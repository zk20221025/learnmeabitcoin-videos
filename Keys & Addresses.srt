00:00:00,030 --> 00:00:06,600
这个视频将解释比特币密钥和地址如何工作的所有信息。

00:00:06,600 --> 00:00:11,400
你可能在本视频中听到像私钥、公钥和地址这样的东西，

00:00:11,400 --> 00:00:16,320
我将在这个视频中解释它们的来源和工作原理。

00:00:16,320 --> 00:00:21,800
我快速概述这个视频中会包含什么内容。

00:00:21,800 --> 00:00:24,630
我将从基础知识开始，

00:00:24,630 --> 00:00:27,029
解释密钥的来源和工作方式，

00:00:27,029 --> 00:00:29,400
并对它们的工作方式进行一个基本的概述。

00:00:29,400 --> 00:00:32,070
我将讲解每个密钥是如何生成的。

00:00:32,070 --> 00:00:35,130
你有一个私钥，

00:00:35,130 --> 00:00:37,320
然后从私钥生成一个公钥，

00:00:37,320 --> 00:00:41,250
这两个是你在比特币中使用的主要密钥，

00:00:41,250 --> 00:00:47,280 
类似于密码和账号。

00:00:47,280 --> 00:00:49,820
从这里你可以得到称为数字签名的东西，

00:00:49,820 --> 00:00:54,149
这被用来证明你拥有公钥，

00:00:54,149 --> 00:00:57,000
就像签署交易一样。

00:00:57,000 --> 00:00:59,160
我将解释这些是如何工作的。

00:00:59,160 --> 00:01:02,460
然后我会讲解地址是如何工作的，

00:01:02,460 --> 00:01:09,750
地址就像公钥的一个更美观或方便用户使用的版本。

00:01:09,750 --> 00:01:12,030
我将解释它们是如何工作的，

00:01:12,030 --> 00:01:14,880
以及它们是如何连接在一起的。

00:01:14,880 --> 00:01:17,070
在最后我将通过一些代码和例子，

00:01:17,070 --> 00:01:21,600
来向你展示如何生成自己的私钥、公钥和地址，

00:01:21,600 --> 00:01:24,990
在本视频的最后。

00:01:24,990 --> 00:01:27,479
这个视频主要是讲解这些内容，

00:01:27,479 --> 00:01:30,180
没有太多的代码，

00:01:30,180 --> 00:01:36,450 
最后可能会有一些关于数字签名的详细解释，

00:01:36,450 --> 00:01:40,290
但只要你对它的工作方式有一个大概了解就可以了。

00:01:40,290 --> 00:01:44,030
我现在开始讲述，

00:01:44,030 --> 00:01:48,390
这也是为什么比特币和其他货币被称为加密货币，

00:01:48,390 --> 00:01:50,520
因为这个私钥和公钥被称为加密，

00:01:50,520 --> 00:01:54,270
使用了密码学，

00:01:54,270 --> 00:01:56,130
所以这就是为什么称他们为加密货币，

00:01:56,130 --> 00:02:05,070
这是交易系统或比特币所有权的基础。

00:02:05,070 --> 00:02:09,060
快进到我们上次停止的地方，

00:02:09,060 --> 00:02:12,000
正如你从我上次的视频中看到的那样，

00:02:12,000 --> 00:02:14,730
这就是比特币网络，

00:02:14,730 --> 00:02:16,500
比特币网络就是一群计算机。

00:02:16,500 --> 00:02:18,830
互相连接在一起，

00:02:18,830 --> 00:02:21,420
并共享一个名为区块链的文件，

00:02:21,420 --> 00:02:24,420
当你想进行比特币交易时，

00:02:24,420 --> 00:02:27,510
你想向某人发送一些比特币，

00:02:27,510 --> 00:02:34,170
你只需要一行描述移动的数据即可进行这样的交易，

00:02:34,170 --> 00:02:36,480
比特币从这个人到这个人。

00:02:36,480 --> 00:02:41,010
当你想将这个交易添加到区块链中时，

00:02:41,010 --> 00:02:44,540
你会将交易插入到网络上的一个节点中，

00:02:44,540 --> 00:02:47,069
他们会将这个交易快速存储在他们的内存池中。

00:02:47,069 --> 00:02:51,450
然后会将交易传递给连接的节点，

00:02:51,450 --> 00:02:54,390
如此反复，

00:02:54,390 --> 00:02:59,640
直到交易存在于网络上每个节点的内存池中。

00:02:59,640 --> 00:03:07,620
然后所有节点都会尝试竞争将他们内存池中的交易添加到区块链上。

00:03:07,620 --> 00:03:09,989
这个过程被称为挖矿，

00:03:09,989 --> 00:03:12,660
假设这个人或者这个矿工，

00:03:12,660 --> 00:03:13,950
他能够将内存池中的交易添加到区块链上。

00:03:13,950 --> 00:03:19,019
这样就会添加一个交易块，

00:03:19,019 --> 00:03:20,940
他们会将该区块传递给连接的节点，

00:03:20,940 --> 00:03:23,100
将其添加到他们的区块链中，

00:03:23,100 --> 00:03:24,870
如此反复，

00:03:24,870 --> 00:03:31,980
直到每个人的区块链副本都更新了最新的交易区块。

00:03:31,980 --> 00:03:33,329
这个人可以查看区块链，

00:03:33,329 --> 00:03:40,260
看到比特币的所有权已经从这个人转移到了这个人。

00:03:40,260 --> 00:03:43,069
在上一次的视频中，

00:03:43,069 --> 00:03:45,299
我解释了这些交易在内部看起来是什么样子的。

00:03:45,299 --> 00:03:47,910
你可以把交易想象成这样：

00:03:47,910 --> 00:03:54,750
区块链充满了所有的交易数据，

00:03:54,750 --> 00:03:56,370
但如果你将其拆开看，

00:03:56,370 --> 00:03:58,950
就会看到很多不同批次、

00:03:58,950 --> 00:04:01,470
不同大小的比特币。

00:04:01,470 --> 00:04:03,690
因此当你进行交易时，

00:04:03,690 --> 00:04:06,000
你需要进入到区块链中，

00:04:06,000 --> 00:04:08,700
选择一个特定的比特币批次，

00:04:08,700 --> 00:04:13,829
比如说这个窗口是一个10比特币的批次，

00:04:13,829 --> 00:04:15,569
然后你将获取出该批次的比特币，

00:04:15,569 --> 00:04:17,608
并从中创建一个新的批次。

00:04:17,608 --> 00:04:25,960
发送一批新的比特币就像从旧的批次中创建一个新的批次。

00:04:25,960 --> 00:04:29,830
你要做的是将该批次的比特币发送到网络中，

00:04:29,830 --> 00:04:33,220
创建一个新的比特币批次进入网络，

00:04:33,220 --> 00:04:35,560
然后这个交易会进入到一个内存池，

00:04:35,560 --> 00:04:37,810
进入到区块链中。

00:04:37,810 --> 00:04:39,340
当你查看区块链时，

00:04:39,340 --> 00:04:41,410
这个新的批次会出现在这个新的区块中，

00:04:41,410 --> 00:04:46,630
而我们用过的整个批次将会变灰，

00:04:46,630 --> 00:04:50,250
因为它已经用完了。

00:04:50,250 --> 00:04:51,940
我一直在称它们为批次，

00:04:51,940 --> 00:04:54,510
但实际上它们被称为输出，

00:04:54,510 --> 00:04:56,320
当你在交易中使用一个输出时，

00:04:56,320 --> 00:04:58,060
它被称为输入。

00:04:58,060 --> 00:05:00,400
所以你可以认为区块链充满了输出，

00:05:00,400 --> 00:05:03,070
它们只是被选择出来，

00:05:03,070 --> 00:05:09,010
然后从它们中创建出新的输出。

00:05:09,010 --> 00:05:12,580
这一切都没有问题 ，

00:05:12,580 --> 00:05:16,630
但是你如何拥有这些比特币批次呢？

00:05:16,630 --> 00:05:18,370
每一批比特币都有一个锁，

00:05:18,370 --> 00:05:23,920
每个想要使用比特币的人都有自己的一组密钥，

00:05:23,920 --> 00:05:26,140
你有一个私钥，就像你的密码，

00:05:26,140 --> 00:05:28,420
还有一个公钥，就像你的账号。

00:05:28,420 --> 00:05:32,050
所以当你想要进行交易时，

00:05:32,050 --> 00:05:35,200
如果这批比特币属于你，

00:05:35,200 --> 00:05:41,080
那么你就可以使用你的私钥来解锁它们，

00:05:41,080 --> 00:05:42,910
然后从这里你可以创建一个新的批次。

00:05:42,910 --> 00:05:46,330
如果你想把比特币发送给这个人，

00:05:46,330 --> 00:05:48,580
他们会给你他们的公钥，

00:05:48,580 --> 00:05:52,000
使用这个公钥，

00:05:52,000 --> 00:05:56,050
你可以在这个批次的输出上创建一个锁，

00:05:56,050 --> 00:05:58,120
这批比特币被锁定到这个人的公钥，

00:05:58,120 --> 00:05:59,770
因为他们像这样把它给了我们。

00:05:59,770 --> 00:06:05,470
如果想要把这批10个比特币发送给别人，

00:06:05,470 --> 00:06:10,630
他们就可以使用他们的私钥来解锁它们，

00:06:10,630 --> 00:06:14,470
然后发送， 这就是一个典型的交易。

00:06:14,470 --> 00:06:20,890
这就是他们如何通过使用这些密钥（私钥和公钥）来完成，

00:06:20,890 --> 00:06:25,130
这就相当于拥有一个账号和密码。

00:06:25,130 --> 00:06:27,470
所以就像我说的，

00:06:27,470 --> 00:06:29,180
一旦你构建了这个交易，

00:06:29,180 --> 00:06:30,680
你就不再拥有一批比特币的所有权，

00:06:30,680 --> 00:06:33,230
而是创建了一批新的比特币，

00:06:33,230 --> 00:06:34,940
锁定给另一个人。

00:06:34,940 --> 00:06:36,950
然后你会将这个交易发送到网络中，

00:06:36,950 --> 00:06:41,230
最终这个交易会被记录到区块链上，

00:06:41,230 --> 00:06:44,150
比特币的批次将会更新。

00:06:44,150 --> 00:06:46,460
这个批次已经被花费掉了，

00:06:46,460 --> 00:06:48,200
它被灰色标记，不能再次被花费，

00:06:48,200 --> 00:06:50,210
新的批次会出现在新的区块中，

00:06:50,210 --> 00:06:54,100
属于另一个人。

00:06:54,100 --> 00:06:59,300
如果你想使用比特币，

00:06:59,300 --> 00:07:02,720
你只需要拥有自己的一组密钥。

00:07:02,720 --> 00:07:07,100
如果你只是想接收别人的比特币，

00:07:07,100 --> 00:07:11,060
你就需要创建并拥有自己的一组密钥就可以使用比特币。

00:07:11,060 --> 00:07:13,850
那么这些密钥是从哪里来的呢？

00:07:13,850 --> 00:07:15,890
我可以告诉你它们不是从哪里来的。

00:07:15,890 --> 00:07:18,170
没有人可以控制比特币，

00:07:18,170 --> 00:07:24,440
有一本书或一台充满了密钥的计算机，

00:07:24,440 --> 00:07:26,360
你可以要求它给你提供私钥和公钥。

00:07:26,360 --> 00:07:31,430
你不需要找任何人给你一个公钥。

00:07:31,430 --> 00:07:33,650
这可能是银行的情况，如果你去银行，

00:07:33,650 --> 00:07:37,060
你必须向某人询问你自己的账号和密码，

00:07:37,060 --> 00:07:40,490
才能使用他们的服务来发送和接收资金。

00:07:40,490 --> 00:07:42,890
但在比特币中，

00:07:42,890 --> 00:07:45,920
我们没有中央机构，

00:07:45,920 --> 00:07:48,950
因为比特币是去中心化的，

00:07:48,950 --> 00:07:52,790
没有一个人可以控制谁可以使用它。

00:07:52,790 --> 00:07:55,340
所以这不是比特币的工作方式。

00:07:55,340 --> 00:07:57,650
那么如果没有人控制密钥或账号，

00:07:57,650 --> 00:07:59,750
你可以要求它给你，

00:07:59,750 --> 00:08:02,780
那么它们是从哪里来的呢？

00:08:02,780 --> 00:08:07,910
答案是我们只是生成自己的私钥和公钥。

00:08:07,910 --> 00:08:10,040
我们不需要询问其他人，

00:08:10,040 --> 00:08:12,350
或者我们需要让你知道从哪里获取这些密钥，

00:08:12,350 --> 00:08:13,670
我们实际上自己创建它们。

00:08:13,670 --> 00:08:18,200
我们创建，就像，

00:08:18,200 --> 00:08:20,090
基本上任何人都可以使用比特币，

00:08:20,090 --> 00:08:21,530
因为我们创建自己的账号和密码。

00:08:21,530 --> 00:08:27,170
我希望这个介绍能让你们都理解，

00:08:27,170 --> 00:08:35,169
现在我将继续介绍创建、生成和使用这些密钥的基础知识。

00:08:35,169 --> 00:08:46,180
如何生成自己的一组密钥以便发送、接收并发送比特币呢？

00:08:46,180 --> 00:08:49,990
首先从一个私钥开始，

00:08:49,990 --> 00:08:54,459
生成自己的私钥最简单或者唯一的方式，

00:08:54,459 --> 00:08:56,079
就是生成一个随机数。

00:08:56,079 --> 00:09:00,490
你只需要生成一个随机数，

00:09:00,490 --> 00:09:02,170
这明显是一个非常小的数字，

00:09:02,170 --> 00:09:04,660
比特币的私钥的数字要大得多，

00:09:04,660 --> 00:09:06,360
但这只是为了展示。

00:09:06,360 --> 00:09:11,260
然后你需要公钥，

00:09:11,260 --> 00:09:14,199
如果私钥是你的密码，

00:09:14,199 --> 00:09:17,199
那么公钥就像你的账号。

00:09:17,199 --> 00:09:19,120
但显然，

00:09:19,120 --> 00:09:21,279
因为没有人会分发这些密钥。

00:09:21,279 --> 00:09:23,649
当我们生成公钥时，

00:09:23,649 --> 00:09:29,170
我们希望私钥和公钥之间有一个联系。

00:09:29,170 --> 00:09:34,630
这样我们就可以用私钥解锁比特币，

00:09:34,630 --> 00:09:37,510
因为它们是连接的。

00:09:37,510 --> 00:09:44,140
那么你如何创建公钥和私钥之间的联系呢？

00:09:44,140 --> 00:09:54,519
你所要做的就是使用一些数学方法从私钥派生出你的公钥。

00:09:54,519 --> 00:09:58,740
基本上你把你的私钥通过一些数学运算函数，

00:09:58,740 --> 00:10:01,510
然后就会得到一个公钥。

00:10:01,510 --> 00:10:07,120
所以这个公钥是通过数学与你的私钥连接的。

00:10:07,120 --> 00:10:13,420
当你生成一组用于比特币的密钥时，

00:10:13,420 --> 00:10:15,519
你从一个随机数的私钥开始，

00:10:15,519 --> 00:10:19,420
然后从中创建你的公钥或者你的账号，

00:10:19,420 --> 00:10:23,860
这只是一个与你的私钥相关的数学连接数。

00:10:23,860 --> 00:10:28,890
这就是你如何生成自己的一组密钥的方式，

00:10:28,890 --> 00:10:32,199
以便你可以从其他人那里接收比特币，

00:10:32,199 --> 00:10:36,110
然后再将它们发送给其他人。

00:10:36,110 --> 00:10:38,000
所以任何人都可以这样做，

00:10:38,000 --> 00:10:40,160
任何人都可以生成自己的一组用于比特币的密钥。

00:10:40,160 --> 00:10:44,600
这些就是基础知识。

00:10:44,600 --> 00:10:46,940
现在我要从这个私钥开始，

00:10:46,940 --> 00:10:51,920
因为生成自己的一组密钥都是从私钥开始的。

00:10:51,920 --> 00:10:57,080
所以将其移到这里，

00:10:57,080 --> 00:11:00,800
像我说的，

00:11:00,800 --> 00:11:03,260
你的私钥只是生成一个随机数，

00:11:03,260 --> 00:11:06,160
这个随机数可以是1到这个数之间的任何一个。

00:11:06,160 --> 00:11:10,430
这是一个非常非常大的数字，

00:11:10,430 --> 00:11:16,190
但只要你生成一个在1和这个值之间的数字，

00:11:16,190 --> 00:11:18,890
它就是一个有效的私钥，

00:11:18,890 --> 00:11:20,900
或者说你有一个有效的起始点，

00:11:20,900 --> 00:11:24,770
你的有效密码可以使用比特币。

00:11:24,770 --> 00:11:29,000
这通常被称为一个256位的数字，

00:11:29,000 --> 00:11:32,240
这只是描述它的大小，

00:11:32,240 --> 00:11:35,090
表示这个数字有多大。

00:11:35,090 --> 00:11:39,070
这来自于计算机，它们存储数据，

00:11:39,070 --> 00:11:44,660
你知道有千字节和字节和兆字节，

00:11:44,660 --> 00:11:46,460
而位是计算机可以容纳的最小数据单位，

00:11:46,460 --> 00:11:49,280
所有的数据都是0或1，

00:11:49,280 --> 00:11:56,570
你的计算机上的所有数据最终都是以0和1的序列存储的。

00:11:56,570 --> 00:12:00,920
同样对于数字，

00:12:00,920 --> 00:12:04,430
当你想在计算机上存储数字时，

00:12:04,430 --> 00:12:09,220
它们也以0和1的形式存储。

00:12:09,220 --> 00:12:12,290
如果你想存储数字，

00:12:12,290 --> 00:12:14,600
从0开始，

00:12:14,600 --> 00:12:15,260
你可以很容易地用位来存储，

00:12:15,260 --> 00:12:18,770
使用数字0，数字1也是类似的。

00:12:18,770 --> 00:12:21,140
你可以只使用位1，

00:12:21,140 --> 00:12:24,020
但对于数字2，

00:12:24,020 --> 00:12:27,410
你已经用完了可以存储这些数据的字符，

00:12:27,410 --> 00:12:29,870
所以你需要添加一个位。

00:12:29,870 --> 00:12:33,170
在二进制或位序列中，

00:12:33,170 --> 00:12:35,330
数字2被存储为10，

00:12:35,330 --> 00:12:39,530
然后是3，存储为11，

00:12:39,530 --> 00:12:41,750
但你已经再次用完了选项，

00:12:41,750 --> 00:12:43,070
所以你需要添加一个位来存储更大的数字，

00:12:43,070 --> 00:12:46,370
就像这样。这个过程会一直持续下去，

00:12:46,370 --> 00:12:47,360
因此数字越大，

00:12:47,360 --> 00:12:52,670
你就需要更多的位来表示它或者在计算机上存储它。

00:12:52,670 --> 00:12:55,870
如果你继续这样做，

00:12:55,870 --> 00:13:02,209
你会有256个位排列在一起，

00:13:02,209 --> 00:13:05,180
如果你在所有这些位上都放上1，

00:13:05,180 --> 00:13:09,470
那么它就能存储这个数字。

00:13:09,470 --> 00:13:13,519
这就是为什么它被称为256位数字，

00:13:13,519 --> 00:13:18,860
它是计算机可以在256位数据中存储的最大数字，

00:13:18,860 --> 00:13:26,470
也就是说2的256次方，

00:13:26,470 --> 00:13:28,970
因为我们每个块都有两个选择，

00:13:28,970 --> 00:13:32,390
可能是0或1，

00:13:32,390 --> 00:13:36,490
如果你这样做256次，

00:13:36,490 --> 00:13:40,220
那么就会给你2的256次方这个数字，

00:13:40,220 --> 00:13:45,310
这是一个非常大的数字。

00:13:45,310 --> 00:13:48,620
那么现在的问题是，

00:13:48,620 --> 00:13:50,209
如果有人生成了和我一样的私钥怎么办？

00:13:50,209 --> 00:13:52,459
这显然看起来，

00:13:52,459 --> 00:13:58,100
像是一种生成自己的私人密码以便使用比特币的粗糙机制。

00:13:58,100 --> 00:14:02,180
答案是这个数字如此之大，

00:14:02,180 --> 00:14:10,089
以至于没有人会生成和你一样的私钥。

00:14:10,089 --> 00:14:13,459
为了说明这一点，

00:14:13,459 --> 00:14:17,560
假设这是已知的可见宇宙，

00:14:17,560 --> 00:14:27,260
这里的数字是这个已知的可见宇宙中的原子数量。

00:14:27,260 --> 00:14:30,709
这样你就可以看到10的78次方的原子数量，

00:14:30,709 --> 00:14:33,829
你可以看到这个256位的数字和宇宙中的原子数量差不多。

00:14:33,829 --> 00:14:37,670
你只需要相信我，

00:14:37,670 --> 00:14:40,730
这个数字非常大，

00:14:40,730 --> 00:14:44,360
虽然我可以在屏幕上显示它，

00:14:44,360 --> 00:14:47,060
但它实在是太大了。

00:14:47,060 --> 00:14:49,220
由于这个数字如此之大，

00:14:49,220 --> 00:14:55,630
意味着两个不同的人不会生成相同的数字。

00:14:55,630 --> 00:14:59,029
这就是它的大小，

00:14:59,029 --> 00:15:01,310
这就是它的安全性。

00:15:01,310 --> 00:15:04,279
在比特币中，这一切都运行得很好，没有问题。

00:15:04,279 --> 00:15:09,170
目前没有任何人生成了相同的私钥，

00:15:09,170 --> 00:15:12,259
至少我不知道。如果有的话，那将是大新闻。

00:15:12,259 --> 00:15:14,810
但就像我说的，这是一个非常大的数字。

00:15:14,810 --> 00:15:21,440
所以私钥只需要在1和这个值之间生成一个数字，

00:15:21,440 --> 00:15:24,290
这个值刚刚生成，

00:15:24,290 --> 00:15:29,300
我会给你私钥，

00:15:29,300 --> 00:15:38,420
所以有什么疑问吗？
 
00:15:38,420 --> 00:15:39,620
私钥只是一个我们刚刚生成的随机数，

00:15:39,620 --> 00:15:42,680
有了它我们就可以得到我们的公钥了。

00:15:42,680 --> 00:15:47,930
就像我说的，

00:15:47,930 --> 00:15:49,610
我们需要将公钥与我们的私钥连接起来，

00:15:49,610 --> 00:15:54,620
因为我们需要将我们的账号和密码连接起来。

00:15:54,620 --> 00:15:58,730
我们达成这一目的的方法是使用一些数学，

00:15:58,730 --> 00:16:03,769
有一种特定类型的数学，

00:16:03,769 --> 00:16:07,550
使用这个东西，

00:16:07,550 --> 00:16:09,889
叫做椭圆曲线。

00:16:09,889 --> 00:16:13,190
有很多不同的椭圆曲线，

00:16:13,190 --> 00:16:15,889
这只是其中一个例子，

00:16:15,889 --> 00:16:19,639
但是比特币使用的特定椭圆曲线叫做secp256k1。

00:16:19,639 --> 00:16:23,870
像我说的，

00:16:23,870 --> 00:16:25,850
有很多不同的椭圆曲线，

00:16:25,850 --> 00:16:31,880
但这是比特币使用的特定的椭圆曲线。

00:16:31,880 --> 00:16:36,470
为了从这个私钥得到你的公钥，

00:16:36,470 --> 00:16:42,230
你必须做所谓的椭圆曲线乘法。

00:16:42,230 --> 00:16:44,240
我们为什么要使用这个椭圆曲线，

00:16:44,240 --> 00:16:46,699
稍后会解释，

00:16:46,699 --> 00:16:48,620
所以现在请耐心等待，

00:16:48,620 --> 00:16:51,250
我会向你展示这个椭圆曲线乘法是如何工作的。

00:16:51,250 --> 00:16:55,730
所以对于SECP256K1，

00:16:55,730 --> 00:16:58,399
它有一个起始点，

00:16:58,399 --> 00:17:00,110
并进行乘法，

00:17:00,110 --> 00:17:01,750
这将是一个简化的解释，

00:17:01,750 --> 00:17:05,329
但基本上这被称为G，

00:17:05,329 --> 00:17:08,869
也称为起始点或生成点，

00:17:08,869 --> 00:17:10,839
但对于乘法来说，

00:17:10,839 --> 00:17:20,359
基本上是在曲线上画一条切线。

00:17:20,359 --> 00:17:25,130
所以我们将从这个生成点开始，

00:17:25,130 --> 00:17:26,839
这个椭圆曲线的一个特性是，

00:17:26,839 --> 00:17:29,510
如果你在上面画一条切线。

00:17:29,510 --> 00:17:31,490
那么它总是会在曲线的另一点相交，

00:17:31,490 --> 00:17:35,930
这只是这种特殊类型曲线的一个特性，

00:17:35,930 --> 00:17:39,070
这就是我们使用它的原因。

00:17:39,070 --> 00:17:42,860
那么当你做到这一点时，

00:17:42,860 --> 00:17:45,740
当它交叉时，你就取那个称为交点的点，

00:17:45,740 --> 00:17:47,840
然后你只需翻转它，

00:17:47,840 --> 00:17:53,390
并从相交处的这一点取曲线上相反的点，

00:17:53,390 --> 00:17:55,810
我将取这个点，

00:17:55,810 --> 00:17:59,150
这个点就像做一轮乘法，

00:17:59,150 --> 00:18:01,880
所以如果这是一个G，

00:18:01,880 --> 00:18:06,560
那么这将是2G，

00:18:06,560 --> 00:18:07,820
如果你想做另一轮乘法，

00:18:07,820 --> 00:18:09,980
画另一条切线，

00:18:09,980 --> 00:18:12,260
它将在曲线上交叉另一个点，

00:18:12,260 --> 00:18:13,910
这会给你很好的结果，

00:18:13,910 --> 00:18:16,520
然后你取那个点的倒数，

00:18:16,520 --> 00:18:18,500
那将给你曲线上的另一个点，

00:18:18,500 --> 00:18:20,350
这是第二轮乘法。

00:18:20,350 --> 00:18:22,730
这有点简化，

00:18:22,730 --> 00:18:26,120
但这基本上就是它的工作原理。

00:18:26,120 --> 00:18:27,290
当你想再次相乘时，

00:18:27,290 --> 00:18:31,580
你只需在曲线上的点处再次取切线，

00:18:31,580 --> 00:18:34,070
如此反复。

00:18:34,070 --> 00:18:35,360
当你做一个椭圆曲线乘法时，

00:18:35,360 --> 00:18:38,570
你在画所有这些切线并取相反的点，

00:18:38,570 --> 00:18:41,540
但最终你在这个曲线上以特定的方式跳动，

00:18:41,540 --> 00:18:48,770
就像这样。

00:18:48,770 --> 00:18:52,550 
你所做的是在曲线上多次跳动，

00:18:52,550 --> 00:18:54,920
根据私钥次数来进行跳动，

00:18:54,920 --> 00:18:58,070
显然我没有在那里结束，

00:18:58,070 --> 00:19:02,160
你会继续做这个，直到你完成了私钥次数的乘法。

00:19:02,160 --> 00:19:05,309
当你做到这一点时，

00:19:05,309 --> 00:19:07,960
当你最后完成时，

00:19:07,960 --> 00:19:10,630
你将在曲线上结束一个点，

00:19:10,630 --> 00:19:14,200
这个点在曲线上是公钥。

00:19:14,200 --> 00:19:16,120
所以曲线上有很多很多点，

00:19:16,120 --> 00:19:23,620
基本上和私钥一样多的点。

00:19:23,620 --> 00:19:25,480
所以一旦你得到了那个公钥，

00:19:25,480 --> 00:19:28,390
就像我说的，

00:19:28,390 --> 00:19:30,040
经过这么多次在曲线上跳动后的最后一个停留点，

00:19:30,040 --> 00:19:32,500
会给你一个公钥，

00:19:32,500 --> 00:19:37,720
准确地说，你的公钥只是这个点的X和Y坐标。

00:19:37,720 --> 00:19:40,120
所以我们得到了X和Y，

00:19:40,120 --> 00:19:42,010
把它们像这样放在一起，

00:19:42,010 --> 00:19:46,960
那就是你的公钥。

00:19:46,960 --> 00:19:49,990
我们使用这个椭圆曲线的原因之一是，

00:19:49,990 --> 00:19:52,360
它的一个特性是，

00:19:52,360 --> 00:19:54,070
这个乘法是所谓的陷门函数，

00:19:54,070 --> 00:19:59,850
这意味着你可以很容易地做私钥乘法，

00:19:59,850 --> 00:20:02,140
也就是说，使用私钥做乘法，

00:20:02,140 --> 00:20:03,870
我可以在曲线上跳动，

00:20:03,870 --> 00:20:05,830
但是反过来，

00:20:05,830 --> 00:20:08,740
从曲线上的这个点，

00:20:08,740 --> 00:20:10,780
找出私钥是什么，

00:20:10,780 --> 00:20:16,510
这是非常困难的，

00:20:16,510 --> 00:20:18,460
因为它还没有被破解，

00:20:18,460 --> 00:20:21,520
没有人知道如何从公钥或曲线上的一个点，

00:20:21,520 --> 00:20:25,510
然后找出私钥是什么，

00:20:25,510 --> 00:20:27,760
公钥是我们通过生成点乘以私钥产生的数字。

00:20:27,760 --> 00:20:33,010
这个椭圆曲线很难解释，

00:20:33,010 --> 00:20:42,940
我认为这个椭圆曲线值得单独拍一个视频。

00:20:42,940 --> 00:20:47,950
但是我要说的是你正在进行大量的模数运算，

00:20:47,950 --> 00:20:49,330
所以在进行这种乘法运算时，

00:20:49,330 --> 00:20:53,250
会有足够多的信息被丢弃。

00:20:53,250 --> 00:20:56,200
所以你不能轻易地逆转，

00:20:56,200 --> 00:21:00,370
这就是为什么我们依赖这个曲线，

00:21:00,370 --> 00:21:06,000
来保护我们的公钥和私钥。

00:21:06,000 --> 00:21:10,250
如果你想了解更多关于为什么不能逆转的信息，

00:21:10,250 --> 00:21:14,690
这被称为椭圆曲线离散对数问题。

00:21:14,690 --> 00:21:16,880
我们从一个随机数开始，

00:21:16,880 --> 00:21:18,110
做一些椭圆曲线数学运算，

00:21:18,110 --> 00:21:20,750
得到曲线上的一个点，

00:21:20,750 --> 00:21:23,360
这就是我们的公钥。

00:21:23,360 --> 00:21:28,730
这就是我们的私钥和公钥之间的数学联系，

00:21:28,730 --> 00:21:34,610
通过椭圆曲线实现的。

00:21:34,610 --> 00:21:36,950
当你有不同的曲线，

00:21:36,950 --> 00:21:39,980
这个被称为SECP256k1，

00:21:39,980 --> 00:21:43,250
它有一个特定的生成点G。

00:21:43,250 --> 00:21:55,309
所以你可以有多个密钥，

00:21:55,309 --> 00:22:02,360
但是它使用这个特定的曲线和这些特定的参数。

00:22:02,360 --> 00:22:06,169
这样就创建了我们的私钥。

00:22:06,169 --> 00:22:10,850
现在已经生成了私钥和公钥，

00:22:10,850 --> 00:22:14,120
我们可以开始使用比特币了。

00:22:14,120 --> 00:22:15,830
如果你想让人们给我们发送比特币，

00:22:15,830 --> 00:22:18,440
只需要给他们提供我们的公钥，

00:22:18,440 --> 00:22:23,030
他们就可以解锁他们拥有的任何比特币，

00:22:23,030 --> 00:22:26,539
创建一个新的批次，

00:22:26,539 --> 00:22:29,419
并把锁放在上面，

00:22:29,419 --> 00:22:34,700
把这批比特币锁定到我们的公钥上。

00:22:34,700 --> 00:22:38,210
当我们想发送比特币的时候，

00:22:38,210 --> 00:22:42,289
我们收到的那些比特币已经被锁定到我们公开的公钥上了，

00:22:42,289 --> 00:22:44,990
我们只需要创建交易，

00:22:44,990 --> 00:22:50,539
然后使用我们的私钥来解锁这个锁，

00:22:50,539 --> 00:22:54,230
或者说证明我们创建了这个公钥，

00:22:54,230 --> 00:22:58,880
或者说我们有这个公钥的数学联系，

00:22:58,880 --> 00:23:01,880
其他人是没有的。

00:23:01,880 --> 00:23:10,280
那么如何证明我们创建了这个公钥，

00:23:10,280 --> 00:23:16,610
如何证明我们拥有这个公钥是由私钥创建的呢？

00:23:16,610 --> 00:23:25,520
一个糟糕的方法是把你的私钥放入你创建的交易中。

00:23:25,520 --> 00:23:30,200
这意味着任何人都可以看到这个私钥和公钥，

00:23:30,200 --> 00:23:32,530
然后他说好吧，

00:23:32,530 --> 00:23:36,169
这个人显然拥有这个私钥，

00:23:36,169 --> 00:23:37,370
因为他们已经给了我们，

00:23:37,370 --> 00:23:41,179
他们可以自己看到数学上的联系，

00:23:41,179 --> 00:23:42,220
他们可以做椭圆曲线乘法，

00:23:42,220 --> 00:23:44,450
得到相同的公钥，

00:23:44,450 --> 00:23:46,820
这证明了我们创建了这个公钥。

00:23:46,820 --> 00:23:50,540
但是问题是，

00:23:50,540 --> 00:23:52,820
当这笔交易进入比特币网络时，

00:23:52,820 --> 00:23:55,010
它将存在于所有的节点中，

00:23:55,010 --> 00:24:05,030
所以任何人都可以看到这个公开的私钥。

00:24:05,030 --> 00:24:07,340
如果他们能看到它，他们可以做的是，

00:24:07,340 --> 00:24:12,830 
如果有任何其他的比特币被锁定到与这个公钥上，

00:24:12,830 --> 00:24:19,610
他们就可以复制我们的私钥，

00:24:19,610 --> 00:24:27,320
并且拿走所有被锁定到这个公钥上的比特币或输出。

00:24:27,320 --> 00:24:29,360
我们能做的最后一件事情就是放弃这个私钥，

00:24:29,360 --> 00:24:33,380
这样就行不通了。

00:24:33,380 --> 00:24:35,410
那么我们能做什么呢？

00:24:35,410 --> 00:24:40,970
我们需要在这笔交易中放入一些东西，

00:24:40,970 --> 00:24:43,220
证明我们创建了这个公钥，

00:24:43,220 --> 00:24:44,780
我们需要放入一些只有我们能创建的东西，

00:24:44,780 --> 00:24:48,679
其他人无法放入解锁这批比特币的东西。

00:24:48,679 --> 00:24:52,130
我们要做什么呢？

00:24:52,130 --> 00:24:53,660
我们再次使用我们的私钥，

00:24:53,660 --> 00:24:59,120
但我们不把实际的私钥放入这个交易数据中，

00:24:59,120 --> 00:25:02,480
而是创建一个签名。

00:25:02,480 --> 00:25:05,049
这些签名非常方便，

00:25:05,049 --> 00:25:07,250
因为它们是根据私钥创建的。

00:25:07,250 --> 00:25:13,620
他们实际上仍然可以证明我们创建了这个公钥。

00:25:13,620 --> 00:25:16,860
这样做的好处是，

00:25:16,860 --> 00:25:18,300
首先它不会泄露我们的私钥，

00:25:18,300 --> 00:25:25,950
其次它们只对我们正在签名的交易有效。

00:25:25,950 --> 00:25:28,380
如果有人看到一个签名，

00:25:28,380 --> 00:25:30,480
并且我们已经将其他的比特币锁定到该公钥，

00:25:30,480 --> 00:25:32,370
他们不能只看这个签名，

00:25:32,370 --> 00:25:35,460
把它放进这个交易，

00:25:35,460 --> 00:25:37,620
或者他们创建的交易，

00:25:37,620 --> 00:25:39,750
因为这不会起作用，

00:25:39,750 --> 00:25:46,410
因为这个签名只对我们创建的一个交易有效。

00:25:46,410 --> 00:25:51,059
你可以把签名看作是一种特殊的一次性私钥，

00:25:51,059 --> 00:25:55,470
我们用它来解锁一批比特币。

00:25:55,470 --> 00:25:56,130
你对此有什么疑问吗？

00:25:56,130 --> 00:25:58,080
我会马上详细介绍，

00:25:58,080 --> 00:25:59,610
只要能解答你的疑惑。

00:25:59,610 --> 00:26:03,030
这就是签名的基本原理。

00:26:03,030 --> 00:26:05,130
我们有一个私钥和一个公钥，

00:26:05,130 --> 00:26:11,910
但现在我们需要弄清楚如何创建数字签名，

00:26:11,910 --> 00:26:16,559
并为此锁定一批交易或一批比特币呢？

00:26:16,559 --> 00:26:20,130
而不泄露私钥，

00:26:20,130 --> 00:26:21,830
这是一个图示，

00:26:21,830 --> 00:26:23,880
我们需要创建一个签名。

00:26:23,880 --> 00:26:28,710
我会快速浏览这个过程，

00:26:28,710 --> 00:26:31,290
并且只会涵盖最基本的部分，

00:26:31,290 --> 00:26:33,150
不用担心，只要你掌握了要点，

00:26:33,150 --> 00:26:34,830
如果第一次听不能完全理解，

00:26:34,830 --> 00:26:36,600
只要你大致明白就好。

00:26:36,600 --> 00:26:39,120
这涉及到一些数学。

00:26:39,120 --> 00:26:43,320
让我们用其他方法移动它，

00:26:43,320 --> 00:26:44,820
可能我有很多方式来进行，

00:26:44,820 --> 00:26:47,730
但我现在还不清楚。

00:26:47,730 --> 00:26:49,530
我们需要创建一个签名，

00:26:49,530 --> 00:26:51,480
创建签名有两个步骤，

00:26:51,480 --> 00:26:53,850
这涉及到椭圆曲线的使用。

00:26:53,850 --> 00:26:56,220
这并不奇怪，

00:26:56,220 --> 00:26:57,210
这就是我们首先使用椭圆曲线的原因，

00:26:57,210 --> 00:26:59,520
因为我们可以再次使用它来创建签名。

00:26:59,520 --> 00:27:10,440
这个创建签名的第一部分是你需要一个随机部分，

00:27:10,440 --> 00:27:14,559
所以你首先要做的是选择一个非常大的随机数，

00:27:14,559 --> 00:27:17,830
然后再做一些椭圆曲线乘法，

00:27:17,830 --> 00:27:19,240
就像我们之前做的一样，

00:27:19,240 --> 00:27:23,440
这会给你曲线上的一个随机点。

00:27:23,440 --> 00:27:26,440 
这与我们之前做的非常相似，

00:27:26,440 --> 00:27:28,330
我们只是取了一个私钥并创建了一个公钥，

00:27:28,330 --> 00:27:29,919
这是完全一样的，

00:27:29,919 --> 00:27:31,659
但我们只是使用一个随机数，

00:27:31,659 --> 00:27:36,879
这将用于一次性交易的签名，

00:27:36,879 --> 00:27:43,059
因此我们在曲线上生成的这个随机点被称为R，

00:27:43,059 --> 00:27:44,529
更具体地说，

00:27:44,529 --> 00:27:46,529
我们只需要它的x值。

00:27:46,529 --> 00:27:51,070
然后使用这个随机点或x值，

00:27:51,070 --> 00:27:53,559
这只是一个数字，

00:27:53,559 --> 00:27:55,749
我们将其与我们的私钥相乘，

00:27:55,749 --> 00:27:58,720
也只是一个数字，

00:27:58,720 --> 00:28:02,350
然后添加一个被称为消息的东西，

00:28:02,350 --> 00:28:04,509
我们想要签名的东西。

00:28:04,509 --> 00:28:06,070
我们想要为这个交易创建一个签名，

00:28:06,070 --> 00:28:10,899
所以我们基本上将这个交易作为消息放在这里，

00:28:10,899 --> 00:28:12,549
这就是全部，这只是一堆数据，

00:28:12,549 --> 00:28:18,009
但我们并不将实际的全部数据放在这里，

00:28:18,009 --> 00:28:22,779
我们做的只是将其哈希并将哈希值放在这里。

00:28:22,779 --> 00:28:25,779
但基本上，

00:28:25,779 --> 00:28:28,419
我们得到了这个x值的随机部分，

00:28:28,419 --> 00:28:30,129
我们将其与私钥相乘，

00:28:30,129 --> 00:28:38,529
然后只需添加我们想要签名的交易的指纹，

00:28:38,529 --> 00:28:42,460
然后再将所有这些写入我们的R。

00:28:42,460 --> 00:28:44,769
所以这里的关键是，

00:28:44,769 --> 00:28:46,779
在曲线中有一个随机点，

00:28:46,779 --> 00:28:48,700
在这里有一个特殊的数字，

00:28:48,700 --> 00:28:50,740
其中包含我们的私钥，

00:28:50,740 --> 00:28:53,259
我们希望签名起作用的交易的组合，

00:28:53,259 --> 00:28:58,809
这被称为S。

00:28:58,809 --> 00:29:00,700
所以你可以看到，

00:29:00,700 --> 00:29:03,309
私钥和交易数据在这里，

00:29:03,309 --> 00:29:04,680
但它们都被打乱了。

00:29:04,680 --> 00:29:06,960
如果我们查看这个S值，

00:29:06,960 --> 00:29:08,430
将无法看到我们的实际私钥是什么，

00:29:08,430 --> 00:29:12,720
因为我们使用了这个R来打乱它。

00:29:12,720 --> 00:29:15,720
但它都在那里，

00:29:15,720 --> 00:29:17,940
签名就是这两部分，

00:29:17,940 --> 00:29:20,250
你在这里放入R，

00:29:20,250 --> 00:29:21,180
并在这里放入S值。

00:29:21,180 --> 00:29:22,380
所以R只是曲线中的一个随机点，

00:29:22,380 --> 00:29:25,680
S是一个特殊的数字，

00:29:25,680 --> 00:29:28,500
包含我们的私钥和我们想要签名的交易数据，

00:29:28,500 --> 00:29:31,620
这就是我们的签名，

00:29:31,620 --> 00:29:35,280
签名只是一个R值和一个S值。

00:29:35,280 --> 00:29:45,690
所以移出这里，这就是第一部分，

00:29:45,690 --> 00:29:47,490
然后今天再继续一遍，这很棒。

00:29:47,490 --> 00:29:55,160
你提到的第一部分是我们有相同的部分，

00:29:55,160 --> 00:29:58,020
生成一个随机数，

00:29:58,020 --> 00:30:00,090
是的，这只是一个随机数。

00:30:00,090 --> 00:30:03,960
我们把这个随机数和G相乘，

00:30:03,960 --> 00:30:05,820
然后一直在曲线上跳跃，

00:30:05,820 --> 00:30:07,860
直到达到某个特定的点。

00:30:07,860 --> 00:30:13,910
在这个阶段，

00:30:13,910 --> 00:30:17,010
我们的公钥或私钥还没有进入画面，

00:30:17,010 --> 00:30:19,710
这是随机的。

00:30:19,710 --> 00:30:30,150
然后我们从私钥中取出X，

00:30:30,150 --> 00:30:32,160
我们再次跳跃。

00:30:32,160 --> 00:30:35,000
对不起，

00:30:35,000 --> 00:30:36,990
这不是椭圆曲线乘法，

00:30:36,990 --> 00:30:40,020
这只是纯数学。

00:30:40,020 --> 00:30:41,790
如果你还记得，我们的私钥只是一个数字，

00:30:41,790 --> 00:30:43,590
这个x值也只是一个数字，

00:30:43,590 --> 00:30:46,410
所以我们只做普通的数学运算，

00:30:46,410 --> 00:30:53,850
这不是椭圆乘法。

00:30:53,850 --> 00:31:00,240
消息就是我们的交易数据。

00:31:00,240 --> 00:31:02,490
将交易数据放入这里，

00:31:02,490 --> 00:31:07,070
这意味着这个签名只能用于特定的交易。

00:31:07,070 --> 00:31:13,440
显然私钥在这里只是为了证明我们拥有这个公钥。

00:31:13,440 --> 00:31:16,380
从前一个视频中，

00:31:16,380 --> 00:31:19,650
这就是没有签名的交易数据。

00:31:19,650 --> 00:31:21,060
你是对的。

00:31:21,060 --> 00:31:24,690
然后把所有的签名都拿出来，

00:31:24,690 --> 00:31:26,370
然后对数据进行哈希处理，

00:31:26,370 --> 00:31:29,960
然后放入这里。记忆力很好。

00:31:29,960 --> 00:31:39,120
这些值的作用是帮助我们打乱私钥。

00:31:39,120 --> 00:31:46,440
所以一个签名由两部分组成：

00:31:46,440 --> 00:31:52,620
随机的曲线上的点和一个通过使用私钥得到的特殊数字。

00:31:52,620 --> 00:31:59,900
现在我们会明白为什么这个方法有效，

00:31:59,900 --> 00:32:02,190
为什么我们要为签名创建了这两样东西。

00:32:02,190 --> 00:32:08,550
当我们发送这个交易数据或者整个交易进入比特币网络时，

00:32:08,550 --> 00:32:10,010
签名的部分就完成了，

00:32:10,010 --> 00:32:15,390
网络上的每一个节点都会进行验证，

00:32:15,390 --> 00:32:18,270
确保这是一个有效的交易。

00:32:18,270 --> 00:32:21,090
他们获取这个签名，

00:32:21,090 --> 00:32:22,260
并希望能够说好的，能通过验证。

00:32:22,260 --> 00:32:31,590
这个签名只能由拥有这个公钥所对应的私钥的人创建。

00:32:31,590 --> 00:32:36,510
所以他们需要验证这一点，

00:32:36,510 --> 00:32:40,290
以确保他们的签名始终是由这个特定的私钥创建的。

00:32:40,290 --> 00:32:43,950
那他们如何做到这一点呢？

00:32:43,950 --> 00:32:45,420
他们并没有私钥，

00:32:45,420 --> 00:32:47,880
他们只有这两个值，R值和S值，

00:32:47,880 --> 00:32:50,160
但是S值是由这个私钥创建的。

00:32:50,160 --> 00:32:53,400
那他们如何做到这一点呢？

00:32:53,400 --> 00:32:57,270
首先他们会获取这个给定的R值，

00:32:57,270 --> 00:32:59,130
然后开始进行一系列的步骤。

00:32:59,130 --> 00:33:02,180
这对他们来说也是一个两步的过程。

00:33:02,180 --> 00:33:04,620
首先，

00:33:04,620 --> 00:33:08,290
他们会做一些常规的数学运算，

00:33:08,290 --> 00:33:15,040
他们只是将交易数据的哈希（不包括R值）与S值相乘，

00:33:15,040 --> 00:33:17,740
这将给出一个非常大的数字。

00:33:17,740 --> 00:33:22,570
然后在将这两个值相乘后的第一步中，

00:33:22,570 --> 00:33:23,940
他们会使用这个大数字，

00:33:23,940 --> 00:33:26,380
从生成点开始，

00:33:26,380 --> 00:33:28,570
进行椭圆曲线乘法，

00:33:28,570 --> 00:33:30,250
使用这个大数字进行乘法，

00:33:30,250 --> 00:33:34,090
从G开始相乘，

00:33:34,090 --> 00:33:35,680
在曲线上弹跳，

00:33:35,680 --> 00:33:39,510
这将给出曲线上的第一个点。

00:33:39,510 --> 00:33:45,700
再进行一些常规的乘法运算，

00:33:45,700 --> 00:33:49,270
他们只需将S乘以R，

00:33:49,270 --> 00:33:51,730
所以只需将S值乘以R值，

00:33:51,730 --> 00:33:53,920
然后从公钥开始，

00:33:53,920 --> 00:33:59,740
在椭圆曲线上跳跃这么多次，

00:33:59,740 --> 00:34:01,360
这样在椭圆曲线上跳跃这么多次，

00:34:01,360 --> 00:34:03,930
这将给出曲线上的第二个点。

00:34:03,930 --> 00:34:08,020
现在关键的部分是，

00:34:08,020 --> 00:34:13,600
如果这三个点在曲线上都对齐，

00:34:13,600 --> 00:34:17,310
那么这个签名就是有效的。

00:34:17,310 --> 00:34:25,060
对于椭圆曲线，

00:34:25,060 --> 00:34:26,590
如果你画出经过曲线上两点的一条直线，

00:34:26,590 --> 00:34:28,510
就像切线一样，

00:34:28,510 --> 00:34:30,010
它总是会与曲线上的另一点相交。

00:34:30,010 --> 00:34:33,100
如果你在曲线上的两点之间画一条线，

00:34:33,100 --> 00:34:38,380
它总会与曲线上的另一点相交。

00:34:38,380 --> 00:34:45,010
通过使用我们给出的这两个值，

00:34:45,010 --> 00:34:47,290
以及公钥和交易数据，

00:34:47,290 --> 00:34:51,760
我们可以在曲线上生成这两个点。

00:34:51,760 --> 00:34:54,460
如果它们都对齐，

00:34:54,460 --> 00:34:57,400
那么签名就是有效的。

00:34:57,400 --> 00:35:02,560
这意味着如果有人篡改交易数据，

00:35:02,560 --> 00:35:04,420
我们给他们提供交易数据和签名，

00:35:04,420 --> 00:35:07,930
然后他们试图将比特币发送到他们的地址，

00:35:07,930 --> 00:35:10,120
他们篡改了交易数据，

00:35:10,120 --> 00:35:12,880
这意味着这个值将会不同，

00:35:12,880 --> 00:35:14,440
所以当他们生成第一个点时，

00:35:14,440 --> 00:35:17,510
它会不同，它们就不会对齐，

00:35:17,510 --> 00:35:21,000
所以签名就不会有效。

00:35:21,000 --> 00:35:26,450
这就保护了交易数据不被改变。

00:35:26,450 --> 00:35:33,120
如果有人试图使用他们的私钥来创建一个签名，

00:35:33,120 --> 00:35:36,030
来花费我们的比特币，

00:35:36,030 --> 00:35:38,370
而不是我们创建公钥时用的私钥，

00:35:38,370 --> 00:35:40,440
来自完全不同的私钥，

00:35:40,440 --> 00:35:42,510
那么当他们生成这个s值时，

00:35:42,510 --> 00:35:44,370
它将完全不同。

00:35:44,370 --> 00:35:46,200
如果这个s值不同，

00:35:46,200 --> 00:35:49,650
那么这个数就会不同。

00:35:49,650 --> 00:35:53,430
所以当我们从公钥开始进行椭圆曲线乘法时，

00:35:53,430 --> 00:35:55,470
这个点将会不同，

00:35:55,470 --> 00:35:57,960
这些点就不会对齐。

00:35:57,960 --> 00:36:07,770
这就是数字签名如何工作的基本概述，

00:36:07,770 --> 00:36:14,370
如果你理解的是私钥和公钥是通过椭圆曲线相连的，

00:36:14,370 --> 00:36:18,600
以及我们使用椭圆曲线的原因，

00:36:18,600 --> 00:36:21,030
是因为我们可以创建这些签名，

00:36:21,030 --> 00:36:24,090
其他人可以通过进行一些椭圆曲线数学验证它们，

00:36:24,090 --> 00:36:31,950
这些都是椭圆曲线的特殊属性。

00:36:31,950 --> 00:36:34,380
总的来说，就像我说的，

00:36:34,380 --> 00:36:36,810
你只需要使用私钥，

00:36:36,810 --> 00:36:42,300
进行椭圆曲线数学乘法得到公钥，

00:36:42,300 --> 00:36:43,620
然后你给其他人这个公钥，

00:36:43,620 --> 00:36:48,600
他们会将一批比特币锁定到这个公钥上。

00:36:48,600 --> 00:36:50,490
然后从这里，

00:36:50,490 --> 00:36:52,950
我们需要将它们发送给其他人。

00:36:52,950 --> 00:36:55,020
我们想要发送它们，

00:36:55,020 --> 00:36:57,330
我们需要证明我们是这个公钥的创建者。

00:36:57,330 --> 00:36:59,150
所以我们做的是，

00:36:59,150 --> 00:37:02,100
使用私钥创建一个签名，

00:37:02,100 --> 00:37:04,670
这又涉及到一些椭圆曲线数学。

00:37:04,670 --> 00:37:07,320
我们提供给他们签名，

00:37:07,320 --> 00:37:10,740
他们可以做一些验证，

00:37:10,740 --> 00:37:14,850
以验证我们是否从正确的私钥创建了这个签名。

00:37:14,850 --> 00:37:17,280
他们通过获取这个公钥、

00:37:17,280 --> 00:37:20,640
签名和数据来做到这一点，

00:37:20,640 --> 00:37:22,680
生成曲线上的三个点。

00:37:22,680 --> 00:37:27,120
如果它们对齐，

00:37:27,120 --> 00:37:29,240
那么这个签名就有效。

00:37:29,240 --> 00:37:32,830
如果有人没有使用正确的私钥，

00:37:32,830 --> 00:37:35,660
他们就不会对齐，

00:37:35,660 --> 00:37:37,730
或者如果有人篡改交易数据，

00:37:37,730 --> 00:37:41,540
他们也不会对齐。

00:37:41,540 --> 00:37:44,660
这整个过程有点神奇，

00:37:44,660 --> 00:37:47,030
但最终这都是数学。

00:37:47,030 --> 00:37:52,010
如果你想从这几张图示中学到了什么，

00:37:52,010 --> 00:37:54,170
那就是椭圆曲线数学，

00:37:54,170 --> 00:37:57,290
对于密码学非常有用，

00:37:57,290 --> 00:38:04,010
非常适合创建账号和密码，

00:38:04,010 --> 00:38:05,660
然后能够证明你拥有账号，

00:38:05,660 --> 00:38:07,670
而无需给出密码，

00:38:07,670 --> 00:38:11,960
这非常聪明。

00:38:11,960 --> 00:38:14,300
所以这就叫做椭圆曲线密码学，

00:38:14,300 --> 00:38:18,110
它非常有用。

00:38:18,110 --> 00:38:23,840
如果没有它，我们就无法安全地发送和接收比特币，

00:38:23,840 --> 00:38:26,050
除非有人控制所有的钥匙。

00:38:26,050 --> 00:38:30,619
所以这意味着通过这种椭圆曲线密码学，

00:38:30,619 --> 00:38:33,230
我们可以生成我们自己的账号和密码，

00:38:33,230 --> 00:38:34,820
以便发送和接收比特币，

00:38:34,820 --> 00:38:38,600
这非常方便。

00:38:38,600 --> 00:38:39,890
就像我在视频开始所说的那样，

00:38:39,890 --> 00:38:47,480
这就是为什么比特币和其他货币被称为加密货币，

00:38:47,480 --> 00:38:58,200
因为它们使用密码学作为这些比特币批次所有权的支柱。

00:38:58,200 --> 00:39:01,030
所以让我把所有这些都移到这里，

00:39:01,030 --> 00:39:08,530
这就是私钥，公钥和签名。

00:39:08,530 --> 00:39:14,050
所以这是发送或接收比特币的基本原理，

00:39:14,050 --> 00:39:24,970
它只需要一组密钥和数字签名来证明你拥有公钥的所有权。

00:39:24,970 --> 00:39:26,680
你可能听说过地址，

00:39:26,680 --> 00:39:29,680
那么什么是地址呢？

00:39:29,680 --> 00:39:36,010
地址基本上就是公钥的更美观、方便用户使用的版本。

00:39:36,010 --> 00:39:39,880
最初或者你现在仍然可以在比特币中做到这一点，

00:39:39,880 --> 00:39:43,420
你可以生成一个私钥和一个公钥，

00:39:43,420 --> 00:39:45,700
将公钥给其他人，

00:39:45,700 --> 00:39:50,410
他们会将比特币锁定到你的公钥中，

00:39:50,410 --> 00:39:56,820
然后你可以使用私钥创建签名并发送它们。

00:39:56,820 --> 00:39:59,880
这个过程运行良好，

00:39:59,880 --> 00:40:03,160
如果有人查看这个公钥，

00:40:03,160 --> 00:40:06,670
他们不能像我之前说的那样推算出私钥，

00:40:06,670 --> 00:40:10,750
因为你不能通过椭圆曲线乘法反向运算。

00:40:10,750 --> 00:40:13,780
你可以以这个方式，其他人不行，

00:40:13,780 --> 00:40:17,740
这也意味着，

00:40:17,740 --> 00:40:20,140
目前还不知道这个问题是否已被解决。

00:40:20,140 --> 00:40:23,500
虽然目前看来这个问题不太可能被解决，

00:40:23,500 --> 00:40:25,780
对于椭圆曲线，

00:40:25,780 --> 00:40:28,240
这意味着，

00:40:28,240 --> 00:40:32,350
如果椭圆曲线能被破解，

00:40:32,350 --> 00:40:35,230
那么你的公钥和比特币就可能被盗。

00:40:35,230 --> 00:40:39,580
我的意思是在可预见的未来，

00:40:39,580 --> 00:40:41,260
没有人能看到这种情况发生，

00:40:41,260 --> 00:40:45,220
但这确实意味着这个公钥就像一只待宰的鸭子，

00:40:45,220 --> 00:40:48,910
如果椭圆曲线能被破解，那么它就可能被攻破。

00:40:48,910 --> 00:40:51,790
所以在比特币中，

00:40:51,790 --> 00:40:54,910
我们喜欢使用更多的安全措施，

00:40:54,910 --> 00:41:01,440
我们不仅仅依赖椭圆曲线离散对数问题来保护我们的比特币。

00:41:01,440 --> 00:41:07,370
所以解决方案是将公钥进行两次哈希，

00:41:07,370 --> 00:41:09,570
通过两种不同的哈希函数，

00:41:09,570 --> 00:41:14,370
第一种是你应该熟悉的SHA256，

00:41:14,370 --> 00:41:16,290
这是挖矿时用到的，

00:41:16,290 --> 00:41:18,720
第二种是RIPEMD160。

00:41:18,720 --> 00:41:25,950
所以就像是通过两个不同的哈希函数，

00:41:25,950 --> 00:41:27,960
对公钥进行双重哈希，

00:41:27,960 --> 00:41:37,380
然后你将哈希后的公钥而不是标准的公钥给其他人，

00:41:37,380 --> 00:41:40,560
这就像是公钥的加密版本。

00:41:40,560 --> 00:41:45,450
其他人会将这些放在锁中，

00:41:45,450 --> 00:41:52,050
这意味着当公钥的哈希版本在锁中时，

00:41:52,050 --> 00:41:56,550
如果有人想获取你的私钥，

00:41:56,550 --> 00:41:59,490
不仅仅是从公钥开始试图反向操作，

00:41:59,490 --> 00:42:02,250
这是不能做到的。

00:42:02,250 --> 00:42:05,820
但这是唯一的办法。

00:42:05,820 --> 00:42:08,790
如果你想从这个公钥的哈希版本中找出你的私钥，

00:42:08,790 --> 00:42:12,900
你需要破解RIPEMD哈希函数，

00:42:12,900 --> 00:42:15,660
这是没有人能做到的。

00:42:15,660 --> 00:42:20,280
你还需要能够反向操作SHA-256哈希函数，

00:42:20,280 --> 00:42:22,620
在做完这些之后，

00:42:22,620 --> 00:42:24,600
我会给你私钥，然后使用这个私钥，

00:42:24,600 --> 00:42:26,840
你需要反向操作并破解这个椭圆曲线，

00:42:26,840 --> 00:42:30,300
这也是没有人做到的。

00:42:30,300 --> 00:42:40,170
这个哈希版本是公钥的一个非常安全的版本。

00:42:40,170 --> 00:42:41,850
我们之所以创建这个版本，

00:42:41,850 --> 00:42:47,130
是因为所有的比特币批次都将包含一个公钥。

00:42:47,130 --> 00:42:49,890
这只是一个非常安全的公钥版本，

00:42:49,890 --> 00:42:52,170
因为很难追溯到私钥。

00:42:52,170 --> 00:42:53,460
如果有一个待宰的鸭子，

00:42:53,460 --> 00:42:54,960
我们就让它变得非常安全。

00:42:54,960 --> 00:42:58,950
这有两个公钥，

00:42:58,950 --> 00:43:04,680
我们称之为哈希160的公钥。

00:43:04,680 --> 00:43:10,110
这只是因为我们使用了哈希函数，

00:43:10,110 --> 00:43:13,960
最后一个我们使用的是RIPEMD-160，

00:43:13,960 --> 00:43:16,450
所以它通常被简化为哈希160公钥。

00:43:16,450 --> 00:43:24,040
我们现在已经对公钥进行了哈希，

00:43:24,040 --> 00:43:27,490
但问题是在此之前，

00:43:27,490 --> 00:43:29,320
我们只需要将公钥放在这里，

00:43:29,320 --> 00:43:31,360
然后在这里创建一个签名。

00:43:31,360 --> 00:43:38,830
但是经过哈希处理的公钥与私钥之间没有数学联系，

00:43:38,830 --> 00:43:45,130
所以我们不能只是在这里放一个签名。

00:43:45,130 --> 00:43:49,390
当我们想要发送比特币时，

00:43:49,390 --> 00:43:49,780
我们应该做什么呢？

00:43:49,780 --> 00:43:53,230
我们现在应该在这个解锁代码中放什么呢？

00:43:53,230 --> 00:43:55,930
我们仍然在这里放签名，

00:43:55,930 --> 00:43:58,630
但是除了签名，

00:43:58,630 --> 00:44:00,580
我们还放入公钥。

00:44:00,580 --> 00:44:06,430
所以这意味着这个锁现在已经进行了一些调整，

00:44:06,430 --> 00:44:09,090
要求提供公钥和签名。

00:44:09,090 --> 00:44:11,950
我要做的第一件事，

00:44:11,950 --> 00:44:18,910
就是检查你在这里输入的公钥是否与哈希版本相匹配。

00:44:18,910 --> 00:44:20,710
任何人都可以做到。

00:44:20,710 --> 00:44:21,970
这是通过这两个哈希函数来完成的，

00:44:21,970 --> 00:44:24,910
然后它会执行之前做过的事情，

00:44:24,910 --> 00:44:27,460
检查签名是否有效。

00:44:27,460 --> 00:44:34,180
因此在只使用公钥时，

00:44:34,180 --> 00:44:39,070
只需要一步就可以比较签名和公钥。

00:44:39,070 --> 00:44:40,780
现在这是一个两步的过程，

00:44:40,780 --> 00:44:42,730
首先比较公钥和你给出的公钥的哈希版本，

00:44:42,730 --> 00:44:44,590
如果检查通过，

00:44:44,590 --> 00:44:50,020
那么它根据公钥检查签名。

00:44:50,020 --> 00:44:52,770
它只是增加了一个步骤。

00:44:52,770 --> 00:44:59,220
所以从这个意义上说，

00:44:59,220 --> 00:45:04,720
我们确实有用于HASH160的公钥，

00:45:04,720 --> 00:45:10,720
这是公开的信息。

00:45:10,720 --> 00:45:12,100
如果你现在想问的是，

00:45:12,100 --> 00:45:13,810
如果最终我们还是要公开公钥，

00:45:13,810 --> 00:45:16,630
那么哈希这个公钥有什么意义呢？

00:45:16,630 --> 00:45:18,070
无论如何，

00:45:18,070 --> 00:45:21,300
最终都会得到公钥。

00:45:23,610 --> 00:45:26,230
这个思路是，

00:45:26,230 --> 00:45:29,990
这个公钥只在最后一刻被公开。

00:45:29,990 --> 00:45:37,320
假设需要一些时间来通过暴力破解得到这个椭圆曲线的反向计算。

00:45:37,320 --> 00:45:40,350
如果它被某种方式破解了，

00:45:40,350 --> 00:45:42,330
首先如果它完全破解了，

00:45:42,330 --> 00:45:44,460
那么你的比特币是安全的，

00:45:44,460 --> 00:45:45,840
因为如果你不花费它们，

00:45:45,840 --> 00:45:47,160
那么其他人就无法取走它们。

00:45:47,160 --> 00:45:50,490
但显然这并不是很好。

00:45:50,490 --> 00:45:52,140
但这里的思路是，

00:45:52,140 --> 00:45:53,610
你只在最后一刻公开。

00:45:53,610 --> 00:45:55,050
如果它在最后一刻被公开，

00:45:55,050 --> 00:46:02,790
那么希望其他人不会有时间快速反向工作以窃取你的比特币。

00:46:02,790 --> 00:46:07,340
从好的方面来说，

00:46:07,340 --> 00:46:09,510
我认为这总比没有好。

00:46:09,510 --> 00:46:13,410
所以这就是我们使用这个哈希版本的原因。

00:46:13,410 --> 00:46:19,619
这个哈希版本并不会给任何人提供任何动力去尝试反向工作，

00:46:19,619 --> 00:46:21,510
因为他们首先必须通过这些哈希函数。

00:46:21,510 --> 00:46:24,570
这是很困难的。

00:46:24,570 --> 00:46:27,060
我的想法是，

00:46:27,060 --> 00:46:32,369
假设我们有10个比特币在这个工作后面。

00:46:32,369 --> 00:46:37,580
我们花费了一个比特币，

00:46:37,580 --> 00:46:40,410
这个过程中，

00:46:40,410 --> 00:46:50,010
攻击者可以获取到公钥的哈希版本。

00:46:50,010 --> 00:46:54,690
你想说的是，你想在这里发送10个比特币，

00:46:54,690 --> 00:46:56,970
我们想发送一个比特币给其他人，

00:46:56,970 --> 00:46:59,520
然后我们想为自己保留剩余的比特币。

00:46:59,520 --> 00:47:02,550
这里建议的是，

00:47:02,550 --> 00:47:06,930
创建一个新地址，

00:47:06,930 --> 00:47:10,109
这就是为什么每个人都说不要使用重复相同的地址，

00:47:10,109 --> 00:47:14,250
因为当你更改发送给自己时，

00:47:14,250 --> 00:47:16,200
如果你使用不同的地址，

00:47:16,200 --> 00:47:18,300
即使你放弃了自己的公钥，

00:47:18,300 --> 00:47:20,040
实际上它也没有用，

00:47:20,040 --> 00:47:26,280
因为所有锁定到这个公钥的比特币都被花掉并转移了。

00:47:26,280 --> 00:47:31,770
这就是为什么每个人都说不要使用不同的地址，

00:47:31,770 --> 00:47:34,600
或每次都使用不同的地址进行更改。

00:47:34,600 --> 00:47:37,450
最后一刻的逻辑，

00:47:37,450 --> 00:47:40,990
感觉这是因为如果它是一个新地址，

00:47:40,990 --> 00:47:46,060
你又不知道公钥。

00:47:46,060 --> 00:47:48,070
所以这是有意义的，

00:47:48,070 --> 00:47:53,650
很明显现在你仍然可以使用，

00:47:53,650 --> 00:47:57,070
如果你仍然可以使用这个方法，

00:47:57,070 --> 00:47:58,570
你仍然可以创建执行此操作的锁，

00:47:58,570 --> 00:48:06,970
但现在所有的钱包都使用它来哈希公钥，

00:48:06,970 --> 00:48:08,770
这样更安全。

00:48:08,770 --> 00:48:10,480
但你仍然可以使用它，

00:48:10,480 --> 00:48:12,010
把公钥放在这里，只使用一个签名，

00:48:12,010 --> 00:48:15,070
这就是区块链中很多早期交易的形式，

00:48:15,070 --> 00:48:16,480
如果你检查他们，

00:48:16,480 --> 00:48:18,400
他们使用一个非常简单的公钥和签名，

00:48:18,400 --> 00:48:29,910
但现在所有的交易都使用这个公钥的哈希版本。

00:48:29,910 --> 00:48:35,410
然后在解锁代码中加入公钥和签名。

00:48:35,410 --> 00:48:42,550
刚刚我对这些锁如何工作做了一个冗长的描述，

00:48:42,550 --> 00:48:48,460
我将在下一个视频中会详细解释这些锁是如何工作的。

00:48:48,460 --> 00:48:50,080
所以这就是锁定代码，

00:48:50,080 --> 00:48:51,880
这就是锁的解锁代码。

00:48:51,880 --> 00:48:56,880
最后像我说的，

00:48:56,880 --> 00:49:00,340
什么是地址？

00:49:00,340 --> 00:49:01,780
我必须通过这个来向你展示一个地址的来源。

00:49:01,780 --> 00:49:06,750
就像我在上一次说的，

00:49:06,750 --> 00:49:10,180
可能你想接收比特币，

00:49:10,180 --> 00:49:12,670
我们给出这个公钥的哈希版本。

00:49:12,670 --> 00:49:14,980
但是如果你浏览一下所有的数据，

00:49:14,980 --> 00:49:17,860
比如说这是一个私钥，

00:49:17,860 --> 00:49:20,590
然后这是一个公钥，

00:49:20,590 --> 00:49:23,740
也是一个大数字。

00:49:23,740 --> 00:49:27,460
这些通常以十六进制格式存储，

00:49:27,460 --> 00:49:30,400
所以让我快速转换一下。

00:49:30,400 --> 00:49:37,049
当我们通过这两个哈希函数对所有这些数据进行哈希，

00:49:37,049 --> 00:49:45,130
我们最后得到这个公钥的哈希版本的十六进制数字。

00:49:45,130 --> 00:49:46,089
这个方法是可行的，我们可以把这个提供给别人，

00:49:46,089 --> 00:49:47,019
这没问题。

00:49:47,019 --> 00:49:49,420
这就是你想让它变得更简单，

00:49:49,420 --> 00:49:53,200
你可以直接给人们这个公钥的哈希版本。

00:49:53,200 --> 00:49:55,390
但是问题是，

00:49:55,390 --> 00:49:56,729
用户使用起来会很麻烦。

00:49:56,729 --> 00:50:00,099
因为你把它给别人，

00:50:00,099 --> 00:50:03,640
或者你在电话上描述这个公钥，

00:50:03,640 --> 00:50:06,059
假设别人把它输入，

00:50:06,059 --> 00:50:09,190
然后他们犯了一个错误，然后他们填写完了。

00:50:09,190 --> 00:50:12,039
如果他们犯了一个简单的错误，

00:50:12,039 --> 00:50:16,079
那么它就会把比特币发送到一个完全不同的地址，

00:50:16,079 --> 00:50:18,430
所以它会丢失那些比特币，

00:50:18,430 --> 00:50:20,789
这个人就不会收到它们。

00:50:20,789 --> 00:50:24,880
所以这不好，没有错误检查，

00:50:24,880 --> 00:50:27,220
当你输入这个公钥的哈希版本时，

00:50:27,220 --> 00:50:30,099
没有办法检查它是否有错误。

00:50:30,099 --> 00:50:33,009
其次它有点长，

00:50:33,009 --> 00:50:35,859
如果你能让它短一些，那就太好了。

00:50:35,859 --> 00:50:37,900
最重要的是，没有错误检查机制。

00:50:37,900 --> 00:50:40,779
那我们可以做些什么方便用户使用呢？

00:50:40,779 --> 00:50:50,049
地址就是这个公钥的一个方便用户使用的版本，

00:50:50,049 --> 00:50:52,839
它包含错误检查，

00:50:52,839 --> 00:50:55,839
并且它会短一些。

00:50:55,839 --> 00:50:58,569
那我们如何解决这个错误检查问题呢?

00:50:58,569 --> 00:51:02,380
我们做的是创建一个叫做校验和的东西，

00:51:02,380 --> 00:51:07,869
我们对公钥的哈希版本进行哈希，

00:51:07,869 --> 00:51:10,739
这会给我们一个长数字。

00:51:10,739 --> 00:51:13,509
我们只取前四个字节，

00:51:13,509 --> 00:51:16,779
即这个公钥的哈希值的前四个字节，

00:51:16,779 --> 00:51:18,999
那就是所谓的校验和，

00:51:18,999 --> 00:51:21,719
我们把它放在最后。

00:51:21,719 --> 00:51:29,619
这意味着如果有人在他们的钱包软件中输入整个公钥，

00:51:29,619 --> 00:51:34,269
他们在这里犯了一个错误，

00:51:34,269 --> 00:51:37,329
钱包软件可以哈希这个输入的密钥，

00:51:37,329 --> 00:51:40,450
并检查这部分的密钥是否与校验和匹配，

00:51:40,450 --> 00:51:43,239
如果不匹配，

00:51:43,239 --> 00:51:44,489
那么他们就知道某个地方犯了错误，

00:51:44,489 --> 00:51:46,539
虽然不能告诉你错误在哪里，

00:51:46,539 --> 00:51:49,119
但至少会发出警告，

00:51:49,119 --> 00:51:50,770
告诉你犯了错误，

00:51:50,770 --> 00:51:57,150
这总比什么都没有好。

00:51:57,150 --> 00:52:00,610
就像我说的这个有点长，

00:52:00,610 --> 00:52:03,550
我们能不能把它弄短一点呢?

00:52:03,550 --> 00:52:06,670
我在这里有校验和，公钥变得更长了，

00:52:06,670 --> 00:52:08,320
我们能不能缩短它呢?

00:52:08,320 --> 00:52:13,119
是的，我们可以。

00:52:13,119 --> 00:52:16,680
这个版本已经用十六进制格式编码，

00:52:16,680 --> 00:52:21,280
它有16个字符可以选择。

00:52:21,280 --> 00:52:24,220
如果它只是一个数字，

00:52:24,220 --> 00:52:28,630
而不是用16个字符编码的格式呢?

00:52:28,630 --> 00:52:32,290
如果我们用更多的字符，而不是16个字符，

00:52:32,290 --> 00:52:33,730
那么如果我们用整个字母数字字母表，

00:52:33,730 --> 00:52:37,150
它有62个字符，

00:52:37,150 --> 00:52:39,010
如果我们可以使用这些字符，

00:52:39,010 --> 00:52:42,160
那么我们可以用更少的字符、

00:52:42,160 --> 00:52:45,820
更短的空间来表示这个数字。

00:52:45,820 --> 00:52:50,320
使用所有这些字符的问题是，

00:52:50,320 --> 00:52:51,940
有些字符很难打出来，

00:52:51,940 --> 00:52:56,410
比如0和o看起来一样，

00:52:56,410 --> 00:52:58,780
所以我们不想用这些。

00:52:58,780 --> 00:53:01,060
L和大写的i看起来也一样，

00:53:01,060 --> 00:53:02,710
所以我们也不想用这些。

00:53:02,710 --> 00:53:04,210
所以如果你把这些踢出去，

00:53:04,210 --> 00:53:07,960
只剩下58个字符可以选择。

00:53:07,960 --> 00:53:13,359
当你以特定的格式编码数字时，

00:53:13,359 --> 00:53:14,530
你可以选择的字符的数量也被称为基数。

00:53:14,530 --> 00:53:16,750
所以这是基数16，

00:53:16,750 --> 00:53:20,500
这是基数58。

00:53:20,500 --> 00:53:24,609
基数58就是字母数字字母表中的字符，

00:53:24,609 --> 00:53:28,150
去掉了那些难以区分的字符。

00:53:28,150 --> 00:53:30,970
如果你把所有这些数据，

00:53:30,970 --> 00:53:33,160
包含校验和的公钥，

00:53:33,160 --> 00:53:38,109
用Base58的字符编码成这种格式，

00:53:38,109 --> 00:53:39,790
你会得到一个稍微短一点、

00:53:39,790 --> 00:53:41,680
更方便用户使用的地址，

00:53:41,680 --> 00:53:44,230
但最重要的是，

00:53:44,230 --> 00:53:46,480
它具有这种箭头跟踪功能，

00:53:46,480 --> 00:53:53,910
这就是为什么觉得这种特殊的格式看起来有点熟悉。
 
00:53:53,910 --> 00:53:56,310
所以基本上只是8个，

00:53:56,310 --> 00:53:59,740
这就是我们所说的地址，

00:53:59,740 --> 00:54:05,950
这个地址就是公钥哈希的美化版本。

00:54:05,950 --> 00:54:10,510
我们可以选择给出哈希版本，

00:54:10,510 --> 00:54:12,070
如果我们愿意的话，

00:54:12,070 --> 00:54:14,950
我们可以放弃哈希版本，

00:54:14,950 --> 00:54:16,870
但是现在的钱包都要求提供一个地址，

00:54:16,870 --> 00:54:19,270
所以你给出地址，

00:54:19,270 --> 00:54:22,660
这意味着如果他们输入错误，

00:54:22,660 --> 00:54:24,340
钱包软件就可以指出有问题。

00:54:24,340 --> 00:54:32,380
所以使用这个地址更方便用户使用，也更安全。

00:54:32,380 --> 00:54:36,910
你可以很容易地在Base58编码和解码之间来回转换，

00:54:36,910 --> 00:54:40,450
这并没有使用任何特定的哈希函数，

00:54:40,450 --> 00:54:44,860
它只是从一种数字格式转换为另一种数字格式，

00:54:44,860 --> 00:54:49,600
就像从十进制转换为十六进制一样。

00:54:49,600 --> 00:54:50,920
这是一种数字转换，

00:54:50,920 --> 00:54:54,430
但仍然看到的是相同的数字。

00:54:54,430 --> 00:54:56,860
你可以来回转换，

00:54:56,860 --> 00:55:00,130
你可以来回转换基数16和基数58。

00:55:00,130 --> 00:55:05,860
这意味着当你实际给出一个地址或者在钱包中输入一个地址时，

00:55:05,860 --> 00:55:07,480
钱包在创建交易时，

00:55:07,480 --> 00:55:13,090
会计算出公钥的哈希值，

00:55:13,090 --> 00:55:16,000
然后将其作为锁。

00:55:16,000 --> 00:55:18,250
所以即使你输入了一个地址，

00:55:18,250 --> 00:55:22,210
钱包也会将其转换为哈希版本。

00:55:22,210 --> 00:55:23,770
如果你查看区块链，

00:55:23,770 --> 00:55:30,310
你会发现区块链上的锁中并没有实际的地址，

00:55:30,310 --> 00:55:32,200
只有公钥的哈希版本，

00:55:32,200 --> 00:55:34,120
或者说在交易数据中只有公钥的哈希版本。

00:55:34,120 --> 00:55:43,630
希望这个解释对你有所帮助。

00:55:43,630 --> 00:55:46,390
最后让我们看一些代码和示例，

00:55:46,390 --> 00:55:49,960
如果你明白了这一切，

00:55:49,960 --> 00:55:52,030
就能理解密钥和地址是如何工作的。

00:55:52,030 --> 00:55:53,980
这样你就拥有了私钥和公钥的基础知识，

00:55:53,980 --> 00:55:56,470
这是发送和接收交易所必需的。

00:55:56,470 --> 00:55:59,170
然后你创建数字签名，

00:55:59,170 --> 00:56:02,590
这样我们就可以证明在公钥上的私钥是存在的。

00:56:02,590 --> 00:56:06,610
我们可以证明我们用私钥创建了公钥，

00:56:06,610 --> 00:00:56:10,000
但实际上我们永远不需要公开私钥，

00:56:10,000 --> 00:56:14,190
这就是创建数字签名的交易系统如何工作的。

00:56:14,190 --> 00:56:21,540
最后我们创建了一个地址。

00:56:21,540 --> 00:56:26,770
实际上所有的交易数据都有公钥，

00:56:26,770 --> 00:56:32,830
而地址只是方便用户使用的方式。

00:56:32,830 --> 00:56:35,800
但在实际的交易中，

00:56:35,800 --> 00:56:39,850
使用的是公钥和哈希公钥，

00:56:39,850 --> 00:56:44,860
地址只是为了方便用户使用。

00:56:44,860 --> 00:56:45,970
所以如果你明白了这一切，

00:56:45,970 --> 00:56:47,460
那你就理解了密钥和地址是如何工作的。

00:56:47,460 --> 00:56:50,650
在这最后的部分，

00:56:50,650 --> 00:56:53,380
这很快就完成了，不是太复杂，

00:56:53,380 --> 00:56:56,080
只是如何生成自己的一套密钥和地址。

00:56:56,080 --> 00:56:58,870
我认为这很有趣，

00:56:58,870 --> 00:57:01,420
这并不难，虽然需要一些编码，

00:57:01,420 --> 00:57:06,880
但你实际上可以很容易地创建自己的一套密钥。

00:57:06,880 --> 00:57:08,470
这样你就可以发送和接收比特币，

00:57:08,470 --> 00:57:09,790
这是一件非常有趣的事情，

00:57:09,790 --> 00:57:12,520
如果你想开始使用比特币。

00:57:12,520 --> 00:57:14,530
现在我将向你展示所有的技术细节，

00:57:14,530 --> 00:57:16,480
如何实际创建你自己的一组密钥，

00:57:16,480 --> 00:57:18,630
从私钥开始。

00:57:18,630 --> 00:57:21,580
让我把这个移动过去，让它变大一点。

00:57:21,580 --> 00:57:24,610
首先，假设你正在进行一些编程工作，

00:57:24,610 --> 00:57:27,370
你想要创建你自己的一组密钥，

00:57:27,370 --> 00:57:29,710
你首先开始生成一个私钥。

00:57:29,710 --> 00:57:32,560
如果你记得，

00:57:32,560 --> 00:57:33,880
私钥只是一个随机数。

00:57:33,880 --> 00:57:41,050
生成这个随机数最重要的一点就是你需要使用一个安全的随机源。

00:57:41,050 --> 00:57:43,620
这是迄今为止最重要的一部分，

00:57:43,620 --> 00:57:45,370
确保它是安全的。

00:57:45,370 --> 00:57:50,590
不要只是使用你的编程语言中的标准随机数生成器，

00:57:50,590 --> 00:57:52,270
它们可能不够安全。

00:57:52,270 --> 00:57:57,390
对于这种情况，

00:57:57,390 --> 00:57:59,740
随机性的良好来源，据我所知，

00:57:59,740 --> 00:58:02,790
是使用Open SSL库，

00:58:02,790 --> 00:58:08,290
每种编程语言都应该能够使用它。

00:58:08,290 --> 00:58:10,840
如果你在Linux上，

00:58:10,840 --> 00:58:12,580
使用dev从/dev/urandom读取字节，

00:58:12,580 --> 00:58:14,520
这应该对你来说足够随机。

00:58:14,520 --> 00:58:19,210
或者如果你只有谷歌用来学习编程语言，

00:58:19,210 --> 00:58:24,010
那么应该有一个库能够让你快速轻松地访问这两个东西。

00:58:24,010 --> 00:58:27,700
在Ruby中，

00:58:27,700 --> 00:58:31,540
它被称为安全随机数，

00:58:31,540 --> 00:58:33,430
不确定在其他语言中是什么，

00:58:33,430 --> 00:58:37,540
但是可以去寻找一下你的编程语言中最安全的随机源，

00:58:37,540 --> 00:58:41,560
这非常重要。

00:58:41,560 --> 00:58:42,970
再次强调，

00:58:42,970 --> 00:58:46,030
你需要一个安全的随机源，

00:58:46,030 --> 00:58:49,000
你需要生成一个256位的数字，

00:58:49,000 --> 00:58:52,540
也就是在1和2的256次方之间的一个数字，

00:58:52,540 --> 00:58:59,349
用十进制表示就是这个数。

00:58:59,349 --> 00:59:02,530
但为了准确，

00:59:02,530 --> 00:59:04,810
实际上有效的私钥范围略小于这个，

00:59:04,810 --> 00:59:08,200
这是因为比特币中使用的特定曲线的限制。

00:59:08,200 --> 00:59:14,170
这个曲线有一个叫做n的参数，

00:59:14,170 --> 00:59:17,130
这就是曲线上的点的数量，

00:59:17,130 --> 00:59:19,710
你的私钥不能超过这个。

00:59:19,710 --> 00:59:23,349
这实际上只比2的256次方小一点。

00:59:23,349 --> 00:59:25,510
它非常接近，

00:59:25,510 --> 00:59:28,329
但为了确保无误，

00:59:28,329 --> 00:59:30,310
我甚至没有看到这个数字在变化，

00:59:30,310 --> 00:59:36,430
但这是2的256次方。

00:59:36,430 --> 00:59:38,170
这就是曲线上的点数N，

00:59:38,170 --> 00:59:40,000
所以要确保它低于这个值。

00:59:40,000 --> 00:59:42,040
如果你在谷歌上搜索曲线的名称SECP256K1，

00:59:42,040 --> 00:59:45,130
你可以找到N的参数。

00:59:45,130 --> 00:59:50,050
所以我们只是生成一个随机数，

00:59:50,050 --> 00:59:51,970
我们可以证明它低于这个最大值。

00:59:51,970 --> 00:59:54,940
这就是私钥，

00:59:54,940 --> 00:59:57,660
只需要生成一个随机数。

00:59:57,660 --> 01:00:00,490
其次我们现在想要创建公钥，

01:00:00,490 --> 01:00:02,859
我们需要使用椭圆曲线，

01:00:02,859 --> 01:00:10,210
实际上我们需要做椭圆曲线乘法，

01:00:10,210 --> 01:00:17,410
但实际上在你的编程语言中可能有一个库可以让你访问，

01:00:17,410 --> 01:00:20,020
并提供一些东西，

01:00:20,020 --> 01:00:21,790
你就可以包含它并让它做一些椭圆曲线乘法。

01:00:21,790 --> 01:00:25,599
所以你在为自己编写代码时，

01:00:25,599 --> 01:00:26,710
可以找个库来帮你。

01:00:26,710 --> 01:00:32,349
你需要做的就是做椭圆曲线乘法，

01:00:32,349 --> 01:00:38,170
将这个生成点或这个值和你的私钥进行乘法运算，

01:00:38,170 --> 01:00:41,619
最后的结果就是公钥。

01:00:41,619 --> 01:00:44,410
公钥是这个点的x和y值。

01:00:44,410 --> 01:00:50,080
显然这个公钥相当大，

01:00:50,080 --> 01:00:53,200
我们有两个256位的数字，

01:00:53,200 --> 01:00:55,270
这会占用很多空间。

01:00:55,270 --> 01:00:58,720
ID和空间都在比特币中，

01:00:58,720 --> 01:01:01,330
因为区块链是一个共享文件，

01:01:01,330 --> 01:01:02,650
我们不希望占用太多空间。

01:01:02,650 --> 01:01:05,470
所以我们可以将这个数字缩小一点，

01:01:05,470 --> 01:01:08,550
我们可以这样做，

01:01:08,550 --> 01:01:13,030
因为椭圆曲线的一个便利特性是它沿着x轴对称。

01:01:13,030 --> 01:01:15,490
所以这意味着，

01:01:15,490 --> 01:01:17,800
如果你有一个x值，

01:01:17,800 --> 01:01:20,020
那么它的y值只有两个可能的值。

01:01:20,020 --> 01:01:23,020
所以对于每个x值，

01:01:23,020 --> 01:01:26,440
只有两个给定的y值。

01:01:26,440 --> 01:01:29,040
你可以考虑是Y或者-Y。

01:01:29,040 --> 01:01:35,320
这个椭圆曲线的一个便利的性质是，

01:01:35,320 --> 01:01:37,869
如果这个Y值是偶数，

01:01:37,869 --> 01:01:40,750
那么它就是曲线上的一个点，

01:01:40,750 --> 01:01:42,369
比如这个。

01:01:42,369 --> 01:01:44,109
如果它是奇数，

01:01:44,109 --> 01:01:47,410
那就表示是曲线上的另一个点。

01:01:47,410 --> 01:01:50,619
我的意思是，当我们想要存储这个公钥时，

01:01:50,619 --> 01:01:52,540
我们不必存储完整的Y值，

01:01:52,540 --> 01:01:54,750
我们只需要知道它是偶数还是奇数。

01:01:54,750 --> 01:01:58,839
这个Y值是偶数，

01:01:58,839 --> 01:02:00,609
所以我们只需要知道这个公钥是偶数，

01:02:00,609 --> 01:02:05,020
然后我们可以根据X值来推算出它是什么。

01:02:05,020 --> 01:02:09,040
这就是X值，

01:02:09,040 --> 01:02:15,040
然后我们可以把Y是偶数还是奇数放在前面。

01:02:15,040 --> 01:02:17,980
显然你不会把"偶数"或者"奇数"这个词放在前面，

01:02:17,980 --> 01:02:20,020
而是用两个代码来表示。

01:02:20,020 --> 01:02:22,540
如果它是偶数，就用02表示，

01:02:22,540 --> 01:02:27,210
如果是奇数，就用03表示。

01:02:27,210 --> 01:02:30,099
在比特币早期，

01:02:30,099 --> 01:02:32,140
公钥实际上是用X和Y值一起存储的，

01:02:32,140 --> 01:02:34,510
这些被称为未压缩密钥。

01:02:34,510 --> 01:02:36,070
这是一个压缩密钥，

01:02:36,070 --> 01:02:38,160
因为我们不需要使用完整的Y值，

01:02:38,160 --> 01:02:44,299
但是这在创始人中本聪开始的时候并不知道，

01:02:44,299 --> 01:02:49,859
所以早期的比特币公钥使用的是未压缩的格式。

01:02:49,859 --> 01:02:51,210
如果你想使用未压缩的格式，

01:02:51,210 --> 01:02:53,220
那么它会以04开头，

01:02:53,220 --> 01:02:57,029
但是这个是02。

01:02:57,029 --> 01:03:00,480
所以这就是公钥，

01:03:00,480 --> 01:03:06,720
只需要X坐标和Y是偶数还是奇数，

01:03:06,720 --> 01:03:08,549
编码为02或03。

01:03:08,549 --> 01:03:13,799
不需要把所有这些文本转换成十进制，

01:03:13,799 --> 01:03:16,950
我只是用数字来说明这一切都只是数字。

01:03:16,950 --> 01:03:21,269
但是当你开始查看私钥和公钥或者传递它们时，

01:03:21,269 --> 01:03:23,819
它们通常会被存储为十六进制格式。

01:03:23,819 --> 01:03:27,900
所以这就是私钥，

01:03:27,900 --> 01:03:30,509
长度为32字节，

01:03:30,509 --> 01:03:35,000
而这个公钥应该是33字节。

01:03:35,000 --> 01:03:37,829
如果这个公钥是一个较小的数字，

01:03:37,829 --> 01:03:41,369
当你把它转换成十六进制时，

01:03:41,369 --> 01:03:44,339
如果它的长度不是32字节，

01:03:44,339 --> 01:03:46,079
那么请确保在开始时用0来填充，

01:03:46,079 --> 01:03:53,039
以确保整个X值部分的公钥总共是32字节。

01:03:53,039 --> 01:03:57,420
这是一个快速提示，

01:03:57,420 --> 01:04:02,210
否则你最终会创建一个错误的地址。

01:04:02,210 --> 01:04:07,140
这就是基本知识：

01:04:07,140 --> 01:04:10,200
私钥、随机数、公钥

01:04:10,200 --> 01:04:11,430
只需进行两个乘法，

01:04:11,430 --> 01:04:14,069
然后以压缩格式存储Y值，

01:04:14,069 --> 01:04:15,329
我们只需要知道它是偶数还是奇数。

01:04:15,329 --> 01:04:17,970
现在我们有了这个，

01:04:17,970 --> 01:04:20,180
我们就可以通过两个哈希函数进行操作，

01:04:20,180 --> 01:04:26,220
因为现在你想要将这个哈希160给其他人。

01:04:26,220 --> 01:04:28,380
所以我们首先通过SHA-256，

01:04:28,380 --> 01:04:32,369
然后通过RIPEMD160，

01:04:32,369 --> 01:04:33,809
这会给你这个摘要，这个结果。

01:04:33,809 --> 01:04:35,819
当你在比特币中进行哈希时，

01:04:35,819 --> 01:04:37,410
别忘了首先将这个转换为二进制，

01:04:37,410 --> 01:04:38,789
然后再放入哈希函数，

01:04:38,789 --> 01:04:41,130
并且得到一个二进制结果，

01:04:41,130 --> 01:04:44,099
将这个二进制结果放入下一个函数，

01:04:44,099 --> 01:04:46,950
然后得到一个二进制结果，

01:04:46,950 --> 01:04:49,859
然后将它转换为十六进制，

01:04:49,859 --> 01:04:51,190
这就会给你这个哈希160。

01:04:51,190 --> 01:04:56,020
你可能会注意到这个结果，

01:04:56,020 --> 01:05:01,710
这个摘要比这些32字节的公钥要小一些。

01:05:01,710 --> 01:05:05,920
那是因为SHA 256是256位的，

01:05:05,920 --> 01:05:10,599
产生256位的结果，也就是32字节，

01:05:10,599 --> 01:05:13,540
但是RIPEMD 160产生的结果更小，

01:05:13,540 --> 01:05:17,770
160位的摘要，

01:05:17,770 --> 01:05:20,890
也就是20字节，所以这个比较小。

01:05:20,890 --> 01:05:26,349
好的，

01:05:26,349 --> 01:05:27,490
这就是我们提供给其他人的东西，

01:05:27,490 --> 01:05:30,250
这就是被保护的公钥。

01:05:30,250 --> 01:05:32,530
但是现在我们要创建一个地址，

01:05:32,530 --> 01:05:34,540
这是一个更美观的版本，

01:05:34,540 --> 01:05:35,710
其中包含了一些错误检查。

01:05:35,710 --> 01:05:39,490
所以我们需要做的是将这个转换为base 58，

01:05:39,490 --> 01:05:43,119
但在我们做这个之前，

01:05:43,119 --> 01:05:45,460
我们首先在开始处放一个版本字节，

01:05:45,460 --> 01:05:48,520
对于大多数地址来说，这个是00，

01:05:48,520 --> 01:05:50,400
我会在一会儿解释为什么要这么做。

01:05:50,400 --> 01:05:53,050
然后像我之前说的，我们需要一个校验和，

01:05:53,050 --> 01:05:55,720
所以我们就对所有这些进行哈希，

01:05:55,720 --> 01:05:57,490
也就是带有版本字节的公钥，

01:05:57,490 --> 01:06:00,369
对所有这些进行哈希，这就是校验和，

01:06:00,369 --> 01:06:03,210
对它进行两次哈希，就像在挖矿中一样，

01:06:03,210 --> 01:06:05,800
然后我们取前四个字节，这就是校验和，

01:06:05,800 --> 01:06:09,640
这就足够我们确信这个哈希是正确的，

01:06:09,640 --> 01:06:11,550
用于错误检查，

01:06:11,550 --> 01:06:14,410
然后我们将所有这些通过base 58进行处理。

01:06:14,410 --> 01:06:18,190
公钥，以及其哈希版本，

01:06:18,190 --> 01:06:20,170
开始时有一个版本字节，结束时有一个校验和，

01:06:20,170 --> 01:06:21,640
把这些都通过base58编码，

01:06:21,640 --> 01:06:23,920
就能得到这个地址。

01:06:23,920 --> 01:06:31,270
我们在开始处添加版本字节的原因是，

01:06:31,270 --> 01:06:40,300
它会影响到经过base58编码后地址的首个字符。

01:06:40,300 --> 01:06:44,730
对于正常的地址，

01:06:44,730 --> 01:06:51,890
我们只想以典型的方式发送和接收比特币，

01:06:51,890 --> 01:06:53,840
我们在开始处放一个零，

01:06:53,840 --> 01:06:55,310
这就给我们一个1地址，

01:06:55,310 --> 01:07:00,170
这意味着你只想以典型的方式发送和接收比特币。

01:07:00,170 --> 01:07:02,510
所以，通过改变开始处的这个版本字节，

01:07:02,510 --> 01:07:04,609
它会改变地址的开始字符。

01:07:04,609 --> 01:07:09,230
所以，00是用于典型的发送或接收地址，

01:07:09,230 --> 01:07:11,330
在主网络上。

01:07:11,330 --> 01:07:13,880
但是对于测试网络，

01:07:13,880 --> 01:07:16,250
如果你在一个测试网络上，

01:07:16,250 --> 01:07:18,550
你在开始处放一个6F，

01:07:18,550 --> 01:07:21,500
这将改变开始字符。

01:07:21,500 --> 01:07:23,390
所以这些不同的版本字节有很多，

01:07:23,390 --> 01:07:24,940
它们能给你不同的地址，

01:07:24,940 --> 01:07:27,830
但是在大多数情况下，

01:07:27,830 --> 01:07:32,290
你只需要使用00，这就能给你一个1地址。

01:07:32,290 --> 01:07:39,740
我想我会在锁定代码或脚本视频中更详细地讲解这个，

01:07:39,740 --> 01:07:42,430
这个视频将在这个之后出现。

01:07:42,430 --> 01:07:44,990
但是对于大多数地址，

01:07:44,990 --> 01:07:48,560
只需要在开始处放一个零就可以了。

01:07:48,560 --> 01:07:53,960
所以这就是你如何通过这个过程创建你自己的一组密钥。

01:07:53,960 --> 01:07:57,170
希望这都有些意义，

01:07:57,170 --> 01:08:02,480
或者解决了一些问题。

01:08:02,480 --> 01:08:08,010
所以有任何关于这个的问题吗？

01:08:08,010 --> 01:08:11,160
好的。

01:08:11,160 --> 01:08:12,690
只是一个简单的问题，

01:08:12,690 --> 01:08:15,210
你提到了一些关于32字节的，

01:08:15,210 --> 01:08:22,560
我可能确实有提到，

01:08:22,560 --> 01:08:26,460
当你有私钥和公钥时，

01:08:26,460 --> 01:08:28,500
这个x坐标总是32字节，

01:08:28,500 --> 01:08:31,020
私钥也是32字节。

01:08:31,020 --> 01:08:33,839
这里有一个小提示，

01:08:33,839 --> 01:08:36,000
当你做这个椭圆曲线乘法时，

01:08:36,000 --> 01:08:37,410
你会得到一个小的x值，

01:08:37,410 --> 01:08:39,299
然后你将其转换为十六进制，

01:08:39,299 --> 01:08:44,399
你可能会得到一个不是32字节长的十六进制数。

01:08:44,399 --> 01:08:47,310
如果是这种情况，

01:08:47,310 --> 01:08:50,819
只需确保在开始时用0填充，

01:08:50,819 --> 01:08:53,549
使每个x长度正确，

01:08:53,549 --> 01:08:56,520
这很重要，

01:08:56,520 --> 01:09:00,270
因为如果你在这里漏掉一个字符，

01:09:00,270 --> 01:09:01,859
那应该是一个0，

01:09:01,859 --> 01:09:03,859
那么这个值将被哈希为一个不同的值，

01:09:03,859 --> 01:09:06,299
所以你将把比特币发送到错误的地方。

01:09:06,299 --> 01:09:08,700
我以前犯过这个错误，

01:09:08,700 --> 01:09:13,319
所以我只是想提一下，

01:09:13,319 --> 01:09:18,649
确保没有人再犯同样的错误。

01:09:18,649 --> 01:09:27,170
所以这就是如何创建你自己的地址和私钥等等。

01:09:27,170 --> 01:09:35,370
这就是那部分。

01:09:35,370 --> 01:09:39,229
我在这里写了一个脚本，

01:09:39,229 --> 01:09:42,479
是用Ruby编写的，

01:09:42,479 --> 01:09:45,359
它会创建一组密钥，按照一个顺序。

01:09:45,359 --> 01:09:47,759
它首先生成一个私钥，

01:09:47,759 --> 01:09:50,520
然后获取一个安全的随机数，

01:09:50,520 --> 01:09:52,170
最大值是这个值，

01:09:52,170 --> 01:09:54,120
这是我之前说过的n，

01:09:54,120 --> 01:09:56,100
也就是曲线上的点数。

01:09:56,100 --> 01:09:59,040
如果它太大就会报错。

01:09:59,040 --> 01:10:01,790
生成私钥后，

01:10:01,790 --> 01:10:06,690
我们需要从私钥转换为公钥，

01:10:06,690 --> 01:10:11,639
所以我们就使用椭圆曲线做乘法。

01:10:11,639 --> 01:10:14,310
这会给你x和y的值。

01:10:14,310 --> 01:10:17,690
在旧格式中，它只是x和y，

01:10:17,690 --> 01:10:21,360
但在新格式中，

01:10:21,360 --> 01:10:22,619
如果你想压缩公钥，

01:10:22,619 --> 01:10:25,349
你只需要取y是否为偶数或奇数，

01:10:25,349 --> 01:10:28,170
然后在开头添加02或03。

01:10:28,170 --> 01:10:32,400
在公钥之后，

01:10:32,400 --> 01:10:33,840
你只能得到HASH 160，

01:10:33,840 --> 01:10:36,150
这非常简单，

01:10:36,150 --> 01:10:39,329
只需将其通过两个不同的哈希函数，

01:10:39,329 --> 01:10:43,760
即SHA256和RIPEMD160。

01:10:43,760 --> 01:10:47,429
要获取地址，你只需在开始处添加一个前缀，

01:10:47,429 --> 01:10:53,790
通过哈希HASH160创建一个校验和，

01:10:53,790 --> 01:10:55,349
然后地址就全部以base58编码。

01:10:55,349 --> 01:10:58,710
如果你有一些实用函数，

01:10:58,710 --> 01:11:00,659
比如base58之类的，

01:11:00,659 --> 01:11:04,380
那么我们就完成了。

01:11:04,380 --> 01:11:07,530
这里是代码，你只需运行Ruby密码生成器的代码，

01:11:07,530 --> 01:11:11,070
我会把这个代码放在网站上或者在描述中添加一个链接，

01:11:11,070 --> 01:11:14,159
这将为你提供一组密钥。

01:11:14,159 --> 01:11:16,139
你可以看到，

01:11:16,139 --> 01:11:18,389
尽管我们做了所有这些复杂的椭圆曲线乘法，

01:11:18,389 --> 01:11:21,210
但当你运行代码时，

01:11:21,210 --> 01:11:24,360
它还是很快就能给你密钥。

01:11:24,360 --> 01:11:32,750
所以只是为了证明给你看，

01:11:32,750 --> 01:11:37,619
这是一个地址，

01:11:37,619 --> 01:11:40,650
我可以向这个地址发送一些比特币，

01:11:40,650 --> 01:11:42,810
这个地址可能不存在。

01:11:42,810 --> 01:11:54,860
我只是为了展示一下，

01:11:54,860 --> 01:12:01,230
我会发送一个低费用的交易。

01:12:01,230 --> 01:12:04,630
好的，所以支付已经发送，

01:12:04,630 --> 01:12:13,870
复制这个，对不起，

01:12:13,870 --> 01:12:16,620
可能是我们的浏览器发送了交易，看看交易，

01:12:16,620 --> 01:12:18,130
就在这里。

01:12:18,130 --> 01:12:23,199
所以Wendy 9就是我发送到的地址。

01:12:23,199 --> 01:12:28,980
所以就像我之前说的，

01:12:28,980 --> 01:12:31,480
记住这个是如何为我处理的，

01:12:31,480 --> 01:12:33,880
它把它发送到了一个不同的地址，

01:12:33,880 --> 01:12:35,889
比如这里。

01:12:35,889 --> 01:12:42,699
所以公钥在这里是受保护的。

01:12:42,699 --> 01:12:47,290
在我结束之前，有几个快速提示。

01:12:47,290 --> 01:12:51,460
这是一个非常好的图形地址生成器，

01:12:51,460 --> 01:12:56,380
它向你展示了生成自己的地址需要做的所有步骤。

01:12:56,380 --> 01:13:00,730
如果你访问Royal Fork的博客，Google一下，

01:13:00,730 --> 01:13:03,219
去使用图形地址生成器，

01:13:03,219 --> 01:13:05,320
它非常好。

01:13:05,320 --> 01:13:07,090
所以如果你正在编程，

01:13:07,090 --> 01:13:08,230
想要创建自己的密钥和地址，

01:13:08,230 --> 01:13:11,020
这非常有帮助。

01:13:11,020 --> 01:13:14,100
它帮助了我很多，非常好。

01:13:14,100 --> 01:13:17,980
其次你拥有各种不同的曲线，

01:13:17,980 --> 01:13:20,679
例如secp256k1，

01:13:20,679 --> 01:13:24,820
它们都在SEC网站上列出。

01:13:24,820 --> 01:13:30,610
我在描述中放了一个链接，

01:13:30,610 --> 01:13:38,800
这就是那个曲线的参数。

01:13:38,800 --> 01:13:42,850
你有很多不同的曲线，

01:13:42,850 --> 01:13:51,409
但这只是比特币使用的一个。

01:13:51,409 --> 01:13:56,809
最后一件事，不要忘记，

01:13:56,809 --> 01:13:57,709
对于这些私钥，

01:13:57,709 --> 01:13:59,209
你也丢失了地址版本的私钥，

01:13:59,209 --> 01:14:00,530
像简短版本的私钥，

01:14:00,530 --> 01:14:02,090
这被称为钱包导入格式。

01:14:02,090 --> 01:14:03,829
我在这里没有涵盖它，

01:14:03,829 --> 01:14:07,969
但它与获取公钥的简短版本的过程非常相似。

01:14:07,969 --> 01:14:10,699
所以，如果你看到钱包导入格式，

01:14:10,699 --> 01:14:21,789
那只是私钥的简短版本。

01:14:21,789 --> 01:14:23,780
我很高兴这一切都很有意义，

01:14:23,780 --> 01:14:28,159
我试图使其尽可能流畅，

01:14:28,159 --> 01:14:29,389
因为这里有很多内容，

01:14:29,389 --> 01:14:30,679
我认为包括椭圆曲线等内容。

01:14:30,679 --> 01:14:32,929
我没有解释所有这些是如何工作的，

01:14:32,929 --> 01:14:42,159
我只是想介绍一下密钥的基本知识。

01:14:42,159 --> 01:14:45,050
是的，我有这样的感觉。

01:14:45,050 --> 01:14:46,219
当我制作视频时，

01:14:46,219 --> 01:14:47,479
我也有这种感觉，这包含相当多的信息，

01:14:47,479 --> 01:14:49,729
你很难知道，

01:14:49,729 --> 01:14:51,309
你很难一次性掌握所有内容，

01:14:51,309 --> 01:15:01,669
但是如果你想学习，

01:15:01,669 --> 01:15:03,619
我认为这些只是数字。

01:15:03,619 --> 01:15:06,859
我认为如果你只是通过创建自己的一组密钥来学习，

01:15:06,859 --> 01:15:08,419
你会在过程中学到所有的东西。

01:15:08,419 --> 01:15:11,749
但希望这能给你一个开始的基础，

01:15:11,749 --> 01:15:15,789
让你开始创建它们。