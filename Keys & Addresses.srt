1
00:00:00,030 --> 00:00:06,600
这个演讲将解释你需要知道的关于比特币密钥和地址的所有信息。

00:00:06,600 --> 00:00:11,400
你可能听过像私钥、公钥和地址这样的东西，

00:00:11,400 --> 00:00:16,320
我将在这个演讲中解释它们的来源和工作原理。

00:00:16,320 --> 00:00:21,800
我快速概述这个演示中会包含什么内容。

00:00:21,800 --> 00:00:24,630
我将从基础知识开始，

00:00:24,630 --> 00:00:27,029
解释密钥的来源和工作方式，

00:00:27,029 --> 00:00:29,400
并对它们的工作方式进行一个基本的概述。

00:00:29,400 --> 00:00:32,070
我将讲解每个密钥是如何生成的，

00:00:32,070 --> 00:00:35,130
你有一个私钥，

00:00:35,130 --> 00:00:37,320
然后从那里生成一个公钥，

00:00:37,320 --> 00:00:41,250
这两个是你在比特币中使用的主要密钥，

00:00:41,250 --> 00:00:47,280 
类似于密码和账号。

00:00:47,280 --> 00:00:49,820
你有所谓的数字签名，

00:00:49,820 --> 00:00:54,149
这些被用来证明你拥有一个公钥，

00:00:54,149 --> 00:00:57,000
就像用于签署交易一样。

00:00:57,000 --> 00:00:59,160
我将解释这些是如何工作的。

00:00:59,160 --> 00:01:02,460
我会讲解地址是如何工作的，

00:01:02,460 --> 00:01:09,750
地址基本上就像公钥的一个更漂亮或对用户更友好的版本。

00:01:09,750 --> 00:01:12,030
我将解释它们是如何工作的，

00:01:12,030 --> 00:01:14,880
以及它们是如何连接在一起的。

00:01:14,880 --> 00:01:17,070
在最后，我将通过一些代码和例子，

00:01:17,070 --> 00:01:24,990
来展示你如何生成自己的私钥、公钥和地址。

00:01:24,990 --> 00:01:27,479
这个演讲主要是讲解，

00:01:27,479 --> 00:01:30,180
不涉及太多的代码，

00:01:30,180 --> 00:01:36,450 
最后可能会有一些关于数字签名的详细解释，

00:01:36,450 --> 00:01:40,290
但只要你对它的工作方式有一个大概了解就可以了。

00:01:40,290 --> 00:01:44,030
我将开始，

00:01:44,030 --> 00:01:48,390
这也是为什么比特币和其他货币被称为加密货币，

00:01:48,390 --> 00:01:50,520
因为这个私钥和公钥的被称为加密，

00:01:50,520 --> 00:01:54,270
使用了密码学，

00:01:54,270 --> 00:01:56,130
所以我们称他们为加密货币，

00:01:56,130 --> 00:02:05,070
这是交易系统或比特币所有权的基础。

它们连接在一起并共享一个名为区块链的文件

00:02:05,070 --> 00:02:09,060
快进到我们上次停止的地方，

00:02:09,060 --> 00:02:12,000
正如你从我上次的演讲中看到的那样，

00:02:12,000 --> 00:02:14,730
这就是比特币网络，

00:02:14,730 --> 00:02:16,500
比特币网络就是一群计算机。

00:02:16,500 --> 00:02:18,830
互相连接在一起，

00:02:18,830 --> 00:02:21,420
并共享一个名为区块链的文件

00:02:21,420 --> 00:02:24,420
当你想进行比特币交易时，

00:02:24,420 --> 00:02:27,510
你想向某人发送一些比特币，

00:02:27,510 --> 00:02:34,170
你只需要一行描述移动的数据即可进行这样的交易，

00:02:34,170 --> 00:02:36,480
比特币从这个人到那个人。

00:02:36,480 --> 00:02:41,010
当你希望将这个交易添加到区块链中时，

00:02:41,010 --> 00:02:44,540
你会将交易插入到网络上的一个节点中，

00:02:44,540 --> 00:02:47,069
他们会在他们的内存池中快速存储这个交易。

00:02:47,069 --> 00:02:51,450
然后他们会将交易传递给他们所连接的节点，

00:02:51,450 --> 00:02:54,390
如此反复，

00:02:54,390 --> 00:02:59,640
直到交易在网络上每个节点的内存池中。

00:02:59,640 --> 00:03:07,620
之后，所有这些节点都会尝试竞争将他们内存池中的交易添加到区块链上。

00:03:07,620 --> 00:03:09,989
这个过程被称为挖矿，

00:03:09,989 --> 00:03:12,660
让我们假设这个人或者这个矿工，

00:03:12,660 --> 00:03:13,950
他能够将内存池中的交易添加到区块链上。

00:03:13,950 --> 00:03:19,019
所以一旦有一个交易块被添加进去，

00:03:19,019 --> 00:03:20,940
他们会将该区块传递给连接的节点，

00:03:20,940 --> 00:03:23,100
然后将其添加到他们的区块链中，

00:03:23,100 --> 00:03:24,870
如此反复，

00:03:24,870 --> 00:03:31,980
直到每个人的区块链副本都更新了最新的交易区块。

00:03:31,980 --> 00:03:33,329
然后这个人可以查看区块链，

00:03:33,329 --> 00:03:40,260
看到所有权已经从这个人转移到了那个人。

00:03:40,260 --> 00:03:43,069
在上一次的演讲中，

00:03:43,069 --> 00:03:45,299
我解释了这些交易在内部看起来是什么样子的。

00:03:45,299 --> 00:03:47,910
你可以把交易想象成这样：

00:03:47,910 --> 00:03:54,750
区块链充满了所有的交易数据，

00:03:54,750 --> 00:03:56,370
但如果你将其拆开看，

00:03:56,370 --> 00:03:58,950
就像看到很多不同批次，

00:03:58,950 --> 00:04:01,470
不同大小的比特币。

00:04:01,470 --> 00:04:03,690
当你进行交易时，

00:04:03,690 --> 00:04:06,000
你需要进入到区块链中，

00:04:06,000 --> 00:04:08,700
选择一个特定的比特币批次，

00:04:08,700 --> 00:04:13,829
比如说这个窗口是一个10的批次，

00:04:13,829 --> 00:04:15,569
然后你会从那里取出那批比特币，

00:04:15,569 --> 00:04:17,608
创建一个新的批次。

00:04:17,608 --> 00:04:25,960
发送一批新的比特币就像从旧的批次中创建一个新的批次。

00:04:25,960 --> 00:04:29,830
然后你会将那批比特币发送到网络中，

00:04:29,830 --> 00:04:31,570
这个交易大约需要两个比特币，

00:04:31,570 --> 00:04:33,220
然后创建一个新的进入网络，

00:04:33,220 --> 00:04:35,560
然后这个新的批次会进入到一个内存池，

00:04:35,560 --> 00:04:37,810
然后进入到区块链中。

00:04:37,810 --> 00:04:39,340
然后当你查看区块链时，

00:04:39,340 --> 00:04:41,410
这个新的批次会出现在这个新的区块中，

00:04:41,410 --> 00:04:46,630
而我们用过的整个批次将会被灰掉，

00:04:46,630 --> 00:04:50,250
因为它已经被消费掉了。

00:04:50,440 --> 00:04:51,940
我一直在称它们为批次，

00:04:51,940 --> 00:04:54,510
但实际上它们被称为输出，

00:04:54,510 --> 00:04:56,320
当你在交易中使用一个输出时，

00:04:56,320 --> 00:04:58,060
它被称为输入。

00:04:58,060 --> 00:05:00,400
所以你可以把区块链想象为充满了输出，

00:05:00,400 --> 00:05:03,070
它们只是被选择出来，

00:05:03,070 --> 00:05:09,010
然后从它们中创建出新的输出。

00:05:09,010 --> 00:05:12,580
这一切都很好，

00:05:12,580 --> 00:05:16,630
但是你如何拥有这些比特币批次呢？

00:05:16,630 --> 00:05:18,370
每一批比特币都有一个锁，

00:05:18,370 --> 00:05:23,920
每个想要使用比特币的人都有自己的一套密钥，

00:05:23,920 --> 00:05:26,140
你有一个私钥，就像你的密码，

00:05:26,140 --> 00:05:28,420
和你的公钥，就像你的账户号码。

00:05:28,420 --> 00:05:32,050
所以，当你想要进行交易，

00:05:32,050 --> 00:05:35,200
如果这批比特币属于你，

00:05:35,200 --> 00:05:41,080
那么你就可以使用你的私钥来解锁它们，

00:05:41,080 --> 00:05:42,910
然后从那里你可以创建一个新的批次。

00:05:42,910 --> 00:05:46,330
如果你想把比特币发送给这个人，

00:05:46,330 --> 00:05:48,580
他们会给你他们的公钥，

00:05:48,580 --> 00:05:52,000
使用这个公钥，

00:05:52,000 --> 00:05:56,050
你可以在这个输出，这批比特币上创建一个锁，

00:05:56,050 --> 00:05:58,120
这批比特币被锁定到这个人的公钥，

00:05:58,120 --> 00:05:59,770
因为他们把它给了我们。

00:05:59,770 --> 00:06:05,470
如果他们想要把这批10个比特币的比特币发送给别人，

00:06:05,470 --> 00:06:10,630
他们就可以使用他们的私钥来解锁它们，

00:06:10,630 --> 00:06:14,470
然后发送，所以这就是一个典型的交易。

00:06:14,470 --> 00:06:20,890
通过使用这些密钥——私钥和公钥，

00:06:20,890 --> 00:06:25,130
这就相当于拥有一个账号和密码。

00:06:25,130 --> 00:06:27,470
我再次强调，

00:06:27,470 --> 00:06:29,180
一旦你构建了这个交易，

00:06:29,180 --> 00:06:30,680
你就不再拥有一批比特币的所有权，

00:06:30,680 --> 00:06:33,230
而是创建了一批新的比特币，

00:06:33,230 --> 00:06:34,940
锁定给另一个人。

00:06:34,940 --> 00:06:36,950
然后你会将这个交易发送到网络中，

00:06:36,950 --> 00:06:41,230
最终这个交易会被记录到区块链上，

00:06:41,230 --> 00:06:44,150
比特币的批次将会更新。

00:06:44,150 --> 00:06:46,460
这个批次已经被花费掉了，

00:06:46,460 --> 00:06:48,200
它被灰色标记，不能再次被花费，

00:06:48,200 --> 00:06:50,210
新的批次会出现在新的区块中，

00:06:50,210 --> 00:06:54,100
属于另一个人。

00:06:55,490 --> 00:06:59,300
如果你想使用比特币，

00:06:59,300 --> 00:07:02,720
你只需要拥有自己的一套密钥。

00:07:02,720 --> 00:07:07,100
如果你只是想接收别人的比特币，

00:07:07,100 --> 00:07:11,060
你就需要创建并拥有自己的一套密钥才能使用比特币。

00:07:11,060 --> 00:07:13,850
那么，这些密钥是从哪里来的呢？

00:07:13,850 --> 00:07:15,890
我可以告诉你它们不是从哪里来的。

00:07:15,890 --> 00:07:18,170
没有人可以控制比特币，

00:07:18,170 --> 00:07:24,440
有一本书或一台电脑充满了密钥，

00:07:24,440 --> 00:07:26,360
你可以要求他给你一个私钥和一个公钥。

00:07:26,360 --> 00:07:31,430
没有人你需要问他给你一个公钥。

00:07:31,430 --> 00:07:33,650
这可能是银行的情况，如果你去银行，

00:07:33,650 --> 00:07:37,060
你必须要求某人给你自己的账号和密码，

00:07:37,060 --> 00:07:40,490
以便使用他们的服务发送和接收资金。

00:07:40,490 --> 00:07:42,890
但在比特币中，

00:07:42,890 --> 00:07:45,920
我们没有中央控制点，

00:07:45,920 --> 00:07:48,950
因为比特币是去中心化的，

00:07:48,950 --> 00:07:52,790
没有一个人可以控制谁可以使用它。

00:07:52,790 --> 00:07:55,340
所以，这不是比特币的工作方式。

00:07:55,340 --> 00:07:57,650
那么，如果没有人控制密钥或账号，

00:07:57,650 --> 00:07:59,750
你可以要求他们给你，

00:07:59,750 --> 00:08:02,780
那么它们是从哪里来的呢？

00:08:02,780 --> 00:08:07,910
答案是，我们自己生成私钥和公钥。

00:08:07,910 --> 00:08:10,040
我们不需要问其他人，

00:08:10,040 --> 00:08:12,350
或者我们需要从哪里获取这些密钥，

00:08:12,350 --> 00:08:13,670
我们实际上自己创建它们。

00:08:13,670 --> 00:08:18,200
我们创建，我们就像我们是任何人一样，

00:08:18,200 --> 00:08:20,090
基本上任何人都可以使用比特币，

00:08:20,090 --> 00:08:21,530
因为我们创建我们自己的账号和密码。

00:08:21,530 --> 00:08:27,170
我希望这个介绍能让你们都理解，

00:08:27,170 --> 00:08:35,169
现在我将进入创建、生成和使用这些密钥的基础知识。

00:08:35,169 --> 00:08:46,180
你如何生成自己的一组密钥以便发送、接收和发送比特币呢？

00:08:46,180 --> 00:08:49,990
首先，你从一个私钥开始，

00:08:49,990 --> 00:08:54,459
最简单或者唯一的方式来生成自己的私钥，

00:08:54,459 --> 00:08:56,079
就是生成一个随机数。

00:08:56,079 --> 00:09:00,490
你只需要生成一个随机数，

00:09:00,490 --> 00:09:02,170
这明显是一个非常小的数，

00:09:02,170 --> 00:09:04,660
比特币的私钥是更大的数，

00:09:04,660 --> 00:09:06,360
但这只是为了展示。

00:09:06,360 --> 00:09:11,260
然后你需要一个公钥，

00:09:11,260 --> 00:09:14,199
如果私钥是你的密码，

00:09:14,199 --> 00:09:17,199
那么公钥就像你的账号。

00:09:17,199 --> 00:09:19,120
但显然，

00:09:19,120 --> 00:09:21,279
因为没有人会分发这些密钥，

00:09:21,279 --> 00:09:23,649
所以当我们生成公钥时，

00:09:23,649 --> 00:09:29,170
我们希望私钥和公钥之间有一个联系。

00:09:29,170 --> 00:09:34,630
这样我们就可以用私钥解锁比特币，

00:09:34,630 --> 00:09:37,510
因为它们是连接的。

00:09:37,510 --> 00:09:44,140
那么你如何创建公钥和私钥之间的联系呢？

00:09:44,140 --> 00:09:54,519
你所要做的就是使用一些数学方法从私钥派生出你的公钥。

00:09:54,519 --> 00:09:58,740
基本上你把你的私钥通过一些数学函数，

00:09:58,740 --> 00:10:01,510
然后就会得到一个公钥。

00:10:01,510 --> 00:10:07,120
所以这个公钥是通过数学与你的私钥连接的。

00:10:07,120 --> 00:10:13,420
所以，当你生成一组用于比特币的密钥时，

00:10:13,420 --> 00:10:15,519
你从一个随机数的私钥开始，

00:10:15,519 --> 00:10:19,420
然后从中创建你的公钥或者你的账号，

00:10:19,420 --> 00:10:23,860
这只是一个与你的私钥连接的数学相关的数字。

00:10:23,860 --> 00:10:28,890
这就是你如何生成自己的一组密钥，

00:10:28,890 --> 00:10:32,199
以便你可以从其他人那里接收比特币，

00:10:32,199 --> 00:10:36,110
然后再将它们发送给其他人。

00:10:36,110 --> 00:10:38,000
所以任何人都可以做这个，

00:10:38,000 --> 00:10:40,160
任何人都可以生成自己的一组用于比特币的密钥。

00:10:40,160 --> 00:10:44,600
这些就是基础知识。

00:10:44,600 --> 00:10:46,940
现在我要从这个私钥开始，

00:10:46,940 --> 00:10:51,920
因为生成自己的一组密钥都是从私钥开始的。

00:10:51,920 --> 00:10:57,080

00:10:57,080 --> 00:11:00,800
像我说的，

00:11:00,800 --> 00:11:03,260
你的私钥就是生成一个随机数，

00:11:03,260 --> 00:11:06,160
这个随机数可以在1到这个数之间的任何位置。

00:11:06,160 --> 00:11:10,430
这是一个非常非常大的数，

00:11:10,430 --> 00:11:16,190
但只要你生成一个在1和这个值之间的数，

00:11:16,190 --> 00:11:18,890
它就是一个有效的私钥，

00:11:18,890 --> 00:11:20,900
或者你有一个有效的起始点，

00:11:20,900 --> 00:11:24,770
你的有效密码来使用比特币。

00:11:24,770 --> 00:11:29,000
这通常被称为一个256位的数字，

00:11:29,000 --> 00:11:32,240
这只是描述它的大小，

00:11:32,240 --> 00:11:35,090
表示这个数字有多大。

00:11:35,090 --> 00:11:39,070
这来自于计算机，它们存储数据，

00:11:39,070 --> 00:11:44,660
你知道你有千字节和字节和兆字节，

00:11:44,660 --> 00:11:46,460
而位是计算机可以容纳的最小的数据单位，

00:11:46,460 --> 00:11:49,280
所有的数据都是0或1，

00:11:49,280 --> 00:11:56,570
所以你的计算机上的所有数据最终都是以0和1的序列存储的。

00:11:56,570 --> 00:12:00,920
同样对于数字，

00:12:00,920 --> 00:12:04,430
当你想在计算机上存储数字时，

00:12:04,430 --> 00:12:09,220
它们也以0和1的形式存储。

00:12:09,220 --> 00:12:12,290
所以如果你想存储数字，

00:12:12,290 --> 00:12:14,600
从0开始，

00:12:14,600 --> 00:12:15,260
你可以很容易地用位来存储，

00:12:15,260 --> 00:12:18,770
使用数字0，数字1也是类似的。

00:12:18,770 --> 00:12:21,140
你可以只使用位数1，

00:12:21,140 --> 00:12:24,020
但对于数字2，

00:12:24,020 --> 00:12:27,410
你已经用完了可以存储这些数据的字符，

00:12:27,410 --> 00:12:29,870
所以你只需要添加另一个位数。

00:12:29,870 --> 00:12:33,170
所以在二进制或位序列中，

00:12:33,170 --> 00:12:35,330
数字2被存储为1和0，

00:12:35,330 --> 00:12:39,530
然后再次是3，1和1，

00:12:39,530 --> 00:12:41,750
但你已经再次用完了选项，

00:12:41,750 --> 00:12:43,070
所以你需要另一个位来存储更大的数字，

00:12:43,070 --> 00:12:46,370
就像这样。这个过程会一直持续下去，

00:12:46,370 --> 00:12:47,360
因此数字越大，

00:12:47,360 --> 00:12:52,670
你就需要更多的位来表示它或者在计算机上存储它。

00:12:52,670 --> 00:12:55,870
如果你继续这样做，

00:12:55,870 --> 00:13:02,209
你会有256个位排列在一起，

00:13:02,209 --> 00:13:05,180
如果你在所有这些位上都放上1，

00:13:05,180 --> 00:13:09,470
那么它就能存储这个数字。

00:13:09,470 --> 00:13:13,519
这就是为什么它被称为256位数字，

00:13:13,519 --> 00:13:18,860
它基本上是计算机可以在256位数据中存储的最大数字，

00:13:18,860 --> 00:13:26,470
也就是说2的256次方，

00:13:26,470 --> 00:13:28,970
因为我们每个块都有两个选择，

00:13:28,970 --> 00:13:32,390
可能是0或1，

00:13:32,390 --> 00:13:36,490
如果你这样做256次，

00:13:36,490 --> 00:13:40,220
那么2的256次方就会给你这个数字，

00:13:40,220 --> 00:13:45,310
这是一个非常大的数字。

00:13:45,310 --> 00:13:48,620
那么现在的问题是，

00:13:48,620 --> 00:13:50,209
如果有人生成了和我一样的私钥怎么办？

00:13:50,209 --> 00:13:52,459
这显然看起来，

00:13:52,459 --> 00:13:58,100
像是一种生成自己的私人密码以便使用比特币的粗糙机制。

00:13:58,100 --> 00:14:02,180
答案是这个数字如此之大，

00:14:02,180 --> 00:14:10,089
以至于没有人会生成和你一样的私钥。

00:14:10,089 --> 00:14:13,459
为了说明这一点，

00:14:13,459 --> 00:14:17,560
假设这是已知的可见宇宙，

00:14:17,560 --> 00:14:24,140
这里的数字是这个已知的可见宇宙中的原子数量。

00:14:24,140 --> 00:14:33,829
你可以看到，这个256位的数字和宇宙中的原子数量差不多。

00:14:33,829 --> 00:14:37,670
你只需要相信我，

00:14:37,670 --> 00:14:40,730
这个数字非常大，

00:14:40,730 --> 00:14:44,360
虽然我可以在屏幕上显示它，

00:14:44,360 --> 00:14:47,060
但它实在是太大了。

00:14:47,060 --> 00:14:49,220
由于这个数字如此之大，

00:14:49,220 --> 00:14:55,630
两个不同的人不会生成相同的数字。

00:14:55,630 --> 00:14:59,029
这就是它的大小，

00:14:59,029 --> 00:15:01,310
这就是它的安全性。

00:15:01,310 --> 00:15:04,279
在比特币中，这一切都运行得很好，没有问题。

00:15:04,279 --> 00:15:09,170
没有人知道有人生成了相同的私钥，

00:15:09,170 --> 00:15:12,259
至少我不知道。如果有的话，那将是大新闻。

00:15:12,259 --> 00:15:14,810
但就像我说的，这是一个非常大的数字。

00:15:14,810 --> 00:15:17,690
所以私钥你只需要在1和这个值之间生成一个数字，

00:15:17,690 --> 00:15:21,440

00:15:21,440 --> 00:15:24,290
这个值刚刚生成，

00:15:24,290 --> 00:15:29,300
我会给你私钥，

00:15:29,300 --> 00:15:39,620
所以私钥只是一个我们刚刚生成的随机数，

00:15:39,620 --> 00:15:42,680
有了它我们就可以得到我们的公钥了。

00:15:42,680 --> 00:15:47,930
像我说的，没有公钥，

00:15:47,930 --> 00:15:49,610
我们需要将它与我们的私钥连接起来，

00:15:49,610 --> 00:15:54,620
因为我们需要将我们的账号和密码连接起来。

00:15:54,620 --> 00:15:58,730
我们做这个的方法是使用一些数学，

00:15:58,730 --> 00:16:03,769
有一种特定类型的数学，

00:16:03,769 --> 00:16:07,550
使用这个东西，

00:16:07,550 --> 00:16:09,889
叫做椭圆曲线。

00:16:09,889 --> 00:16:13,190
有很多不同的椭圆曲线，

00:16:13,190 --> 00:16:15,889
这只是其中一个的插图，

00:16:15,889 --> 00:16:19,639
但是比特币使用的特别的一个叫做sec p 2 5 6 k 1。

00:16:19,639 --> 00:16:23,870
像我说的，

00:16:23,870 --> 00:16:25,850
有很多不同的椭圆曲线，

00:16:25,850 --> 00:16:31,880
但是这是比特币使用的特别的椭圆曲线。

00:16:31,880 --> 00:16:36,470
所以从这个私钥得到你的公钥，

00:16:36,470 --> 00:16:42,230
你必须做所谓的椭圆曲线乘法。

00:16:42,230 --> 00:16:44,240
我们为什么要使用这个椭圆曲线，

00:16:44,240 --> 00:16:46,699
稍后会解释，

00:16:46,699 --> 00:16:48,620
所以现在请耐心等待，

00:16:48,620 --> 00:16:51,250
我会向你展示这个椭圆曲线乘法是如何工作的。

00:16:51,250 --> 00:16:55,730
所以对于SEC P 2 5 6 K 1，

00:16:55,730 --> 00:16:58,399
它有一个起始点，

00:16:58,399 --> 00:17:00,110
要做乘法，

00:17:00,110 --> 00:17:01,750
这将是一个简化的解释，

00:17:01,750 --> 00:17:05,329
但基本上这被称为G，

00:17:05,329 --> 00:17:08,869
也称为起始点或生成点，

00:17:08,869 --> 00:17:10,839
但对于乘法，

00:17:10,839 --> 00:17:20,359
基本上是在曲线上画一条切线。

00:17:20,359 --> 00:17:25,130
所以我们将从这个生成点开始，

00:17:25,130 --> 00:17:26,839
这个椭圆曲线的一个特性是，

00:17:26,839 --> 00:17:29,510
如果你在上面画一条切线。

00:17:29,510 --> 00:17:31,490
那么，它总是会在曲线的另一点相交，

00:17:31,490 --> 00:17:35,930
这只是这种特殊类型曲线的一个特性，

00:17:35,930 --> 00:17:39,070
这就是我们使用它的原因。

00:17:39,070 --> 00:17:42,860
那么，当你做到这一点时，

00:17:42,860 --> 00:17:45,740
当它交叉时，你就取那个称为交点的点，

00:17:45,740 --> 00:17:47,840
然后你只需翻转它，

00:17:47,840 --> 00:17:53,390
并从相交处的这一点取曲线上相反的点

00:17:53,390 --> 00:17:55,810
我将取这个点，

00:17:55,810 --> 00:17:59,150
这个点就像做一轮乘法，

00:17:59,150 --> 00:18:01,880
所以如果这是一个G，

00:18:01,880 --> 00:18:06,560
那么这将是2G，

00:18:06,560 --> 00:18:07,820
如果你想做另一轮乘法，

00:18:07,820 --> 00:18:09,980
画另一个切线，

00:18:09,980 --> 00:18:12,260
它将在曲线上交叉另一个点，

00:18:12,260 --> 00:18:13,910
这会给你很好的结果，

00:18:13,910 --> 00:18:16,520
然后你取那个点的倒数，

00:18:16,520 --> 00:18:18,500
那将给你曲线上的另一个点，

00:18:18,500 --> 00:18:20,350
这是第二轮乘法。

00:18:20,350 --> 00:18:22,730
这有点简化，

00:18:22,730 --> 00:18:26,120
但这基本上就是它的工作原理。

00:18:26,120 --> 00:18:27,290
当你想再次乘法时，

00:18:27,290 --> 00:18:31,580
你只需在曲线上的点处再次取切线，

00:18:31,580 --> 00:18:34,070
如此反复。

00:18:34,070 --> 00:18:35,360
基本上，当你做一个椭圆曲线乘法时，

00:18:35,360 --> 00:18:38,570
你在画所有这些切线并取相反的点，

00:18:38,570 --> 00:18:41,540
但最终你在这个曲线上以特定的方式跳动，

00:18:41,540 --> 00:18:48,770
就像这样。

00:18:48,770 --> 00:18:52,550 
所以你所做的是在曲线上多次跳动，

00:18:52,550 --> 00:18:54,920
根据私钥次数来进行跳动，

00:18:54,920 --> 00:18:58,070
所以显然我没有在那里结束，

00:18:58,070 --> 00:19:02,160
但你会继续做这个，直到你做到了私钥次数。

00:19:02,160 --> 00:19:05,309
当你做到这一点时，

00:19:05,309 --> 00:19:07,960
当你最后完成时，

00:19:07,960 --> 00:19:10,630
你将在曲线上结束一个点，

00:19:10,630 --> 00:19:14,200
这个点在曲线上是公钥。

00:19:14,200 --> 00:19:16,120
所以，曲线上有很多很多点，

00:19:16,120 --> 00:19:23,620
基本上和私钥一样多的点。

00:19:23,620 --> 00:19:25,480
所以，一旦你得到了那个公钥，

00:19:25,480 --> 00:19:28,390
基本上，就像我说的，

00:19:28,390 --> 00:19:30,040
经过这么多次在曲线上跳动后的最后一个停留点，

00:19:30,040 --> 00:19:32,500
给你一个公钥，

00:19:32,500 --> 00:19:37,720
准确地说，你的公钥只是这个点的X和Y坐标。

00:19:37,720 --> 00:19:40,120
所以我们得到了X和Y，

00:19:40,120 --> 00:19:42,010
把它们像这样放在一起，

00:19:42,010 --> 00:19:46,960
那就是你的公钥。

00:19:46,960 --> 00:19:49,990
我们使用这个椭圆曲线的原因之一是，

00:19:49,990 --> 00:19:52,360
它的一个特性是，

00:19:52,360 --> 00:19:54,070
这个乘法是所谓的陷门函数，

00:19:54,070 --> 00:19:59,850
这意味着你可以很容易地做私钥乘法，

00:19:59,850 --> 00:20:02,140
也就是说，使用私钥做乘法，

00:20:02,140 --> 00:20:03,870
我可以在曲线上跳动，

00:20:03,870 --> 00:20:05,830
但是反过来，

00:20:05,830 --> 00:20:08,740
从曲线上的这个点，

00:20:08,740 --> 00:20:10,780
找出私钥是什么，

00:20:10,780 --> 00:20:16,510
这是非常困难的，

00:20:16,510 --> 00:20:18,460
而且还没有解决，

00:20:18,460 --> 00:20:21,520
没有人知道如何从公钥或曲线上的一个点，

00:20:21,520 --> 00:20:25,510
找出私钥是什么，

00:20:25,510 --> 00:20:27,760
我们通过生成器点乘以的数字。

00:20:27,760 --> 00:20:33,010
解释为什么这个椭圆曲线很难，

00:20:33,010 --> 00:20:42,940
我认为这个椭圆曲线值得单独拍一个视频。

00:20:42,940 --> 00:20:47,950
但是我要说的是你正在进行大量的模数运算，

00:20:47,950 --> 00:20:49,330
所以在进行这种乘法运算时，

00:20:49,330 --> 00:20:53,250
会有足够多的信息被丢弃。

00:20:53,250 --> 00:20:56,200
所以你不能轻易地逆转，

00:20:56,200 --> 00:21:06,280
这就是为什么我们依赖这个曲线来保护我们的公钥和私钥。

00:21:06,280 --> 00:21:10,250
如果你想了解更多为什么不能逆转，

00:21:10,250 --> 00:21:14,690
这被称为椭圆曲线离散对数问题。

00:21:14,690 --> 00:21:16,880
我们从一个随机数开始，

00:21:16,880 --> 00:21:18,110
做一些椭圆曲线数学运算，

00:21:18,110 --> 00:21:20,750
得到曲线上的一个点，

00:21:20,750 --> 00:21:23,360
这就是我们的公钥。

00:21:23,360 --> 00:21:28,730
这就是我们的私钥和公钥之间的数学联系，

00:21:28,730 --> 00:21:34,610
通过椭圆曲线实现的。

00:21:34,610 --> 00:21:36,950
当你有不同的曲线，

00:21:36,950 --> 00:21:39,980
这个被称为SECP，

00:21:39,980 --> 00:21:43,250
它有一个特定的G生成点。

00:21:43,250 --> 00:21:55,309
所以你可以有多个密钥，

00:21:55,309 --> 00:22:02,360
但是它使用这个特定的曲线和这些特定的参数。

00:22:02,360 --> 00:22:06,169

00:22:06,169 --> 00:22:10,850
现在我们已经生成了我们的私钥和公钥，

00:22:10,850 --> 00:22:14,120
我们可以开始使用比特币了。

00:22:14,120 --> 00:22:15,830
如果你想让人们给我们发送比特币，

00:22:15,830 --> 00:22:18,440
我们只需要给他们我们的公钥，

00:22:18,440 --> 00:22:23,030
他们就可以解锁他们拥有的任何比特币，

00:22:23,030 --> 00:22:26,539
创建一个新的批次，

00:22:26,539 --> 00:22:29,419
并把锁放在上面，

00:22:29,419 --> 00:22:34,700
把这批比特币锁定到我们的公钥上。

00:22:34,700 --> 00:22:38,210
当我们想发送比特币的时候，

00:22:38,210 --> 00:22:42,289
我们收到的那些比特币已经被锁定到我们公开的公钥上了，

00:22:42,289 --> 00:22:44,990
我们只需要创建交易，

00:22:44,990 --> 00:22:50,539
然后使用我们的私钥来解锁这个锁，

00:22:50,539 --> 00:22:54,230
或者说证明我们创建了这个公钥，

00:22:54,230 --> 00:22:58,880
或者说我们有这个公钥的数学联系，

00:22:58,880 --> 00:23:01,880
其他人是没有的。

00:23:01,880 --> 00:23:10,280
那么我们如何证明我们创建了这个公钥，

00:23:10,280 --> 00:23:16,610
我们如何证明我们拥有这个公钥是由私钥创建的呢？

00:23:16,610 --> 00:23:25,520
一个糟糕的方法是把你的私钥放入你创建的交易中。

00:23:25,520 --> 00:23:30,200
这意味着任何人都可以看到这个私钥和公钥，

00:23:30,200 --> 00:23:32,530
然后说，

00:23:32,530 --> 00:23:36,169
这个人显然拥有这个私钥，

00:23:36,169 --> 00:23:37,370
因为他们已经给了我们，

00:23:37,370 --> 00:23:41,179
他们可以自己看到数学上的联系，

00:23:41,179 --> 00:23:42,220
他们可以做椭圆曲线乘法，

00:23:42,220 --> 00:23:44,450
得到相同的公钥，

00:23:44,450 --> 00:23:46,820
这证明了我们创建了这个公钥。

00:23:46,820 --> 00:23:50,540
但是问题是，

00:23:50,540 --> 00:23:52,820
当这笔交易进入比特币网络时，

00:23:52,820 --> 00:23:55,010
它将存在于所有的节点中，

00:23:55,010 --> 00:24:05,030
所以任何人都可以看到这个公开暴露的私钥。

00:24:05,030 --> 00:24:07,340
如果他们能看到它，他们就可以做的是，

00:24:07,340 --> 00:24:12,830 
如果有任何其他的比特币被锁定到与这个公钥相同的公钥上，

00:24:12,830 --> 00:24:19,610
他们就可以复制我们的私钥，

00:24:19,610 --> 00:24:27,320
并且基本上拿走所有被锁定到这个公钥上的比特币或输出。

00:24:27,320 --> 00:24:29,360
所以我们最不想做的就是把私钥给出去，

00:24:29,360 --> 00:24:33,380
那样就不行了。

00:24:33,380 --> 00:24:35,410
那么我们能做什么呢？

00:24:35,410 --> 00:24:40,970
我们需要在这笔交易中放入一些东西，

00:24:40,970 --> 00:24:43,220
证明我们创建了这个公钥，

00:24:43,220 --> 00:24:44,780
我们需要放入一些只有我们能创建的东西，

00:24:44,780 --> 00:24:48,679
其他人无法放入解锁这批比特币的东西。

00:24:48,679 --> 00:24:52,130
我们要做什么呢？

00:24:52,130 --> 00:24:53,660
我们再次使用我们的私钥，

00:24:53,660 --> 00:24:59,120
但是我们不把实际的私钥放入这个交易数据中，

00:24:59,120 --> 00:25:02,480
而是创建一个所谓的签名。

00:25:02,480 --> 00:25:05,049
这些签名非常方便，

00:25:05,049 --> 00:25:07,250
因为它们是由私钥创建的。

00:25:07,250 --> 00:25:13,620
他们实际上仍然可以证明我们创建了这个公钥。

00:25:13,620 --> 00:25:16,860
但好处是，首先，

00:25:16,860 --> 00:25:18,300
它不会泄露我们的私钥，

00:25:18,300 --> 00:25:25,950
其次，它们只对我们签名的交易有效。

00:25:25,950 --> 00:25:28,380
如果有人看到一个签名，

00:25:28,380 --> 00:25:30,480
我们有其他的比特币被这个公钥锁定，

00:25:30,480 --> 00:25:32,370
他们不能只看这个签名，

00:25:32,370 --> 00:25:35,460
把它放进这个交易，

00:25:35,460 --> 00:25:37,620
或者他们创建的交易，

00:25:37,620 --> 00:25:39,750
因为这不会起作用，

00:25:39,750 --> 00:25:46,410
因为这个签名只对我们创建的一个交易有效。

00:25:46,410 --> 00:25:55,470
你可以把签名看作是一种我们用来解锁一批比特币的特殊一次性私钥，

00:25:55,470 --> 00:25:56,130
这有道理吗？

00:25:56,130 --> 00:25:58,080
我会马上详细介绍，

00:25:58,080 --> 00:25:59,610
但只要有意义，

00:25:59,610 --> 00:26:03,030
这就是签名的基本原理。

00:26:03,030 --> 00:26:05,130
我们有一个私钥和一个公钥，

00:26:05,130 --> 00:26:11,910
但现在我们需要弄清楚如何创建数字签名，

00:26:11,910 --> 00:26:16,559
并为此锁定一批交易或一批比特币呢？

00:26:16,559 --> 00:26:20,130
而不泄露私钥，

00:26:20,130 --> 00:26:21,830
这是一个图示，

00:26:21,830 --> 00:26:23,880
所以我们需要创建一个签名。

00:26:23,880 --> 00:26:28,710
我会快速浏览这个过程，

00:26:28,710 --> 00:26:31,290
并且只会涵盖最基本的部分，

00:26:31,290 --> 00:26:33,150
不用担心，

00:26:33,150 --> 00:26:34,830
如果第一次听不完全理解，

00:26:34,830 --> 00:26:36,600
只要你大致明白就好。

00:26:36,600 --> 00:26:39,120
这涉及到一些数学。

00:26:39,120 --> 00:26:43,320
让我们用其他方法移动它，

00:26:43,320 --> 00:26:44,820
可能我有很多方式来进行，

00:26:44,820 --> 00:26:47,730
但我现在还不清楚。

00:26:47,730 --> 00:26:49,530
我们需要创建一个签名，

00:26:49,530 --> 00:26:51,480
创建签名有两个步骤，

00:26:51,480 --> 00:26:53,850
这涉及到椭圆曲线的使用。

00:26:53,850 --> 00:26:56,220
这并不奇怪，

00:26:56,220 --> 00:26:57,210
这就是我们首先使用椭圆曲线的原因，

00:26:57,210 --> 00:26:59,520
因为我们可以再次使用它来创建签名。

00:26:59,520 --> 00:27:10,440
这个创建签名的两步过程的第一部分是你需要一个随机部分，

00:27:10,440 --> 00:27:14,559
所以你首先要做的是选择一个非常大的随机数，

00:27:14,559 --> 00:27:17,830
然后再做一些椭圆曲线乘法，

00:27:17,830 --> 00:27:19,240
就像我们之前做的一样，

00:27:19,240 --> 00:27:23,440
这会给你曲线上的一个随机点。

00:27:23,440 --> 00:27:26,440 
这与我们之前做的非常相似，

00:27:26,440 --> 00:27:28,330
我们只是取了一个私钥并创建了一个公钥，

00:27:28,330 --> 00:27:29,919
这是完全一样的，

00:27:29,919 --> 00:27:31,659
但我们只是使用一个随机数，

00:27:31,659 --> 00:27:36,879
这将用于这次一次性交易的签名，

00:27:36,879 --> 00:27:43,059
因此我们在曲线上生成的这个随机点被称为我们的R，

00:27:43,059 --> 00:27:44,529
更具体地说，

00:27:44,529 --> 00:27:46,529
我们只需要它的x值。

00:27:46,529 --> 00:27:51,070
然后，使用这个随机点或x值，

00:27:51,070 --> 00:27:53,559
这只是一个数字，

00:27:53,559 --> 00:27:55,749
我们将其与我们的私钥，

00:27:55,749 --> 00:27:58,720
也只是一个数字相乘，

00:27:58,720 --> 00:28:02,350
然后添加一个被称为消息的东西，

00:28:02,350 --> 00:28:04,509
我们想要签名的东西。

00:28:04,509 --> 00:28:06,070
我们想要为这个交易创建一个签名，

00:28:06,070 --> 00:28:10,899
所以我们基本上将这个交易作为消息放在这里，

00:28:10,899 --> 00:28:12,549
这只是一堆数据，

00:28:12,549 --> 00:28:18,009
但我们并不将实际的全部数据放在这里，

00:28:18,009 --> 00:28:22,779
我们做的只是将其哈希并将数据的哈希放在这里。

00:28:22,779 --> 00:28:25,779
但基本上，

00:28:25,779 --> 00:28:28,419
我们有随机部分这个x值，

00:28:28,419 --> 00:28:30,129
我们将其与私钥相乘，

00:28:30,129 --> 00:28:38,529
然后我们只是添加了我们想要签名的交易的指纹，

00:28:38,529 --> 00:28:42,460
然后我们再将所有这些写入我们的R。

00:28:42,460 --> 00:28:44,769
所以这里的关键实际上是，

00:28:44,769 --> 00:28:46,779
我们在曲线中有一个随机点，

00:28:46,779 --> 00:28:48,700
我们在这里有一个特殊的数字，

00:28:48,700 --> 00:28:50,740
其中包含我们的私钥，

00:28:50,740 --> 00:28:53,259
我们希望签名起作用的交易的组合，

00:28:53,259 --> 00:28:58,809
这被称为S。

00:28:58,809 --> 00:29:00,700
所以你可以看到，

00:29:00,700 --> 00:29:03,309
私钥和交易数据在那里，

00:29:03,309 --> 00:29:04,680
但它们都被打乱了。

00:29:04,680 --> 00:29:06,960
如果我们看一下这个S值，

00:29:06,960 --> 00:29:08,430
他们将无法看到我们的实际私钥是什么，

00:29:08,430 --> 00:29:12,720
因为我们使用了这个R等来打乱它。

00:29:12,720 --> 00:29:15,720
但它都在那里，

00:29:15,720 --> 00:29:17,940
所以签名就是这两部分，

00:29:17,940 --> 00:29:20,250
所以你在那里放入R，

00:29:20,250 --> 00:29:21,180
并在那里放入S值。

00:29:21,180 --> 00:29:22,380
所以R只是曲线中的一个随机点，

00:29:22,380 --> 00:29:25,680
S是一个特殊的数字，

00:29:25,680 --> 00:29:28,500
包含我们的私钥和我们想要签名的交易数据，

00:29:28,500 --> 00:29:31,620
这就是我们的签名，

00:29:31,620 --> 00:29:35,280
签名只是一个R和一个S值。

00:29:35,280 --> 00:29:45,690
所以，移出那里，这就是第一部分，

00:29:45,690 --> 00:29:47,490
然后今天在继续一遍，这会很棒。

00:29:47,490 --> 00:29:55,160
你提到的第一部分是我们有相同的部分，

00:29:55,160 --> 00:29:58,020
生成一个随机数，

00:29:58,020 --> 00:30:00,090
是的，这只是一个随机数。

00:30:00,090 --> 00:30:03,960
我们把这个随机数和G相乘，

00:30:03,960 --> 00:30:05,820
就一直在曲线上跳跃，

00:30:05,820 --> 00:30:07,860
直到达到某个特定的点。

00:30:07,860 --> 00:30:13,910
在这个阶段，

00:30:13,910 --> 00:30:17,010
我们的公钥或私钥还没有进入画面，

00:30:17,010 --> 00:30:19,710
这是随机的。

00:30:19,710 --> 00:30:30,150
然后我们从私钥中取出X，

00:30:30,150 --> 00:30:32,160
我们再次跳跃。

00:30:32,160 --> 00:30:35,000
对不起，

00:30:35,000 --> 00:30:36,990
这不是椭圆曲线乘法，

00:30:36,990 --> 00:30:40,020
这只是纯数学。

00:30:40,020 --> 00:30:41,790
如果你还记得，我们的私钥只是一个数字，

00:30:41,790 --> 00:30:43,590
这个x值也只是一个数字，

00:30:43,590 --> 00:30:46,410
所以我们只做普通的数学运算，

00:30:46,410 --> 00:30:53,850
这不是椭圆乘法。

00:30:53,850 --> 00:31:00,240
然后，消息基本上就是我们的交易数据。

00:31:00,240 --> 00:31:02,490
将交易数据放入这里，

00:31:02,490 --> 00:31:07,070
这意味着这个签名只能用于特定的交易。

00:31:07,070 --> 00:31:13,440
显然，私钥在这里只是为了证明我们拥有这个公钥。

00:31:13,440 --> 00:31:16,380
从前一个视频中，

00:31:16,380 --> 00:31:19,650
这就是没有签名的交易数据。

00:31:19,650 --> 00:31:21,060
你是对的。

00:31:21,060 --> 00:31:22,950
所以你把所有这些东西都拿走，

00:31:22,950 --> 00:31:24,690
然后把所有的签名都拿走，

00:31:24,690 --> 00:31:26,370
然后对数据进行哈希处理，

00:31:26,370 --> 00:31:29,960
然后放入这里。记忆力很好。

00:31:29,960 --> 00:31:39,120
这些值的作用是帮助我们打乱私钥。

00:31:39,120 --> 00:31:46,440
所以，一个签名由两部分组成：

00:31:46,440 --> 00:31:52,620
随机的曲线上的点和一个通过使用我们的私钥得到的特殊数字。

00:31:52,620 --> 00:31:59,900
现在我们将看到为什么这个方法有效，

00:31:59,900 --> 00:32:02,190
为什么我们为签名创建了这两样东西。

00:32:02,190 --> 00:32:10,010
当我们发送这个交易数据或者整个交易进入比特币网络时，

00:32:10,010 --> 00:32:15,390
网络上的每一个节点都会进行验证，

00:32:15,390 --> 00:32:18,270
确保这是一个有效的交易。

00:32:18,270 --> 00:32:21,090
他们获取这个签名，

00:32:21,090 --> 00:32:22,260
并希望能够说，

00:32:22,260 --> 00:32:31,590
这个签名只能由拥有这个公钥所对应的私钥的人创建。

00:32:31,590 --> 00:32:36,510
所以他们需要验证这一点，

00:32:36,510 --> 00:32:40,290
以确保他们的签名始终是由这个特定的私钥创建的。

00:32:40,290 --> 00:32:43,950
那他们如何做到这一点呢？

00:32:43,950 --> 00:32:45,420
他们并没有私钥，

00:32:45,420 --> 00:32:47,880
他们只有这两个值，R值和S值，

00:32:47,880 --> 00:32:50,160
但是S值是由这个私钥创建的。

00:32:50,160 --> 00:32:53,400
那他们如何做到这一点呢？

00:32:53,400 --> 00:32:57,270
首先，他们会拿到这个给定的R值，

00:32:57,270 --> 00:32:59,130
然后开始进行一系列的步骤。

00:32:59,130 --> 00:33:02,180
同样，这对他们来说也是一个两步的过程。

00:33:02,180 --> 00:33:04,620
首先，

00:33:04,620 --> 00:33:08,290
他们会做一些常规的数学运算，

00:33:08,290 --> 00:33:15,040
他们只是将交易数据的哈希（不包括R值）与S值相乘，

00:33:15,040 --> 00:33:17,740
这将给出一个非常大的数。

00:33:17,740 --> 00:33:22,570
然后，在第一步中，

00:33:22,570 --> 00:33:23,940
他们会使用这个大数，

00:33:23,940 --> 00:33:26,380
从生成点开始，

00:33:26,380 --> 00:33:28,570
进行椭圆曲线乘法，

00:33:28,570 --> 00:33:30,250
使用这个大数字进行乘法，

00:33:30,250 --> 00:33:34,090
从G开始相乘，

00:33:34,090 --> 00:33:35,680
然后在曲线上弹跳，

00:33:35,680 --> 00:33:39,510
这将给出曲线上的第一个点。

00:33:39,510 --> 00:33:45,700
他们会再做一些常规的乘法运算，

00:33:45,700 --> 00:33:49,270
他们只需将S值乘以R值，

00:33:49,270 --> 00:33:51,730
所以只需将S值乘以R值，

00:33:51,730 --> 00:33:53,920
然后从公钥开始，

00:33:53,920 --> 00:33:59,740
在椭圆曲线上跳跃这么多次，

00:33:59,740 --> 00:34:01,360
这样在椭圆曲线上跳跃这么多次，

00:34:01,360 --> 00:34:03,930
这将给出曲线上的第二个点。

00:34:03,930 --> 00:34:08,020
现在，关键的部分是，

00:34:08,020 --> 00:34:13,600
如果这三个点在曲线上都对齐，

00:34:13,600 --> 00:34:17,310
那么这个签名就是有效的。

00:34:17,310 --> 00:34:25,060
在椭圆曲线上，

00:34:25,060 --> 00:34:26,590
如果你画出经过曲线上两点的一条直线，

00:34:26,590 --> 00:34:28,510
就像切线一样，

00:34:28,510 --> 00:34:30,010
它总是会与曲线上的另一点相交。

00:34:30,010 --> 00:34:33,100
如果你在曲线上的两点之间画一条线，

00:34:33,100 --> 00:34:38,380
它总会与曲线上的另一点相交。

00:34:38,380 --> 00:34:45,010
通过使用我们给出的这两个值，

00:34:45,010 --> 00:34:47,290
以及公钥和交易数据，

00:34:47,290 --> 00:34:51,760
我们可以在曲线上生成这两个点。

00:34:51,760 --> 00:34:54,460
如果它们都对齐，

00:34:54,460 --> 00:34:57,400
那么签名就是有效的。

00:34:57,400 --> 00:35:02,560
这意味着，如果有人篡改交易数据，

00:35:02,560 --> 00:35:04,420
我们给他们交易数据和签名，

00:35:04,420 --> 00:35:07,930
然后他们试图将比特币发送到他们的地址，

00:35:07,930 --> 00:35:10,120
他们篡改了交易数据，

00:35:10,120 --> 00:35:12,880
这意味着这个值将会不同，

00:35:12,880 --> 00:35:14,440
所以当他们生成第一个点时，

00:35:14,440 --> 00:35:17,510
它会不同，它们就不会对齐，

00:35:17,510 --> 00:35:21,000
所以签名就不会有效。

00:35:21,000 --> 00:35:26,450
这就保护了交易数据不被改变。

00:35:26,450 --> 00:35:33,120
如果有人试图使用他们自己的私钥来创建一个签名，

00:35:33,120 --> 00:35:36,030
来花费我们的比特币，

00:35:36,030 --> 00:35:40,440
不是我们用来创建公钥的那个私钥，

00:35:40,440 --> 00:35:42,510
那么当他们生成这个s值时，

00:35:42,510 --> 00:35:44,370
它将完全不同。

00:35:44,370 --> 00:35:46,200
如果这个s值不同，

00:35:46,200 --> 00:35:49,650
那么这个数就会不同。

00:35:49,650 --> 00:35:53,430
所以当我们从公钥开始进行椭圆曲线乘法时，

00:35:53,430 --> 00:35:55,470
这个点将会不同，

00:35:55,470 --> 00:35:57,960
这些点就不会对齐。

00:35:57,960 --> 00:36:07,770
这就是数字签名工作的基本概述，

00:36:07,770 --> 00:36:14,370
如果你理解的只是私钥和公钥是通过椭圆曲线相连的，

00:36:14,370 --> 00:36:18,600
我们使用椭圆曲线的原因是因为我们可以创建这些签名，

00:36:18,600 --> 00:36:24,090
其他人可以通过进行一些椭圆曲线数学验证它们，

00:36:24,090 --> 00:36:31,950
这些都是椭圆曲线的特殊性质。

00:36:31,950 --> 00:36:34,380
总的来说，

00:36:34,380 --> 00:36:36,810
你只需要拿一个私钥，

00:36:36,810 --> 00:36:42,300
进行椭圆曲线数学乘法得到公钥，

00:36:42,300 --> 00:36:43,620
然后你给其他人这个公钥，

00:36:43,620 --> 00:36:48,600
他们会将一批比特币锁定到这个公钥上。

00:36:48,600 --> 00:36:50,490
但是从那里开始，

00:36:50,490 --> 00:36:52,950
我们需要将它们发送给其他人。

00:36:52,950 --> 00:36:55,020
我们想要发送他们，

00:36:55,020 --> 00:36:57,330
我们需要证明我们是这个公钥的创建者。

00:36:57,330 --> 00:36:59,150
所以我们做的是，

00:36:59,150 --> 00:37:02,100
我们拿我们的私钥，创建一个签名，

00:37:02,100 --> 00:37:04,670
这又涉及到一些椭圆曲线数学。

00:37:04,670 --> 00:37:07,320
然后我们给他们那个签名，

00:37:07,320 --> 00:37:10,740
然后他们可以做一些验证，

00:37:10,740 --> 00:37:14,850
以验证我们是用正确的私钥创建了这个签名。

00:37:14,850 --> 00:37:17,280
他们通过取这个公钥，

00:37:17,280 --> 00:37:20,640
签名和数据，

00:37:20,640 --> 00:37:22,680
生成曲线上的三个点来做到这一点。

00:37:22,680 --> 00:37:27,120
如果他们排成一行，

00:37:27,120 --> 00:37:29,240
那么这个签名就有效。

00:37:29,240 --> 00:37:32,830
如果有人不使用正确的私钥，

00:37:32,830 --> 00:37:35,660
他们就不会排成一行，

00:37:35,660 --> 00:37:37,730
或者如果有人篡改交易数据，

00:37:37,730 --> 00:37:41,540
他们也不会排成一行。

00:37:41,540 --> 00:37:44,660
这整个过程有点神奇，

00:37:44,660 --> 00:37:47,030
但最终它都是数学。

00:37:47,030 --> 00:37:52,010
如果你从这几张幻灯片中学到了什么，

00:37:52,010 --> 00:37:57,290
那就是椭圆曲线数学非常适合用于密码学，

00:37:57,290 --> 00:38:04,010
非常适合创建账号和密码，

00:38:04,010 --> 00:38:05,660
然后能够证明你拥有账号，

00:38:05,660 --> 00:38:07,670
而无需给出密码，

00:38:07,670 --> 00:38:11,960
这非常聪明。

00:38:11,960 --> 00:38:14,300
所以这就叫做椭圆曲线密码学，

00:38:14,300 --> 00:38:18,110
它非常有用。

00:38:18,110 --> 00:38:23,840
没有它，我们就无法安全地发送和接收比特币，

00:38:23,840 --> 00:38:26,050
而不需要一个人控制所有的钥匙。

00:38:26,050 --> 00:38:30,619
所以，通过这种椭圆曲线密码学，

00:38:30,619 --> 00:38:33,230
我们可以生成我们自己的账号和密码，

00:38:33,230 --> 00:38:34,820
以便发送和接收比特币，

00:38:34,820 --> 00:38:38,600
这非常方便。

00:38:38,600 --> 00:38:39,890
就像我在开始的时候说的，

00:38:39,890 --> 00:38:47,480
这就是为什么比特币和其他货币被称为加密货币，

00:38:47,480 --> 00:38:58,200
因为他们使用密码学作为比特币批次所有权的支柱。

00:38:58,200 --> 00:39:01,030
所以让我把所有这些都移到这里，

00:39:01,030 --> 00:39:08,530
这就是私钥，公钥和签名。

00:39:08,530 --> 00:39:14,050
所以这是发送或接收比特币的基本原理，

00:39:14,050 --> 00:39:24,970
它只需要一组密钥和数字签名来证明你拥有公钥的所有权。

00:39:24,970 --> 00:39:26,680
你可能听说过地址，

00:39:26,680 --> 00:39:29,680
那么什么是地址呢？

00:39:29,680 --> 00:39:36,010
地址基本上就是公钥的更美观、对用户更友好的版本。

00:39:36,010 --> 00:39:39,880
在比特币中，

00:39:39,880 --> 00:39:43,420
你可以生成一个私钥和一个公钥，

00:39:43,420 --> 00:39:45,700
将公钥给其他人，

00:39:45,700 --> 00:39:50,410
他们会将比特币锁定到你的公钥中，

00:39:50,410 --> 00:39:56,820
然后你可以使用私钥创建签名并发送它们。

00:39:56,820 --> 00:39:59,880
这个过程完全有效，

00:39:59,880 --> 00:40:03,160
如果有人查看这个公钥，

00:40:03,160 --> 00:40:06,670
他们不能像我之前说的那样推算出私钥，

00:40:06,670 --> 00:40:10,750
因为你不能通过椭圆曲线乘法反向运算。

00:40:10,750 --> 00:40:13,780
你可以以这个方式，我们不可以，

00:40:13,780 --> 00:40:17,740
这也意味着如果这个问题被解决，

00:40:17,740 --> 00:40:20,140
那么你的公钥和比特币可能会被盗。

00:40:20,140 --> 00:40:23,500
虽然目前看来这个问题不太可能被解决，

00:40:23,500 --> 00:40:25,780
对于通过椭圆曲线，

00:40:25,780 --> 00:40:28,240
这意味着，

00:40:28,240 --> 00:40:32,350
如果椭圆曲线能被破解，

00:40:32,350 --> 00:40:35,230
那么你的公钥和比特币就可能被盗。

00:40:35,230 --> 00:40:39,580
我的意思是，没有人可以在可预见的未来，

00:40:39,580 --> 00:40:41,260
没有人能看到这种情况发生，

00:40:41,260 --> 00:40:45,220
但这确实意味着但这个公钥就像一只待宰的鸭子，

00:40:45,220 --> 00:40:48,910
如果椭圆曲线能被破解，那么它就可能被攻破。

00:40:48,910 --> 00:40:51,790
所以在比特币中，

00:40:51,790 --> 00:40:54,910
我们喜欢使用更多的安全措施，

00:40:54,910 --> 00:41:01,440
我们不仅仅依赖椭圆曲线离散对数问题来保护我们的比特币。

00:41:01,440 --> 00:41:09,570
我们的解决方案是将公钥通过两种不同的哈希函数进行两次哈希，

00:41:09,570 --> 00:41:14,370
第一种是你应该熟悉的sha-256，

00:41:14,370 --> 00:41:16,290
这是挖矿时用到的，

00:41:16,290 --> 00:41:18,720
第二种是RIPEMD160。

00:41:18,720 --> 00:41:25,950
所以他所说的就是像通过两个不同的哈希函数，

00:41:25,950 --> 00:41:27,960
对公钥进行双重哈希，

00:41:27,960 --> 00:41:37,380
然后你将哈希后的公钥而不是标准的公钥给其他人，

00:41:37,380 --> 00:41:40,560
这就像是公钥的加密版本。

00:41:40,560 --> 00:41:45,450
其他人会将这些放在锁中，

00:41:45,450 --> 00:41:52,050
这意味着当公钥的哈希版本在锁中时，

00:41:52,050 --> 00:41:56,550
如果有人想获取你的私钥，

00:41:56,550 --> 00:41:59,490
而不仅仅是从公钥开始并试图反向操作，

00:41:59,490 --> 00:42:02,250
这是不能做到的。

00:42:02,250 --> 00:42:05,820
但这是唯一的办法。

00:42:05,820 --> 00:42:08,790
如果你想从这个公钥的哈希版本中找出你的私钥，

00:42:08,790 --> 00:42:12,900
你需要破解RIPEMD哈希函数，

00:42:12,900 --> 00:42:15,660
这是没有人能做到的。

00:42:15,660 --> 00:42:20,280
你还需要能够反向操作SHA-256哈希函数，

00:42:20,280 --> 00:42:22,620
这也是没有人能做到的。在做完这些之后，

00:42:22,620 --> 00:42:24,600
我会给你私钥，然后使用这个私钥，

00:42:24,600 --> 00:42:26,840
你需要反向操作并破解这个椭圆曲线，

00:42:26,840 --> 00:42:30,300
这也是没有人做到的。

00:42:30,300 --> 00:42:40,170
这个哈希版本是公钥的一个非常安全的版本。

00:42:40,170 --> 00:42:41,850
我们之所以创建这个版本，

00:42:41,850 --> 00:42:47,130
是因为所有的比特币批次都将包含一个公钥。

00:42:47,130 --> 00:42:49,890
这只是一个非常安全的公钥版本，

00:42:49,890 --> 00:42:52,170
因为很难追溯到私钥。

00:42:52,170 --> 00:42:53,460
如果有一个待宰的鸭子，

00:42:53,460 --> 00:42:54,960
我们就让它变得非常安全。

00:42:54,960 --> 00:42:58,950
这有两个公钥，

00:42:58,950 --> 00:43:04,680
我们称之为哈希160的公钥。

00:43:04,680 --> 00:43:10,110
这只是因为我们使用了哈希函数，

00:43:10,110 --> 00:43:13,960
最后一个我们使用的是RIPEMD-160，

00:43:13,960 --> 00:43:16,450
所以它通常被简化为哈希160公钥。

00:43:16,450 --> 00:43:24,040
我们现在已经对公钥进行了哈希，

00:43:24,040 --> 00:43:27,490
但问题是在此之前，

00:43:27,490 --> 00:43:29,320
我们只需要将公钥放在这里，

00:43:29,320 --> 00:43:31,360
然后在这里创建一个签名。

00:43:31,360 --> 00:43:38,830
但是，经过哈希处理的公钥与私钥之间没有数学联系，

00:43:38,830 --> 00:43:45,130
所以我们不能只是在这里放一个签名。

00:43:45,130 --> 00:43:49,390
当我们想要发送比特币时，

00:43:49,390 --> 00:43:49,780
我们应该做什么呢？

00:43:49,780 --> 00:43:53,230
我们现在应该在这个解锁代码中放什么呢？

00:43:53,230 --> 00:43:55,930
我们仍然在这里放签名，

00:43:55,930 --> 00:43:58,630
但是除了签名，

00:43:58,630 --> 00:44:00,580
我们还放入公钥。

00:44:00,580 --> 00:44:06,430
所以这意味着这个锁现在已经进行了一些调整，

00:44:06,430 --> 00:44:09,090
要求提供公钥和签名。

00:44:09,090 --> 00:44:11,950
首先，

00:44:11,950 --> 00:44:18,910
我会做的是检查你在这里输入的公钥是否与哈希版本相匹配。

00:44:18,910 --> 00:44:20,710
任何人都可以做到。

00:44:20,710 --> 00:44:21,970
这是通过这两个哈希函数来完成的，

00:44:21,970 --> 00:44:24,910
然后，它会做之前做过的事情，

00:44:24,910 --> 00:44:27,460
检查签名是否有效。

00:44:27,460 --> 00:44:34,180
之后我们在这里有公钥，

00:44:34,180 --> 00:44:39,070
只需要一步就可以比较签名和公钥。

00:44:39,070 --> 00:44:40,780
现在，这是一个两步的过程，

00:44:40,780 --> 00:44:42,730
首先比较公钥和你给出的哈希版本，

00:44:42,730 --> 00:44:44,590
如果检查正确，

00:44:44,590 --> 00:44:50,020
那么它会校验签名和公钥。

00:44:50,020 --> 00:44:52,770
基本上，它只是增加了一个步骤。

00:44:52,770 --> 00:44:59,220
所以从这个意义上说，

00:44:59,220 --> 00:45:04,720
我们确实有用于hash160的公钥，

00:45:04,720 --> 00:45:10,720
这是公开的信息。

00:45:10,720 --> 00:45:12,100
如果你现在想问的是，

00:45:12,100 --> 00:45:13,810
如果最终我们还是要公开公钥，

00:45:13,810 --> 00:45:16,630
那么哈希这个公钥并公开有什么意义呢？

00:45:16,630 --> 00:45:18,070
无论如何，

00:45:18,070 --> 00:45:21,300
最终都会得到公钥

00:45:23,610 --> 00:45:26,230
这个思路是，

00:45:26,230 --> 00:45:29,990
这个公钥只在最后一刻被公开。

00:45:29,990 --> 00:45:37,320
假设需要一些时间来通过暴力破解得到这个椭圆曲线的反向计算。

00:45:37,320 --> 00:45:40,350
如果它被某种方式破解了，

00:45:40,350 --> 00:45:42,330
首先，如果它完全破解了，

00:45:42,330 --> 00:45:44,460
那么你的比特币是安全的，

00:45:44,460 --> 00:45:45,840
因为如果你不花费它们，

00:45:45,840 --> 00:45:47,160
那么其他人就无法取走它们。

00:45:47,160 --> 00:45:50,490
但显然，这并不是很好。

00:45:50,490 --> 00:45:52,140
但这个公钥的思路是，

00:45:52,140 --> 00:45:53,610
你只在最后一刻公开。

00:45:53,610 --> 00:45:55,050
如果它在最后一刻被公开，

00:45:55,050 --> 00:46:02,790
那么希望其他人不会有时间快速反向工作以窃取你的比特币。

00:46:02,790 --> 00:46:07,340
但另一方面，

00:46:07,340 --> 00:46:09,510
我认为这总比没有好。

00:46:09,510 --> 00:46:13,410
所以这就是我们使用这个哈希版本的原因。

00:46:13,410 --> 00:46:19,619
这个哈希版本并不会给任何人提供任何激励去尝试反向工作，

00:46:19,619 --> 00:46:24,570
因为他们首先必须通过这些哈希函数。

00:46:21,510 --> 00:46:24,570
这是很困难的。

00:46:24,570 --> 00:46:27,060
我的想法是，

00:46:27,060 --> 00:46:32,369
假设我们有10个比特币在这个工作后面。

00:46:32,369 --> 00:46:37,580
我们花费了一个比特币，

00:46:37,580 --> 00:46:40,410
这个过程中，

00:46:40,410 --> 00:46:50,010
攻击者可以获取到公钥的哈希160。

00:46:50,010 --> 00:46:54,690
你所做的是，你想在这里发送10个比特币，

00:46:54,690 --> 00:46:56,970
我们想发送一个比特币给其他人，

00:46:56,970 --> 00:46:59,520
然后我们想为自己保留剩余的比特币

00:46:59,520 --> 00:47:02,550
这里建议的是，

00:47:02,550 --> 00:47:06,930
创建一个新地址，

00:47:06,930 --> 00:47:10,109
这就是为什么每个人都说不要使用重复相同的地址，

00:47:10,109 --> 00:47:14,250
因为当你更改发送给自己时，

00:47:14,250 --> 00:47:16,200
如果你使用不同的地址，

00:47:16,200 --> 00:47:18,300
即使你放弃了自己的公钥，

00:47:18,300 --> 00:47:20,040
实际上它也没有用，

00:47:20,040 --> 00:47:26,280
因为所有锁定到这个公钥的比特币都被花掉并转移了。

00:47:26,280 --> 00:47:31,770
这就是为什么每个人都说不要使用重复不同的地址，

00:47:31,770 --> 00:47:34,600
或每次都使用不同的地址进行更改。

00:47:34,600 --> 00:47:37,450
最后一刻的逻辑，

00:47:37,450 --> 00:47:40,990
感觉这是因为如果它是一个新地址，

00:47:40,990 --> 00:47:46,060
你又不知道公钥。

00:47:46,060 --> 00:47:48,070
所以这是有意义的，

00:47:48,070 --> 00:47:53,650
很明显现在你仍然可以使用，

00:47:53,650 --> 00:47:57,070
如果你退回去你仍然可以使用这个方法，

00:47:57,070 --> 00:47:58,570
你仍然可以创建执行此操作的锁

00:47:58,570 --> 00:48:06,970
但现在所有的钱包都使用它来哈希公钥，

00:48:06,970 --> 00:48:08,770
这样更安全

00:48:08,770 --> 00:48:10,480
但你仍然可以使用它

00:48:10,480 --> 00:48:12,010
把公钥放在这里，只使用一个签名，

00:48:12,010 --> 00:48:15,070
这就是区块链中很多早期交易的形式，

00:48:15,070 --> 00:48:16,480
如果你检查他们，

00:48:16,480 --> 00:48:18,400
他们使用一个非常简单的公钥和签名，

00:48:18,400 --> 00:48:29,910
但现在所有的交易都使用这个锁内的哈希版本。

00:48:29,910 --> 00:48:35,410
然后在解锁代码中加入公钥和签名。

00:48:35,410 --> 00:48:42,550
刚刚我对这些锁如何工作做了一个冗长的描述，

00:48:42,550 --> 00:48:48,460
我将在下一个视频中会详细解释这些锁是如何工作的。

00:48:48,460 --> 00:48:50,080
所以这就是锁定代码，

00:48:50,080 --> 00:48:51,880
这就是解锁代码。

00:48:51,880 --> 00:48:56,880
最后，像我说的，

00:48:56,880 --> 00:49:00,340
什么是地址？

00:49:00,340 --> 00:49:01,780
我必须通过这个来向你展示一个地址的来源。

00:49:01,780 --> 00:49:06,750
就像我在上一次说的，

00:49:06,750 --> 00:49:10,180
可能你想接收比特币，

00:49:10,180 --> 00:49:12,670
我们给出这个公钥的哈希版本。

00:49:12,670 --> 00:49:14,980
但是如果你实际看一下所有的这些数据，

00:49:14,980 --> 00:49:17,860
比如说这是一个私钥，

00:49:17,860 --> 00:49:20,590
然后这是一个公钥，

00:49:20,590 --> 00:49:23,740
也是一个大数字。

00:49:23,740 --> 00:49:27,460
这些通常以十六进制格式存储，

00:49:27,460 --> 00:49:30,400
所以让我快速转换一下。

00:49:30,400 --> 00:49:37,049
当我们通过这两个哈希函数对所有这些数据进行哈希，

00:49:37,049 --> 00:49:45,130
我们最后得到这个公钥的哈希版本的十六进制数字。

00:49:45,130 --> 00:49:46,089
这个方法是可行的，我们可以把这个给别人，

00:49:46,089 --> 00:49:47,019
这没问题。

00:49:47,019 --> 00:49:49,420
这就是你想让它简单，

00:49:49,420 --> 00:49:53,200
你可以直接给人们这个公钥的直接哈希版本。

00:49:53,200 --> 00:49:55,390
但是问题是，

00:49:55,390 --> 00:49:56,729
它对用户并不友好。

00:49:56,729 --> 00:50:00,099
因为你把它给别人，

00:50:00,099 --> 00:50:03,640
或者你在电话上描述这个公钥，

00:50:03,640 --> 00:50:06,059
假设别人把它键入，

00:50:06,059 --> 00:50:09,190
然后他们犯了一个错误，然后他们填写完了。

00:50:09,190 --> 00:50:12,039
如果他们犯了一个简单的错误，

00:50:12,039 --> 00:50:16,079
那么它就会把比特币发送到一个完全不同的地址，

00:50:16,079 --> 00:50:18,430
所以它会丢失那些比特币，

00:50:18,430 --> 00:50:20,789
这个人就不会收到它们。

00:50:20,789 --> 00:50:24,880
所以这不好。

00:50:24,880 --> 00:50:27,220
当你键入这个公钥的哈希版本时，

00:50:27,220 --> 00:50:30,099
没有进行错误检查。

00:50:30,099 --> 00:50:33,009
其次，它有点长，

00:50:33,009 --> 00:50:35,859
如果你能让它短一些，那就太好了。

00:50:35,859 --> 00:50:37,900
但是最重要的是，没有错误检查。

00:50:37,900 --> 00:50:40,779
所以我们可以做些什么来让这些地址对用户更友好呢？

00:50:40,779 --> 00:50:50,049
地址就是这个公钥的一个对用户更加友好的版本，

00:50:50,049 --> 00:50:52,839
它包含错误检查，

00:50:52,839 --> 00:50:55,839
并且它会短一些。

00:50:55,839 --> 00:50:58,569
那我们如何修复这个错误呢?

00:50:58,569 --> 00:51:02,380
我们做的是检查问题，我们创建了一个叫做校验和的东西，

00:51:02,380 --> 00:51:07,869
我们对密钥进行哈希，

00:51:07,869 --> 00:51:10,739
这会给我们一个长数字。

00:51:10,739 --> 00:51:13,509
如果我们只取前四位字节，

00:51:13,509 --> 00:51:16,779
即这个公钥的哈希值，

00:51:16,779 --> 00:51:18,999
那就是所谓的校验和，

00:51:18,999 --> 00:51:21,719
我们把它放在最后。

00:51:21,719 --> 00:51:29,619
这意味着如果有人在他们的钱包软件中输入整个公钥，

00:51:29,619 --> 00:51:34,269
如果他们在这里犯了一个错误，

00:51:34,269 --> 00:51:37,329
钱包软件可以哈希这个，

00:51:37,329 --> 00:51:40,450
并检查这部分的密钥是否与校验和匹配，

00:51:40,450 --> 00:51:43,239
如果不匹配，

00:51:43,239 --> 00:51:44,489
那么他们就知道某个地方犯了错误，

00:51:44,489 --> 00:51:46,539
虽然不能告诉你错误在哪里，

00:51:46,539 --> 00:51:49,119
但至少会发出警告，

00:51:49,119 --> 00:51:50,770
告诉你你犯了错误，

00:51:50,770 --> 00:51:57,150
这总比什么都没有好。

00:51:57,150 --> 00:52:00,610
我说过这个有点长，

00:52:00,610 --> 00:52:03,550
我们能不能把它弄短一点呢?

00:52:03,550 --> 00:52:06,670
我在这里有校验和，公钥变得更长了，

00:52:06,670 --> 00:52:08,320
我们能不能缩短它呢?

00:52:08,320 --> 00:52:13,119
是的，我们可以。

00:52:13,119 --> 00:52:16,680
这个版本已经用十六进制格式编码，

00:52:16,680 --> 00:52:21,280
它有16个字符可以选择。

00:52:21,280 --> 00:52:24,220
如果它只是一个数字，

00:52:24,220 --> 00:52:28,630
而不是用16个字符编码的格式呢?

00:52:28,630 --> 00:52:32,290
如果我们用更多的字符，而不是16个字符，

00:52:32,290 --> 00:52:33,730
那么如果我们用整个字母数字字母表，

00:52:33,730 --> 00:52:37,150
它有62个字符

00:52:37,150 --> 00:52:39,010
，如果我们开始使用这些，

00:52:39,010 --> 00:52:42,160
那么我们可以用更少的字符，

00:52:42,160 --> 00:52:45,820
更短的空间来表示这个数字。

00:52:45,820 --> 00:52:50,320
使用所有这些字符的问题是，

00:52:50,320 --> 00:52:51,940
有些字符很难打出来，

00:52:51,940 --> 00:52:56,410
比如0和o看起来一样，

00:52:56,410 --> 00:52:58,780
所以我们不想用那些。

00:52:58,780 --> 00:53:01,060
L和大写的i看起来也一样，

00:53:01,060 --> 00:53:02,710
所以我们也不想用那些。

00:53:02,710 --> 00:53:04,210
所以如果你把这些踢出去，

00:53:04,210 --> 00:53:07,960
我们就有58个字符可以选择。

00:53:07,960 --> 00:53:13,359
当你在特定的格式中编码数字时，

00:53:13,359 --> 00:53:14,530
你可以选择的字符的数量也被称为基数。
number of characters you have to choose

1175
00:53:14,530 --> 00:53:16,750
所以这是基数16，

00:53:16,750 --> 00:53:20,500
这是基数58。

00:53:20,500 --> 00:53:24,609
基数58就是字母数字字母表中的字符，

00:53:24,609 --> 00:53:28,150
去掉了那些难以区分的字符。

00:53:28,150 --> 00:53:30,970
如果你把所有这些数据，

00:53:30,970 --> 00:53:33,160
包含校验和的公钥，

00:53:33,160 --> 00:53:38,109
用Base58的字符编码成这种格式，

00:53:38,109 --> 00:53:39,790
你会得到一个稍微短一点，

00:53:39,790 --> 00:53:41,680
稍微对用户友好的地址，

00:53:41,680 --> 00:53:44,230
但最重要的是，

00:53:44,230 --> 00:53:46,480
它具有这种箭头跟踪功能，

00:53:46,480 --> 00:53:53,910
这就是为什么觉得这种特殊的格式看起来有点熟悉。
 
00:53:53,910 --> 00:53:56,310
所以基本上，

00:53:56,310 --> 00:53:59,740
这就是我们所说的地址，

00:53:59,740 --> 00:54:05,950
这个地址就是公钥哈希的美化版本。

00:54:05,950 --> 00:54:10,510
我们可以选择给出哈希版本，

00:54:10,510 --> 00:54:12,070
如果我们愿意的话，

00:54:12,070 --> 00:54:14,950
我们可以放弃哈希版本，

00:54:14,950 --> 00:54:16,870
但是现在的钱包都要求提供一个地址，

00:54:16,870 --> 00:54:19,270
所以你给出地址，

00:54:19,270 --> 00:54:22,660
这意味着如果他们输入错误，

00:54:22,660 --> 00:54:24,340
钱包软件就可以指出有问题。

00:54:24,340 --> 00:54:32,380
所以使用这个地址对用户更友好，也更安全。

00:54:32,380 --> 00:54:36,910
你可以很容易地在Base58编码和解码之间来回转换，

00:54:36,910 --> 00:54:40,450
这并没有使用任何特定的哈希函数，

00:54:40,450 --> 00:54:44,860
它只是从一种数字格式转换为另一种数字格式，

00:54:44,860 --> 00:54:49,600
就像从十进制转换为十六进制一样。

00:54:49,600 --> 00:54:50,920
这是一种数字转换，

00:54:50,920 --> 00:54:54,430
但仍然看到的是相同的数字。

00:54:54,430 --> 00:54:56,860
你可以来回转换，

00:54:56,860 --> 00:55:00,130
基数16，基数58，你可以来回转换

00:55:00,130 --> 00:55:05,860
当你实际给出一个地址或者在钱包中输入一个地址时，

00:55:05,860 --> 00:55:07,480
钱包在创建交易时，

00:55:07,480 --> 00:55:13,090
会计算出公钥的哈希值，

00:55:13,090 --> 00:55:16,000
然后将其作为锁。

00:55:16,000 --> 00:55:18,250
所以，即使你输入了一个地址，

00:55:18,250 --> 00:55:22,210
钱包也会将其转换为哈希版本。

00:55:22,210 --> 00:55:23,770
如果你查看区块链，

00:55:23,770 --> 00:55:30,310
你会发现区块链上的锁中并没有实际的地址，

00:55:30,310 --> 00:55:32,200
只有公钥的哈希版本，

00:55:32,200 --> 00:55:34,120
或者说在交易数据中只有公钥的哈希版本。

00:55:34,120 --> 00:55:43,630
希望这个解释对你有所帮助。

00:55:43,630 --> 00:55:46,390
最后，让我们看一些代码示例，

00:55:46,390 --> 00:55:49,960
如果你明白了这一切，

00:55:49,960 --> 00:55:52,030
就能理解密钥和地址是如何工作的。

00:55:52,030 --> 00:55:53,980
你需要拥有基础的私钥和公钥，

00:55:53,980 --> 00:55:56,470
这是发送和接收交易所必需的。

00:55:56,470 --> 00:55:59,170
然后你创建数字签名，

00:55:59,170 --> 00:56:02,590
这样我们就可以证明在公钥上的私钥是存在的。

00:56:02,590 --> 00:56:06,610
我们可以证明我们用私钥创建了公钥，

00:56:06,610 --> 00:00:56:10,000
但实际上我们永远不需要公开私钥，

00:56:10,000 --> 00:56:14,190
这就是创建数字签名的交易系统如何工作的。

00:56:14,190 --> 00:56:21,540
最后，我们创建了一个地址。

00:56:21,540 --> 00:56:26,770
实际上，所有的交易数据都有公钥，

00:56:26,770 --> 00:56:32,830
而地址只是对用户友好的方式。

00:56:32,830 --> 00:56:35,800
但在实际的交易中，

00:56:35,800 --> 00:56:39,850
使用的是公钥和哈希公钥，

00:56:39,850 --> 00:56:44,860
地址只是为了对用户更友好。

00:56:44,860 --> 00:56:45,970
所以如果你明白了这一切，

00:56:45,970 --> 00:56:47,460
那你就理解了密钥和地址是如何工作的。

00:56:47,460 --> 00:56:50,650
在这最后的部分，

00:56:50,650 --> 00:56:53,380
这很快就完成了，不是太复杂，

00:56:53,380 --> 00:56:56,080
只是如何生成自己的一套密钥和地址。

00:56:56,080 --> 00:56:58,870
我认为这很有趣，

00:56:58,870 --> 00:57:01,420
虽然需要一些编码，

00:57:01,420 --> 00:57:06,880
但你实际上可以很容易地创建自己的一套密钥。

00:57:06,880 --> 00:57:08,470
这样你就可以发送和接收比特币，

00:57:08,470 --> 00:57:09,790
这是一件非常有趣的事情，

00:57:09,790 --> 00:57:12,520
如果你想开始使用比特币。

00:57:12,520 --> 00:57:14,530
现在我将向你展示所有的技术细节，

00:57:14,530 --> 00:57:16,480
如何实际创建你自己的一套密钥，

00:57:16,480 --> 00:57:18,630
从私钥开始。
set of keys start with a private key so

1269
00:57:18,630 --> 00:57:21,580
让我把这个移动过去，让它变大一点。
let me just move this across make that

1270
00:57:21,580 --> 00:57:24,610
首先，假设你正在进行一些编程工作，
bit bigger so first of all let's see you

1271
00:57:24,610 --> 00:57:27,370
你想要创建你自己的静态生成的一组密钥，

00:57:27,370 --> 00:57:29,710
你首先开始生成一个私钥。
own set of keys you first of all start

1274
00:57:29,710 --> 00:57:32,560
如果你记得，
by generating a private key and if you

1275
00:57:32,560 --> 00:57:33,880
私钥只是一个随机数。
remember a private key just a random

1276
00:57:33,880 --> 00:57:41,050
生成这个随机数最重要的一点就是你需要使用一个安全的随机数源。

00:57:41,050 --> 00:57:43,620
这是迄今为止最重要的一部分，
this is the most important part by far

1280
00:57:43,620 --> 00:57:45,370
确保它是安全的。
make sure it's secure

1281
00:57:45,370 --> 00:57:50,590
不要只是使用你的编程语言中的标准随机数生成器，

00:57:50,590 --> 00:57:52,270
它们可能不够安全。
language they're probably not secure

1284
00:57:52,270 --> 00:57:57,390
对于这种情况，
enough for this kind of stuff so good

1285
00:57:57,390 --> 00:57:59,740
好的随机数源，据我所知，
sources of randomness as far as I'm

1286
00:57:59,740 --> 00:58:02,790
是使用Open SSL库，
aware is using the open SSL library

1287
00:58:02,790 --> 00:58:08,290
每种编程语言都应该能够使用它。

00:58:08,290 --> 00:58:10,840
如果你在Linux上，
you're on Linux use dev read bytes from

1290
00:58:10,840 --> 00:58:12,580
使用dev从/dev/urandom读取字节，
dev you random that should be random

1291
00:58:12,580 --> 00:58:14,520
这应该对你来说足够随机。
enough for you

1292
00:58:14,520 --> 00:58:19,210
另外，如果你在你的编程语言中搜索，

00:58:19,210 --> 00:58:24,010
应该有一个库能够让你快速轻松地访问这两个东西。

00:58:24,010 --> 00:58:27,700
在Ruby中，
things if they're available so in Ruby

1297
00:58:27,700 --> 00:58:31,540
它被称为安全随机数，
it's called secure random not sure it is

1298
00:58:31,540 --> 00:58:33,430
不确定在其他语言中是什么，
in other languages but just have a look

1299
00:58:33,430 --> 00:58:37,540
但是可以去寻找一下你的编程语言中最安全的随机数源，

00:58:37,540 --> 00:58:41,560
这非常重要。
it's very important so again okay so you

1302
00:58:41,560 --> 00:58:42,970
再次强调，
are secure a source of randomness you

1303
00:58:42,970 --> 00:58:46,030
你需要一个安全的随机数源，
need to generate a 256 bit number so

1304
00:58:46,030 --> 00:58:49,000
你需要生成一个256位的数字，
that's between one and a number that is

1305
00:58:49,000 --> 00:58:52,540
也就是在1和2的256次方之间的一个数字，
2 to the power of 256 which in decimal

1306
00:58:52,540 --> 00:58:59,349
用十进制表示就是这个数。
is this but to be precise it's actually

1307
00:58:59,349 --> 00:59:02,530
但为了准确，
the range of valid private keys is

1308
00:59:02,530 --> 00:59:04,810
实际上有效的私钥范围略小于这个，
slightly less than this and that's

1309
00:59:04,810 --> 00:59:08,200
这是因为比特币中使用的特定曲线的限制。

00:59:08,200 --> 00:59:14,170
这个曲线有一个叫做n的参数，

00:59:14,170 --> 00:59:17,130
这就是曲线上的点的数量，
points on the curve and you cannot

1314
00:59:17,130 --> 00:59:19,710
你的私钥不能超过这个。
exceed this for your private key and

1315
00:59:19,710 --> 00:59:23,349
这实际上只比2的256次方小一点。
it's only actually a little bit smaller

1316
00:59:23,349 --> 00:59:25,510
它非常接近，
than 2 to the power of 256 it's very

1317
00:59:25,510 --> 00:59:28,329
但为了确保无误，
close to it but just to be sure I don't

1318
00:59:28,329 --> 00:59:30,310
我甚至没有看到这个数字在变化，
even see this number changing but this

1319
00:59:30,310 --> 00:59:36,430
但这是2的256次方。
is 2 2 power of 56 but this is the N or

1320
00:59:36,430 --> 00:59:38,170
这就是曲线上的点数N，
the number of points on the curve so

1321
00:59:38,170 --> 00:59:40,000
所以要确保它低于这个值。
make sure it's below this and if you

1322
00:59:40,000 --> 00:59:42,040
如果你在谷歌上搜索曲线的名称SECP 256 K1，
google around the name of the curve SEC

1323
00:59:42,040 --> 00:59:45,130
你可以找到N的参数。
P 2 5 6 K 1 you can find the parameter

1324
00:59:45,130 --> 00:59:50,050
所以我们只是生成一个随机数，
for n so there we are we just generate a

1325
00:59:50,050 --> 00:59:51,970
我们可以证明它低于这个最大值。
random number we can show us below this

1326
00:59:51,970 --> 00:59:54,940
这就是私钥，
maximum value here so that's the private

1327
00:59:54,940 --> 00:59:57,660
只需要生成一个随机数。
key done just generate a random number

1328
00:59:57,660 --> 01:00:00,490
其次，我们现在想要创建公钥，
secondly now we want to create the

1329
01:00:00,490 --> 01:00:02,859
我们需要使用椭圆曲线，
public key we need to use the elliptic

1330
01:00:02,859 --> 01:00:10,210
实际上我们需要做椭圆曲线乘法，

01:00:10,210 --> 01:00:17,410
但实际上在你的编程语言中可能有一个库可以让你访问，

01:00:17,410 --> 01:00:20,020
如果要给出东西，
to give stuff so you can just include

1336
01:00:20,020 --> 01:00:21,790
你就可以包含它并让它做一些椭圆曲线乘法。
that in and just ask it to do some

1337
01:00:21,790 --> 01:00:25,599
所以你在为自己编写代码时，

01:00:25,599 --> 01:00:26,710
可以找个库来帮你。
get a librarian

1340
01:00:26,710 --> 01:00:32,349
你需要做的就是做椭圆曲线乘法，

01:00:32,349 --> 01:00:38,170
将这个生成点或这个值和你的私钥进行乘法运算，

01:00:38,170 --> 01:00:41,619
最后的结果就是公钥。
point will be this public key and the

1345
01:00:41,619 --> 01:00:44,410
公钥是这个点的x和y值。
public key is the ax and y value at this

1346
01:00:44,410 --> 01:00:50,080
显然，这个公钥相当大，
point obviously this public key is quite

1347
01:00:50,080 --> 01:00:53,200
我们有两个256位的数字，
large we've got to 256 bit numbers here

1348
01:00:53,200 --> 01:00:55,270
这会占用很多空间。
so that's gonna take up a lot of space

1349
01:00:55,270 --> 01:00:58,720
在比特币中，
and ID be in Bitcoin because the

1350
01:00:58,720 --> 01:01:01,330
因为区块链是一个共享文件，
blockchain is a shared file we don't be

1351
01:01:01,330 --> 01:01:02,650
我们不希望占用太多空间。
taking up too much space if we don't

1352
01:01:02,650 --> 01:01:04,450
所以我们可以将这个数字缩小一点，
have to so what we can do we can

1353
01:01:04,450 --> 01:01:05,470
actually shrink this number down a

1354
01:01:05,470 --> 01:01:08,550
我们可以这样做，

little bit and we can do that because

1355
01:01:08,550 --> 01:01:10,750
因为椭圆曲线的一个便利特性是它沿着x轴对称。
one of the handy properties are this

1356
01:01:10,750 --> 01:01:13,030
elliptic curve is that it's symmetrical

1357
01:01:13,030 --> 01:01:15,490
所以这意味着，
along the x-axis so what that means is

1358
01:01:15,490 --> 01:01:17,800
如果你有一个x值，
if you have an x value then it's only

1359
01:01:17,800 --> 01:01:20,020
那么它的y值只有两个可能的值。
the Y value it's only gonna be one of

1360
01:01:20,020 --> 01:01:23,020
所以对于每个x值，
two different values so for every x

1361
01:01:23,020 --> 01:01:26,440
只有两个给定的y值。
value there's only two given Y values so

1362
01:01:26,440 --> 01:01:29,040
你可以考虑是Y或者-Y。
you could think about being Y or minus y

1363
01:01:29,040 --> 01:01:35,320
这个椭圆曲线的一个便利的性质是，
and one of the handy properties of this

1364
01:01:35,320 --> 01:01:37,869
如果这个Y值是偶数，
elliptic curve is that if this Y value

1365
01:01:37,869 --> 01:01:40,750
那么它就是曲线上的一个点，
is even then it means it's it's one it's

1366
01:01:40,750 --> 01:01:42,369
比如这个。
one point on the curve say this one or

1367
01:01:42,369 --> 01:01:44,109
如果它是奇数，
if it's odd it means it's the other

1368
01:01:44,109 --> 01:01:47,410
那就表示是曲线上的另一个点。
point on the curve so I mean when we

1369
01:01:47,410 --> 01:01:50,619
当我们想要存储这个公钥时，
want to store this public key we don't

1370
01:01:50,619 --> 01:01:52,540
我们不需要存储完整的Y值，
have to store the full Y value all we

1371
01:01:52,540 --> 01:01:54,750
我们只需要知道它是偶数还是奇数。
need to know is whether it's even or odd

1372
01:01:54,750 --> 01:01:58,839
这个Y值是偶数，
so this Y value here is even so all we

1373
01:01:58,839 --> 01:02:00,609
所以我们只需要知道这个公钥是偶数，
need to know just always full public key

1374
01:02:00,609 --> 01:02:05,020
然后我们可以根据X值来推算出它是什么。


01:02:05,020 --> 01:02:09,040
这就是X值，
x value so this is the x value and then

1377
01:02:09,040 --> 01:02:15,040
然后我们可以把Y是偶数还是奇数放在前面。

01:02:15,040 --> 01:02:17,980
显然，你不会把"偶数"或者"奇数"这个词放在前面，
don't put the word even at the front or

1380
01:02:17,980 --> 01:02:20,020
而是用两个代码来表示。
odd there are two codes for that so if

1381
01:02:20,020 --> 01:02:22,540
如果它是偶数，就用02表示，
it's e if it's even but o2 like so or if

1382
01:02:22,540 --> 01:02:27,210
如果是奇数，就用03表示。
it's odd over 3 and early on in Bitcoin

1383
01:02:27,210 --> 01:02:30,099
在比特币早期，
public keys were actually stored using

1384
01:02:30,099 --> 01:02:32,140
公钥实际上是用X和Y值一起存储的，
both the x and y value and these are

1385
01:02:32,140 --> 01:02:34,510
这些被称为未压缩的密钥。
called uncompressed keys so this is a

1386
01:02:34,510 --> 01:02:36,070
这是一个压缩的密钥，
compressed key because you don't use the

1387
01:02:36,070 --> 01:02:38,160
因为我们不需要使用完整的Y值，
full y value because we don't need to

1388
01:02:38,160 --> 01:02:44,299
但是这在创始人中本聪开始的时候并不知道，

01:02:44,299 --> 01:02:47,299
所以早期的比特币公钥使用的是未压缩的格式。
lot of early on bit in any public keys

1391
01:02:47,299 --> 01:02:49,859
use the uncompressed format and if you

1392
01:02:49,859 --> 01:02:51,210
如果你想使用未压缩的格式，
want to use number cut price for Matt

1393
01:02:51,210 --> 01:02:53,220
那么它会以04开头，
that'll start with over four zero four

1394
01:02:53,220 --> 01:02:57,029
但是这个是02。
sorry but this one zero two so there we

1395
01:02:57,029 --> 01:03:00,480
所以这就是公钥，
go that is the public key just in the X

1396
01:03:00,480 --> 01:03:06,720
只需要X坐标和Y是偶数还是奇数，
x coordinate and whether the Y is even

1397
01:03:06,720 --> 01:03:08,549
编码为02或03。
or odd encoded as a zero two or zero

1398
01:03:08,549 --> 01:03:13,799
不需要把所有这些文本转换成十进制，

01:03:13,799 --> 01:03:16,950
我只是用数字来说明这一切都只是数字。

01:03:16,950 --> 01:03:21,269
但是当你开始查看私钥和公钥或者传递它们时，

01:03:21,269 --> 01:03:23,819
它们通常会被存储为十六进制格式。
they're usually stored in hexadecimal

1405
01:03:23,819 --> 01:03:27,900
所以这就是私钥，
format so there we go that's private key

1406
01:03:27,900 --> 01:03:30,509
长度为32字节，
is 32 bytes and this public key should

1407
01:03:30,509 --> 01:03:35,000
而这个公钥应该是33字节。
be future by it's also quick tip if this

1408
01:03:35,000 --> 01:03:37,829
如果这个公钥是一个较小的数字，
public key it's quite a low number and

1409
01:03:37,829 --> 01:03:41,369
当你把它转换成十六进制时，
when you convert it into hexadecimal if

1410
01:03:41,369 --> 01:03:44,339
如果它的长度不是32字节，
it's not 32 pipes in length make sure to

1411
01:03:44,339 --> 01:03:46,079
那么请确保在开始时用0来填充，
pad it out at the start with the zeros

1412
01:03:46,079 --> 01:03:53,039
以确保整个X值部分的公钥总共是32字节。

01:03:53,039 --> 01:03:57,420
just a quick tip otherwise you'll end up

1415
01:03:57,420 --> 01:04:02,210
creating an incorrect address later on

1416
01:04:03,230 --> 01:04:07,140
so okay that's the basics done private

1417
01:04:07,140 --> 01:04:10,200
key random number public key just

1418
01:04:10,200 --> 01:04:11,430
develop two key of multiplication and

1419
01:04:11,430 --> 01:04:14,069
store the Y value in a compressed format

1420
01:04:14,069 --> 01:04:15,329
we just need to know with it if it's

1421
01:04:15,329 --> 01:04:17,970
even or odd now we've got that we just

1422
01:04:17,970 --> 01:04:20,180
put that through two hash functions

1423
01:04:20,180 --> 01:04:23,609
because now you want the Hat to hash 160

1424
01:04:23,609 --> 01:04:26,220
of this to give a way to other people so

1425
01:04:26,220 --> 01:04:28,380
if we just put it through sha-256 first

1426
01:04:28,380 --> 01:04:32,369
then wipe mt 160 and that gives you this

1427
01:04:32,369 --> 01:04:33,809
digest this result

1428
01:04:33,809 --> 01:04:35,819
don't forget when you're hashing in

1429
01:04:35,819 --> 01:04:37,410
Bitcoin to configure this to binary

1430
01:04:37,410 --> 01:04:38,789
first before you put into the hash

1431
01:04:38,789 --> 01:04:41,130
function and a spirit of binary result

1432
01:04:41,130 --> 01:04:44,099
put that binary result into the next one

1433
01:04:44,099 --> 01:04:46,950
I'll spit up binary thank averted to

1434
01:04:46,950 --> 01:04:49,859
taxes a hexadecimal and this is that

1435
01:04:49,859 --> 01:04:51,190
gives you this hash one-sixth

1436
01:04:51,190 --> 01:04:56,020
here you might notice that this result

1437
01:04:56,020 --> 01:04:58,710
this digest is a bit smaller than these

1438
01:04:58,710 --> 01:05:01,710
32 byte public keys

1439
01:05:01,710 --> 01:05:05,920
that's because char 256 is 256 bits

1440
01:05:05,920 --> 01:05:10,599
produces 256 bit results which is 32

1441
01:05:10,599 --> 01:05:13,540
bytes but right the MT 160 produces

1442
01:05:13,540 --> 01:05:17,770
smaller results 160 bit digests which is

1443
01:05:17,770 --> 01:05:20,890
20 bytes so that's quite a bit smaller

1444
01:05:20,890 --> 01:05:26,349
like so fine okay

1445
01:05:26,349 --> 01:05:27,490
so this is what we give way to other

1446
01:05:27,490 --> 01:05:30,250
people this is the protected public key

1447
01:05:30,250 --> 01:05:32,530
if you will but now we want to create

1448
01:05:32,530 --> 01:05:34,540
the address which is like a prettier

1449
01:05:34,540 --> 01:05:35,710
version with some error checking

1450
01:05:35,710 --> 01:05:39,490
involved so what we do we need some base

1451
01:05:39,490 --> 01:05:43,119
58 this but before we do that we first

1452
01:05:43,119 --> 01:05:45,460
of all put a version byte at the start

1453
01:05:45,460 --> 01:05:48,520
which for most addresses is 0 0 I'll

1454
01:05:48,520 --> 01:05:50,400
explain why we do that in just a moment

1455
01:05:50,400 --> 01:05:53,050
and then like I said earlier we need a

1456
01:05:53,050 --> 01:05:55,720
checksum so we just hash all of this so

1457
01:05:55,720 --> 01:05:57,490
the public key with a version by at the

1458
01:05:57,490 --> 01:06:00,369
start hash at all here's the checksum

1459
01:06:00,369 --> 01:06:03,210
hash it twice you know like in mining

1460
01:06:03,210 --> 01:06:05,800
then we take the first four bytes last

1461
01:06:05,800 --> 01:06:07,240
to checksum that's all we need really to

1462
01:06:07,240 --> 01:06:09,640
be sure enough that this hash is

1463
01:06:09,640 --> 01:06:11,550
correctly for the error tracking and

1464
01:06:11,550 --> 01:06:14,410
then we put all that then through base

1465
01:06:14,410 --> 01:06:18,190
58 so public key well the hashed version

1466
01:06:18,190 --> 01:06:20,170
of it vision byte at the start check

1467
01:06:20,170 --> 01:06:21,640
them at the end stick it all through

1468
01:06:21,640 --> 01:06:23,920
base 58 and that would give us this

1469
01:06:23,920 --> 01:06:28,450
address the reason be append or prepend

1470
01:06:28,450 --> 01:06:29,109
sorry

1471
01:06:29,109 --> 01:06:31,270
this version byte at the start is

1472
01:06:31,270 --> 01:06:37,349
because it effects the leading character

1473
01:06:37,349 --> 01:06:40,300
of the address after weaving codes it in

1474
01:06:40,300 --> 01:06:44,730
base 58 format so for normal addresses

1475
01:06:44,730 --> 01:06:46,780
where we just want to send and receive

1476
01:06:46,780 --> 01:06:51,890
bitcoins in a typical way

1477
01:06:51,890 --> 01:06:53,840
we put zeros you at the start and that

1478
01:06:53,840 --> 01:06:55,310
gives us a one address so that means

1479
01:06:55,310 --> 01:06:56,540
that you just want to send and receive

1480
01:06:56,540 --> 01:07:00,170
bitcoins in typical way so if by

1481
01:07:00,170 --> 01:07:02,510
changing this version byte at the start

1482
01:07:02,510 --> 01:07:04,609
it changes the starting character of the

1483
01:07:04,609 --> 01:07:09,230
address so 0 0 is for typical sending or

1484
01:07:09,230 --> 01:07:11,330
receiving addresses on the on the main

1485
01:07:11,330 --> 01:07:13,880
net network but for test NAT so if

1486
01:07:13,880 --> 01:07:16,250
you're on a test net network you put 6 F

1487
01:07:16,250 --> 01:07:18,550
at the start and that will change the

1488
01:07:18,550 --> 01:07:21,500
leading character so there are quite a

1489
01:07:21,500 --> 01:07:23,390
few of these different version bytes of

1490
01:07:23,390 --> 01:07:24,940
the start to give you different

1491
01:07:24,940 --> 01:07:27,830
addresses but for most cases you're just

1492
01:07:27,830 --> 01:07:32,290
gonna use 0 0 to give you a 1 address

1493
01:07:32,380 --> 01:07:35,240
yes so I think I'll cover this a bit

1494
01:07:35,240 --> 01:07:39,740
more in the locking code or script video

1495
01:07:39,740 --> 01:07:42,430
which will be coming up after this one

1496
01:07:42,430 --> 01:07:44,990
but for most addresses just one stick

1497
01:07:44,990 --> 01:07:48,560
and zeros you at the start so there we

1498
01:07:48,560 --> 01:07:51,380
go that's how you create you can create

1499
01:07:51,380 --> 01:07:53,960
your own set of keys just through this

1500
01:07:53,960 --> 01:07:57,170
process here hopefully you all made some

1501
01:07:57,170 --> 01:08:02,480
sense or it's cleared up some issues so

1502
01:08:02,480 --> 01:08:05,740
there we go any questions about that

1503
01:08:08,010 --> 01:08:11,160
okay okay

1504
01:08:11,160 --> 01:08:12,690
just a quick question you mentioned

1505
01:08:12,690 --> 01:08:15,210
something about 32 bytes riding or some

1506
01:08:15,210 --> 01:08:22,560
yes okay okay um I probably do need to

1507
01:08:22,560 --> 01:08:25,560
mention that but when you private keys

1508
01:08:25,560 --> 01:08:26,460
and public keys

1509
01:08:26,460 --> 01:08:28,500
well this x coordinate is always 32

1510
01:08:28,500 --> 01:08:31,020
bytes and private keys or 32 bytes as

1511
01:08:31,020 --> 01:08:33,839
well and just a little tip that if you

1512
01:08:33,839 --> 01:08:36,000
when you do this lipstick you have

1513
01:08:36,000 --> 01:08:37,410
multiplication so you get a small number

1514
01:08:37,410 --> 01:08:39,299
for X and then you convert it to

1515
01:08:39,299 --> 01:08:41,370
hexadecimal then you might end up

1516
01:08:41,370 --> 01:08:44,399
getting a hexadecimal number that isn't

1517
01:08:44,399 --> 01:08:47,310
32 bytes long if that's the case just be

1518
01:08:47,310 --> 01:08:50,819
sure to pad it up and 0 to the start so

1519
01:08:50,819 --> 01:08:53,549
that the each X so the x coordinate is

1520
01:08:53,549 --> 01:08:56,520
the right length because that's

1521
01:08:56,520 --> 01:08:58,738
important because if you missed out a

1522
01:08:58,738 --> 01:09:00,270
character here that when they should

1523
01:09:00,270 --> 01:09:01,859
have been a zero there then this is

1524
01:09:01,859 --> 01:09:03,859
going to hash out to a different value

1525
01:09:03,859 --> 01:09:06,299
so you'll be sending bitcoins to the

1526
01:09:06,299 --> 01:09:08,700
wrong place so it's just I've made this

1527
01:09:08,700 --> 01:09:13,319
mistake before so I just wanted to bring

1528
01:09:13,319 --> 01:09:14,580
it up to make sure that no one else

1529
01:09:14,580 --> 01:09:18,649
makes the same mistake so there we go

1530
01:09:18,649 --> 01:09:23,270
and that's how to create your own

1531
01:09:23,270 --> 01:09:27,170
addresses and private keys and whatnot

1532
01:09:27,170 --> 01:09:35,370
so that's that part and my to know here

1533
01:09:35,370 --> 01:09:39,229
we go so I've made a little script here

1534
01:09:39,229 --> 01:09:42,479
it's written in Ruby and that will

1535
01:09:42,479 --> 01:09:45,359
create a set of keys tries to go through

1536
01:09:45,359 --> 01:09:47,160
an order it starts off by generating a

1537
01:09:47,160 --> 01:09:47,759
private key

1538
01:09:47,759 --> 01:09:50,520
just getting a secure random number the

1539
01:09:50,520 --> 01:09:52,170
maximum is this value here which is n

1540
01:09:52,170 --> 01:09:54,120
like I said earlier which is the number

1541
01:09:54,120 --> 01:09:56,100
of points on the curve so if asked to

1542
01:09:56,100 --> 01:09:59,040
big I'll just raise an error so that

1543
01:09:59,040 --> 01:10:01,790
generates a private key

1544
01:10:01,790 --> 01:10:04,110
after that he need to go from the

1545
01:10:04,110 --> 01:10:06,690
private to the public so we just use the

1546
01:10:06,690 --> 01:10:09,480
elliptic curve you do his ed up to give

1547
01:10:09,480 --> 01:10:11,639
multiplication

1548
01:10:11,639 --> 01:10:14,310
and then you that give you an x and y

1549
01:10:14,310 --> 01:10:17,690
value so in the old format it's just the

1550
01:10:17,690 --> 01:10:21,360
x and y but a new format if want to

1551
01:10:21,360 --> 01:10:22,619
compress the public key

1552
01:10:22,619 --> 01:10:25,349
you just take whether Y is even or odd

1553
01:10:25,349 --> 01:10:28,170
and then / - no - or no three at the

1554
01:10:28,170 --> 01:10:32,400
start based on that after the public key

1555
01:10:32,400 --> 01:10:33,840
you only get the hash 160 it's quite

1556
01:10:33,840 --> 01:10:36,150
simple just put it through two different

1557
01:10:36,150 --> 01:10:39,329
hashing functions so sha 256 and then

1558
01:10:39,329 --> 01:10:43,760
wipe MD 160 and then to get the address

1559
01:10:43,760 --> 01:10:47,429
you stick a prefix of the start create a

1560
01:10:47,429 --> 01:10:53,790
checksum by hashing the hash 160 and

1561
01:10:53,790 --> 01:10:55,349
then the address is just all about

1562
01:10:55,349 --> 01:10:58,710
encoded in base 58 so if you have some

1563
01:10:58,710 --> 01:11:00,659
utility functions like the base 58 and

1564
01:11:00,659 --> 01:11:04,380
stuff and there we are so here's the

1565
01:11:04,380 --> 01:11:07,530
code you just run Ruby key generator

1566
01:11:07,530 --> 01:11:09,060
I'll put this code on the website or a

1567
01:11:09,060 --> 01:11:11,070
link in the description and this will

1568
01:11:11,070 --> 01:11:14,159
give you a set of keys as you can see

1569
01:11:14,159 --> 01:11:16,139
it's quite fast so even though we did

1570
01:11:16,139 --> 01:11:18,389
all this you know crazy elliptic curve

1571
01:11:18,389 --> 01:11:21,210
multiplication when you run the code

1572
01:11:21,210 --> 01:11:24,360
it's pretty fast to give you you know

1573
01:11:24,360 --> 01:11:32,750
your psyches so just to prove to you um

1574
01:11:32,750 --> 01:11:37,619
here's an address I can send some

1575
01:11:37,619 --> 01:11:40,650
bitcoins there's a debt this address may

1576
01:11:40,650 --> 01:11:42,810
be our nest and the base description

1577
01:11:42,810 --> 01:11:54,860
sorry me not just for just to show up

1578
01:11:54,860 --> 01:11:59,300
send a low fee send

1579
01:12:01,230 --> 01:12:04,630
okay so the paper has been sent so copy

1580
01:12:04,630 --> 01:12:13,870
that I'm sorry maybe our browser send

1581
01:12:13,870 --> 01:12:16,620
the transaction look at the transaction

1582
01:12:16,620 --> 01:12:18,130
right there it is

1583
01:12:18,130 --> 01:12:23,199
so Wendy 9 that's the address I sent it

1584
01:12:23,199 --> 01:12:28,980
to so like I said earlier remember how

1585
01:12:28,980 --> 01:12:31,480
the electrum Wallace took care of my

1586
01:12:31,480 --> 01:12:33,880
change form for me and it sent it to a

1587
01:12:33,880 --> 01:12:35,889
different address like here so the

1588
01:12:35,889 --> 01:12:42,699
public here is protected okay a few

1589
01:12:42,699 --> 01:12:47,290
quick tips just before I go and this is

1590
01:12:47,290 --> 01:12:51,460
a very good graphical address generator

1591
01:12:51,460 --> 01:12:53,590
that shows you all the steps you need to

1592
01:12:53,590 --> 01:12:56,380
do to generate your own addresses if you

1593
01:12:56,380 --> 01:13:00,730
go on the Royal Fork blog Google that

1594
01:13:00,730 --> 01:13:03,219
cool and gone to the graphical address

1595
01:13:03,219 --> 01:13:05,320
general address generator it's very good

1596
01:13:05,320 --> 01:13:07,090
so if you're programming and you want to

1597
01:13:07,090 --> 01:13:08,230
create your own set of keys and

1598
01:13:08,230 --> 01:13:11,020
addresses this is very very helpful

1599
01:13:11,020 --> 01:13:14,100
it's helped me a lot it's very good

1600
01:13:14,100 --> 01:13:17,980
secondly and preset about you've got all

1601
01:13:17,980 --> 01:13:20,679
those different caves and you know the

1602
01:13:20,679 --> 01:13:24,820
SEC p25 6k one well they're all outlined

1603
01:13:24,820 --> 01:13:29,830
on the SEC website so here's a I put a

1604
01:13:29,830 --> 01:13:30,610
link in the description

1605
01:13:30,610 --> 01:13:38,800
here's the you are so here's the

1606
01:13:38,800 --> 01:13:40,719
parameters for that cave so you have

1607
01:13:40,719 --> 01:13:42,850
lots different caves but this is just

1608
01:13:42,850 --> 01:13:46,650
the one that Bitcoin uses that one so

1609
01:13:46,650 --> 01:13:50,130
yep there we go

1610
01:13:51,409 --> 01:13:56,809
one last thing don't forget for these

1611
01:13:56,809 --> 01:13:57,709
private keys

1612
01:13:57,709 --> 01:13:59,209
you also have lost like an address

1613
01:13:59,209 --> 01:14:00,530
version like a pretty version the

1614
01:14:00,530 --> 01:14:02,090
private key which is called wallet

1615
01:14:02,090 --> 01:14:03,829
import format I haven't covered it here

1616
01:14:03,829 --> 01:14:06,649
but it's very similar to this process

1617
01:14:06,649 --> 01:14:07,969
for getting a pretty version at the

1618
01:14:07,969 --> 01:14:10,699
public key so if you ever see wallet

1619
01:14:10,699 --> 01:14:12,499
import format it's just the pretty

1620
01:14:12,499 --> 01:14:18,729
version of the private key any questions

1621
01:14:21,789 --> 01:14:23,780
I'm glad it all made sense

1622
01:14:23,780 --> 01:14:28,159
I tried to make it as a flowing as

1623
01:14:28,159 --> 01:14:29,389
possible because it's quite a lot I

1624
01:14:29,389 --> 01:14:30,679
thought with the elliptic curves and

1625
01:14:30,679 --> 01:14:32,929
stuff to include that I don't cover how

1626
01:14:32,929 --> 01:14:35,510
that all works I just wanted to cover

1627
01:14:35,510 --> 01:14:41,530
the basics of keys what are you yeah and

1628
01:14:42,159 --> 01:14:45,050
yeah yeah no I felt like that I felt

1629
01:14:45,050 --> 01:14:46,219
that as well when I was doing the video

1630
01:14:46,219 --> 01:14:47,479
I was like oh god this is quite a lot of

1631
01:14:47,479 --> 01:14:49,729
information it's hard to you know do

1632
01:14:49,729 --> 01:14:51,309
it's hard to take it all in one sitting

1633
01:14:51,309 --> 01:15:01,669
but maybe if you want to learn yeah yeah

1634
01:15:01,669 --> 01:15:03,619
it's just numbers I think if you just

1635
01:15:03,619 --> 01:15:05,329
went through this process of creating

1636
01:15:05,329 --> 01:15:06,859
your own set of keys I think you'd learn

1637
01:15:06,859 --> 01:15:08,419
everything as you went along but

1638
01:15:08,419 --> 01:15:11,749
hopefully this gives you a primer to get

1639
01:15:11,749 --> 01:15:15,789
going I suppose and create them

