1
00:00:00,030 --> 00:00:06,600
这个演讲将解释你需要知道的关于比特币密钥和地址的所有信息。

00:00:06,600 --> 00:00:11,400
你可能听过像私钥、公钥和地址这样的东西，

00:00:11,400 --> 00:00:16,320
我将在这个演讲中解释它们的来源和工作原理。

00:00:16,320 --> 00:00:21,800
我快速概述这个演示中会包含什么内容。

00:00:21,800 --> 00:00:24,630
我将从基础知识开始，

00:00:24,630 --> 00:00:27,029
解释密钥的来源和工作方式，

00:00:27,029 --> 00:00:29,400
并对它们的工作方式进行一个基本的概述。

00:00:29,400 --> 00:00:32,070
我将讲解每个密钥是如何生成的，

00:00:32,070 --> 00:00:35,130
你有一个私钥，

00:00:35,130 --> 00:00:37,320
然后从那里生成一个公钥，

00:00:37,320 --> 00:00:41,250
这两个是你在比特币中使用的主要密钥，

00:00:41,250 --> 00:00:47,280 
类似于密码和账号。

00:00:47,280 --> 00:00:49,820
你有所谓的数字签名，

00:00:49,820 --> 00:00:54,149
这些被用来证明你拥有一个公钥，

00:00:54,149 --> 00:00:57,000
就像用于签署交易一样。

00:00:57,000 --> 00:00:59,160
我将解释这些是如何工作的。

00:00:59,160 --> 00:01:02,460
我会讲解地址是如何工作的，

00:01:02,460 --> 00:01:09,750
地址基本上就像公钥的一个更漂亮或对用户更友好的版本。

00:01:09,750 --> 00:01:12,030
我将解释它们是如何工作的，

00:01:12,030 --> 00:01:14,880
以及它们是如何连接在一起的。

00:01:14,880 --> 00:01:17,070
在最后，我将通过一些代码和例子，

00:01:17,070 --> 00:01:24,990
来展示你如何生成自己的私钥、公钥和地址。

00:01:24,990 --> 00:01:27,479
这个演讲主要是讲解，

00:01:27,479 --> 00:01:30,180
不涉及太多的代码，

00:01:30,180 --> 00:01:36,450 
最后可能会有一些关于数字签名的详细解释，

00:01:36,450 --> 00:01:40,290
但只要你对它的工作方式有一个大概了解就可以了。

00:01:40,290 --> 00:01:44,030
我将开始，

00:01:44,030 --> 00:01:48,390
这也是为什么比特币和其他货币被称为加密货币，

00:01:48,390 --> 00:01:50,520
因为这个私钥和公钥的被称为加密，

00:01:50,520 --> 00:01:54,270
使用了密码学，

00:01:54,270 --> 00:01:56,130
所以我们称他们为加密货币，

00:01:56,130 --> 00:02:05,070
这是交易系统或比特币所有权的基础。

它们连接在一起并共享一个名为区块链的文件

00:02:05,070 --> 00:02:09,060
快进到我们上次停止的地方，

00:02:09,060 --> 00:02:12,000
正如你从我上次的演讲中看到的那样，

00:02:12,000 --> 00:02:14,730
这就是比特币网络，

00:02:14,730 --> 00:02:16,500
比特币网络就是一群计算机。

00:02:16,500 --> 00:02:18,830
互相连接在一起，

00:02:18,830 --> 00:02:21,420
并共享一个名为区块链的文件

00:02:21,420 --> 00:02:24,420
当你想进行比特币交易时，

00:02:24,420 --> 00:02:27,510
你想向某人发送一些比特币，

00:02:27,510 --> 00:02:34,170
你只需要一行描述移动的数据即可进行这样的交易，

00:02:34,170 --> 00:02:36,480
比特币从这个人到那个人。

00:02:36,480 --> 00:02:41,010
当你希望将这个交易添加到区块链中时，

00:02:41,010 --> 00:02:44,540
你会将交易插入到网络上的一个节点中，

00:02:44,540 --> 00:02:47,069
他们会在他们的内存池中快速存储这个交易。

00:02:47,069 --> 00:02:51,450
然后他们会将交易传递给他们所连接的节点，

00:02:51,450 --> 00:02:54,390
如此反复，

00:02:54,390 --> 00:02:59,640
直到交易在网络上每个节点的内存池中。

00:02:59,640 --> 00:03:07,620
之后，所有这些节点都会尝试竞争将他们内存池中的交易添加到区块链上。

00:03:07,620 --> 00:03:09,989
这个过程被称为挖矿，

00:03:09,989 --> 00:03:12,660
让我们假设这个人或者这个矿工，

00:03:12,660 --> 00:03:13,950
他能够将内存池中的交易添加到区块链上。

00:03:13,950 --> 00:03:19,019
所以一旦有一个交易块被添加进去，

00:03:19,019 --> 00:03:20,940
他们会将该区块传递给连接的节点，

00:03:20,940 --> 00:03:23,100
然后将其添加到他们的区块链中，

00:03:23,100 --> 00:03:24,870
如此反复，

00:03:24,870 --> 00:03:31,980
直到每个人的区块链副本都更新了最新的交易区块。

00:03:31,980 --> 00:03:33,329
然后这个人可以查看区块链，

00:03:33,329 --> 00:03:40,260
看到所有权已经从这个人转移到了那个人。

00:03:40,260 --> 00:03:43,069
在上一次的演讲中，

00:03:43,069 --> 00:03:45,299
我解释了这些交易在内部看起来是什么样子的。

00:03:45,299 --> 00:03:47,910
你可以把交易想象成这样：

00:03:47,910 --> 00:03:54,750
区块链充满了所有的交易数据，

00:03:54,750 --> 00:03:56,370
但如果你将其拆开看，

00:03:56,370 --> 00:03:58,950
就像看到很多不同批次，

00:03:58,950 --> 00:04:01,470
不同大小的比特币。

00:04:01,470 --> 00:04:03,690
当你进行交易时，

00:04:03,690 --> 00:04:06,000
你需要进入到区块链中，

00:04:06,000 --> 00:04:08,700
选择一个特定的比特币批次，

00:04:08,700 --> 00:04:13,829
比如说这个窗口是一个10的批次，

00:04:13,829 --> 00:04:15,569
然后你会从那里取出那批比特币，

00:04:15,569 --> 00:04:17,608
创建一个新的批次。

00:04:17,608 --> 00:04:25,960
发送一批新的比特币就像从旧的批次中创建一个新的批次。

00:04:25,960 --> 00:04:29,830
然后你会将那批比特币发送到网络中，

00:04:29,830 --> 00:04:31,570
这个交易大约需要两个比特币，

00:04:31,570 --> 00:04:33,220
然后创建一个新的进入网络，

00:04:33,220 --> 00:04:35,560
然后这个新的批次会进入到一个内存池，

00:04:35,560 --> 00:04:37,810
然后进入到区块链中。

00:04:37,810 --> 00:04:39,340
然后当你查看区块链时，

00:04:39,340 --> 00:04:41,410
这个新的批次会出现在这个新的区块中，

00:04:41,410 --> 00:04:46,630
而我们用过的整个批次将会被灰掉，

00:04:46,630 --> 00:04:50,250
因为它已经被消费掉了。

00:04:50,440 --> 00:04:51,940
我一直在称它们为批次，

00:04:51,940 --> 00:04:54,510
但实际上它们被称为输出，

00:04:54,510 --> 00:04:56,320
当你在交易中使用一个输出时，

00:04:56,320 --> 00:04:58,060
它被称为输入。

00:04:58,060 --> 00:05:00,400
所以你可以把区块链想象为充满了输出，

00:05:00,400 --> 00:05:03,070
它们只是被选择出来，

00:05:03,070 --> 00:05:09,010
然后从它们中创建出新的输出。

00:05:09,010 --> 00:05:12,580
这一切都很好，

00:05:12,580 --> 00:05:16,630
但是你如何拥有这些比特币批次呢？

00:05:16,630 --> 00:05:18,370
每一批比特币都有一个锁，

00:05:18,370 --> 00:05:23,920
每个想要使用比特币的人都有自己的一套密钥，

00:05:23,920 --> 00:05:26,140
你有一个私钥，就像你的密码，

00:05:26,140 --> 00:05:28,420
和你的公钥，就像你的账户号码。

00:05:28,420 --> 00:05:32,050
所以，当你想要进行交易，

00:05:32,050 --> 00:05:35,200
如果这批比特币属于你，

00:05:35,200 --> 00:05:41,080
那么你就可以使用你的私钥来解锁它们，

00:05:41,080 --> 00:05:42,910
然后从那里你可以创建一个新的批次。

00:05:42,910 --> 00:05:46,330
如果你想把比特币发送给这个人，

00:05:46,330 --> 00:05:48,580
他们会给你他们的公钥，

00:05:48,580 --> 00:05:52,000
使用这个公钥，

00:05:52,000 --> 00:05:56,050
你可以在这个输出，这批比特币上创建一个锁，

00:05:56,050 --> 00:05:58,120
这批比特币被锁定到这个人的公钥，

00:05:58,120 --> 00:05:59,770
因为他们把它给了我们。

00:05:59,770 --> 00:06:05,470
如果他们想要把这批10个比特币的比特币发送给别人，

00:06:05,470 --> 00:06:10,630
他们就可以使用他们的私钥来解锁它们，

00:06:10,630 --> 00:06:14,470
然后发送，所以这就是一个典型的交易。

00:06:14,470 --> 00:06:20,890
通过使用这些密钥——私钥和公钥，

00:06:20,890 --> 00:06:25,130
这就相当于拥有一个账号和密码。

00:06:25,130 --> 00:06:27,470
我再次强调，

00:06:27,470 --> 00:06:29,180
一旦你构建了这个交易，

00:06:29,180 --> 00:06:30,680
你就不再拥有一批比特币的所有权，

00:06:30,680 --> 00:06:33,230
而是创建了一批新的比特币，

00:06:33,230 --> 00:06:34,940
锁定给另一个人。

00:06:34,940 --> 00:06:36,950
然后你会将这个交易发送到网络中，

00:06:36,950 --> 00:06:41,230
最终这个交易会被记录到区块链上，

00:06:41,230 --> 00:06:44,150
比特币的批次将会更新。

00:06:44,150 --> 00:06:46,460
这个批次已经被花费掉了，

00:06:46,460 --> 00:06:48,200
它被灰色标记，不能再次被花费，

00:06:48,200 --> 00:06:50,210
新的批次会出现在新的区块中，

00:06:50,210 --> 00:06:54,100
属于另一个人。

00:06:55,490 --> 00:06:59,300
如果你想使用比特币，

00:06:59,300 --> 00:07:02,720
你只需要拥有自己的一套密钥。

00:07:02,720 --> 00:07:07,100
如果你只是想接收别人的比特币，

00:07:07,100 --> 00:07:11,060
你就需要创建并拥有自己的一套密钥才能使用比特币。

00:07:11,060 --> 00:07:13,850
那么，这些密钥是从哪里来的呢？

00:07:13,850 --> 00:07:15,890
我可以告诉你它们不是从哪里来的。

00:07:15,890 --> 00:07:18,170
没有人可以控制比特币，

00:07:18,170 --> 00:07:24,440
有一本书或一台电脑充满了密钥，

00:07:24,440 --> 00:07:26,360
你可以要求他给你一个私钥和一个公钥。

00:07:26,360 --> 00:07:31,430
没有人你需要问他给你一个公钥。

00:07:31,430 --> 00:07:33,650
这可能是银行的情况，如果你去银行，

00:07:33,650 --> 00:07:37,060
你必须要求某人给你自己的账号和密码，

00:07:37,060 --> 00:07:40,490
以便使用他们的服务发送和接收资金。

00:07:40,490 --> 00:07:42,890
但在比特币中，

00:07:42,890 --> 00:07:45,920
我们没有中央控制点，

00:07:45,920 --> 00:07:48,950
因为比特币是去中心化的，

00:07:48,950 --> 00:07:52,790
没有一个人可以控制谁可以使用它。

00:07:52,790 --> 00:07:55,340
所以，这不是比特币的工作方式。

00:07:55,340 --> 00:07:57,650
那么，如果没有人控制密钥或账号，

00:07:57,650 --> 00:07:59,750
你可以要求他们给你，

00:07:59,750 --> 00:08:02,780
那么它们是从哪里来的呢？

00:08:02,780 --> 00:08:07,910
答案是，我们自己生成私钥和公钥。

00:08:07,910 --> 00:08:10,040
我们不需要问其他人，

00:08:10,040 --> 00:08:12,350
或者我们需要从哪里获取这些密钥，

00:08:12,350 --> 00:08:13,670
我们实际上自己创建它们。

00:08:13,670 --> 00:08:18,200
我们创建，我们就像我们是任何人一样，

00:08:18,200 --> 00:08:20,090
基本上任何人都可以使用比特币，

00:08:20,090 --> 00:08:21,530
因为我们创建我们自己的账号和密码。

00:08:21,530 --> 00:08:27,170
我希望这个介绍能让你们都理解，

00:08:27,170 --> 00:08:35,169
现在我将进入创建、生成和使用这些密钥的基础知识。

00:08:35,169 --> 00:08:39,279
these keys so how do you generate your

206
00:08:39,279 --> 00:08:43,208
own set of keys to be able to send

207
00:08:43,208 --> 00:08:46,180
receive and send bitcoins well first of

208
00:08:46,180 --> 00:08:49,990
all you start with a private key and the

209
00:08:49,990 --> 00:08:52,630
simplest way or well the only way to

210
00:08:52,630 --> 00:08:54,459
generate your own private key to start

211
00:08:54,459 --> 00:08:56,079
out with it's just to generate a random

212
00:08:56,079 --> 00:09:00,490
number so like so you'll just generate a

213
00:09:00,490 --> 00:09:02,170
random number this is obviously a very

214
00:09:02,170 --> 00:09:04,660
small number bitcoin private keys are

215
00:09:04,660 --> 00:09:06,360
much bigger numbers but this is just

216
00:09:06,360 --> 00:09:11,260
just to show you and then from there you

217
00:09:11,260 --> 00:09:14,199
need your public key so if a private key

218
00:09:14,199 --> 00:09:17,199
is your password the public key is like

219
00:09:17,199 --> 00:09:19,120
your account number but obviously

220
00:09:19,120 --> 00:09:21,279
because there's no one given out these

221
00:09:21,279 --> 00:09:23,649
sets of keys when we generate our public

222
00:09:23,649 --> 00:09:25,899
key we want to have a connection between

223
00:09:25,899 --> 00:09:29,170
our private key and our public key so

224
00:09:29,170 --> 00:09:33,190
that when we use them well so that's

225
00:09:33,190 --> 00:09:34,630
what we can use our private key to

226
00:09:34,630 --> 00:09:37,510
unlock bitcoins because they're

227
00:09:37,510 --> 00:09:41,470
connected so how would you create a

228
00:09:41,470 --> 00:09:44,140
connection between a public key and a

229
00:09:44,140 --> 00:09:46,089
private key well what you do is you just

230
00:09:46,089 --> 00:09:51,130
used use some mathematics to derive your

231
00:09:51,130 --> 00:09:54,519
public key from your private key so you

232
00:09:54,519 --> 00:09:57,160
basically take your private key put it

233
00:09:57,160 --> 00:09:58,740
through some mathematical functions and

234
00:09:58,740 --> 00:10:01,510
then that will give you a public key and

235
00:10:01,510 --> 00:10:04,660
so this public key is connected to your

236
00:10:04,660 --> 00:10:07,120
private key through mathematics that's

237
00:10:07,120 --> 00:10:11,350
where the connection is so again when

238
00:10:11,350 --> 00:10:13,420
you generates a set of keys to be used

239
00:10:13,420 --> 00:10:15,519
in Bitcoin you start your private key

240
00:10:15,519 --> 00:10:17,560
it's just a random number and then from

241
00:10:17,560 --> 00:10:19,420
that you create your public key or your

242
00:10:19,420 --> 00:10:21,100
account number which is just a

243
00:10:21,100 --> 00:10:23,860
mathematically connected number that's

244
00:10:23,860 --> 00:10:25,350
connected to your private key and that

245
00:10:25,350 --> 00:10:28,890
is how you generate your own set of keys

246
00:10:28,890 --> 00:10:32,199
so that you can receive bitcoins from

247
00:10:32,199 --> 00:10:34,089
other people and then send them on to

248
00:10:34,089 --> 00:10:36,110
other people also

249
00:10:36,110 --> 00:10:38,000
so anyone can do this anyone can

250
00:10:38,000 --> 00:10:40,160
generate their own set of keys to be

251
00:10:40,160 --> 00:10:44,600
used in Bitcoin so that's the basics

252
00:10:44,600 --> 00:10:46,940
done now I'm going to start with this

253
00:10:46,940 --> 00:10:48,890
private key because generating your own

254
00:10:48,890 --> 00:10:51,920
set of keys it all starts with the

255
00:10:51,920 --> 00:10:57,080
private key so move this across there we

256
00:10:57,080 --> 00:11:00,800
go like I said your private key is just

257
00:11:00,800 --> 00:11:03,260
generating a random number and this

258
00:11:03,260 --> 00:11:06,160
random number can be between anywhere

259
00:11:06,160 --> 00:11:10,430
from 1 to this number now this is a very

260
00:11:10,430 --> 00:11:14,450
very large number but as long as you

261
00:11:14,450 --> 00:11:16,190
generate a number between 1 and this

262
00:11:16,190 --> 00:11:18,890
value it's a valid private key or you've

263
00:11:18,890 --> 00:11:20,900
valid starting points your valid

264
00:11:20,900 --> 00:11:24,770
password to use Bitcoin this is often

265
00:11:24,770 --> 00:11:29,000
referred to as a 256 big 256 bit number

266
00:11:29,000 --> 00:11:32,240
and this just describes the size of it

267
00:11:32,240 --> 00:11:35,090
how big the number is and that comes

268
00:11:35,090 --> 00:11:39,070
from basically computers they store data

269
00:11:39,070 --> 00:11:42,170
you know you have kilobytes and bytes

270
00:11:42,170 --> 00:11:44,660
and megabytes while a bit is the

271
00:11:44,660 --> 00:11:46,460
smallest you know unit of data that a

272
00:11:46,460 --> 00:11:49,280
computer can hold and all that is is a 0

273
00:11:49,280 --> 00:11:54,140
or 1 and so all the data on your

274
00:11:54,140 --> 00:11:56,570
computer is ultimately stored in a

275
00:11:56,570 --> 00:12:00,920
sequence of zeros and ones so same thing

276
00:12:00,920 --> 00:12:02,600
for numbers when you want to store

277
00:12:02,600 --> 00:12:04,430
numbers on a computer they are also

278
00:12:04,430 --> 00:12:09,220
stored in zeros on one zeros and ones so

279
00:12:09,220 --> 00:12:12,290
if you want to store numbers start out

280
00:12:12,290 --> 00:12:14,600
when starting out with 0 you can store

281
00:12:14,600 --> 00:12:15,260
that quite easily

282
00:12:15,260 --> 00:12:18,770
in bits by using the number 0 the number

283
00:12:18,770 --> 00:12:21,140
1 similar thing you can just use the bit

284
00:12:21,140 --> 00:12:24,020
1 but then for the number 2 you've run

285
00:12:24,020 --> 00:12:27,410
out of characters that you can store

286
00:12:27,410 --> 00:12:29,870
this data in so you just add another bit

287
00:12:29,870 --> 00:12:33,170
in so in binary or in a sequence of bits

288
00:12:33,170 --> 00:12:35,330
the number 2 is stored as a 1 and then a

289
00:12:35,330 --> 00:12:39,530
0 and then again 3 1 1 but then you've

290
00:12:39,530 --> 00:12:41,750
run out of options again so you need

291
00:12:41,750 --> 00:12:43,070
another bit to store a bigger number

292
00:12:43,070 --> 00:12:46,370
like so so this goes on and on so the

293
00:12:46,370 --> 00:12:47,360
bigger the number

294
00:12:47,360 --> 00:12:50,329
becomes the more bits you need to be

295
00:12:50,329 --> 00:12:52,670
able to represent it or store it on a

296
00:12:52,670 --> 00:12:55,870
computer so who carried on doing this

297
00:12:55,870 --> 00:13:02,209
and you had 256 bits lined up together

298
00:13:02,209 --> 00:13:05,180
and you put ones in all of them then

299
00:13:05,180 --> 00:13:09,470
that would be able to store this number

300
00:13:09,470 --> 00:13:12,920
here so that's why it's called a 256 bit

301
00:13:12,920 --> 00:13:13,519
number

302
00:13:13,519 --> 00:13:16,519
it's basically what a computer the

303
00:13:16,519 --> 00:13:18,860
largest number a computer can hold in

304
00:13:18,860 --> 00:13:23,600
256 bits worth of data and that's also

305
00:13:23,600 --> 00:13:26,470
the same as saying 2 to the power of 256

306
00:13:26,470 --> 00:13:28,970
because we have two options for each

307
00:13:28,970 --> 00:13:32,390
each block here and sock might be either

308
00:13:32,390 --> 00:13:36,490
be a 0 or 1 and if you do that 256 times

309
00:13:36,490 --> 00:13:40,220
so ^ 2056 that gives you this number

310
00:13:40,220 --> 00:13:45,310
here 2 ^ 256 which is a very big number

311
00:13:45,310 --> 00:13:48,620
so then the question now is what if

312
00:13:48,620 --> 00:13:50,209
someone generates the same private key

313
00:13:50,209 --> 00:13:52,459
as me this obviously seems like a bit of

314
00:13:52,459 --> 00:13:54,800
a crude mechanism for generating you own

315
00:13:54,800 --> 00:13:58,100
private password to be able to use

316
00:13:58,100 --> 00:14:02,180
Bitcoin well the answer is that this

317
00:14:02,180 --> 00:14:05,720
number is so large that nobody is going

318
00:14:05,720 --> 00:14:09,310
to generate the same private key as you

319
00:14:10,089 --> 00:14:13,459
to illustrate that let's say this is the

320
00:14:13,459 --> 00:14:17,560
known visible universe this number here

321
00:14:17,560 --> 00:14:21,320
this is the number of atoms in this

322
00:14:21,320 --> 00:14:24,140
known visible universe so as you can see

323
00:14:24,140 --> 00:14:27,260
which is 10 to the power of 78 as you

324
00:14:27,260 --> 00:14:30,709
can see this 256 bit number here is not

325
00:14:30,709 --> 00:14:33,829
too far off from the number of atoms in

326
00:14:33,829 --> 00:14:37,670
universe so you just have to trust me

327
00:14:37,670 --> 00:14:40,730
when I say that because this is number

328
00:14:40,730 --> 00:14:42,370
is so large I mean it doesn't

329
00:14:42,370 --> 00:14:44,360
particularly look large here because I

330
00:14:44,360 --> 00:14:47,060
can display it on a screen but it is

331
00:14:47,060 --> 00:14:49,220
unbelievably large and the fact that

332
00:14:49,220 --> 00:14:52,699
it's so large means that 2 different

333
00:14:52,699 --> 00:14:53,990
people are not going to generate the

334
00:14:53,990 --> 00:14:55,630
same number

335
00:14:55,630 --> 00:14:59,029
and that's just how big it is and that's

336
00:14:59,029 --> 00:15:01,310
so secure it is and this has been

337
00:15:01,310 --> 00:15:04,279
working fine in Bitcoin no problems

338
00:15:04,279 --> 00:15:06,680
there's been no known case of anyone

339
00:15:06,680 --> 00:15:09,170
generating the same private key or not I

340
00:15:09,170 --> 00:15:12,259
know of anyway and if there was it would

341
00:15:12,259 --> 00:15:14,810
be big news but like I said it's a very

342
00:15:14,810 --> 00:15:17,690
big number so private key you just

343
00:15:17,690 --> 00:15:21,440
generate a number up to between one and

344
00:15:21,440 --> 00:15:24,290
this value here just generated and I'll

345
00:15:24,290 --> 00:15:29,300
give you your private key something

346
00:15:29,300 --> 00:15:38,420
sensitive huh okay right so private key

347
00:15:38,420 --> 00:15:39,620
just a random number we've just

348
00:15:39,620 --> 00:15:42,680
generated from that we can now get our

349
00:15:42,680 --> 00:15:47,930
public key so like I said without public

350
00:15:47,930 --> 00:15:49,610
key it needs to be connected to our

351
00:15:49,610 --> 00:15:52,790
private key somehow because we need our

352
00:15:52,790 --> 00:15:54,620
account number to be connected to our

353
00:15:54,620 --> 00:15:58,730
password so the way we do that is we use

354
00:15:58,730 --> 00:16:02,120
some mathematics and there's a

355
00:16:02,120 --> 00:16:03,769
particular type of mathematics we use

356
00:16:03,769 --> 00:16:07,550
though and that mathematics uses this

357
00:16:07,550 --> 00:16:09,889
thing here which is called an elliptic

358
00:16:09,889 --> 00:16:13,190
curve you have lots of different

359
00:16:13,190 --> 00:16:15,889
elliptic curves this is just in this

360
00:16:15,889 --> 00:16:17,690
illustration of one but the what

361
00:16:17,690 --> 00:16:19,639
particular one used in Bitcoin is called

362
00:16:19,639 --> 00:16:23,870
sec p 2 5 6 k 1 so like I said there are

363
00:16:23,870 --> 00:16:25,850
lots of different elliptic curves but

364
00:16:25,850 --> 00:16:27,350
this is the particular one the

365
00:16:27,350 --> 00:16:31,880
particular shape that Bitcoin users and

366
00:16:31,880 --> 00:16:34,250
so to get your public key from this

367
00:16:34,250 --> 00:16:36,470
private key you often do you have to do

368
00:16:36,470 --> 00:16:37,579
what's called elliptic curve

369
00:16:37,579 --> 00:16:42,230
multiplication the reason well but why

370
00:16:42,230 --> 00:16:44,240
we we are using this limit elliptic

371
00:16:44,240 --> 00:16:46,699
curve for them apparent later on so just

372
00:16:46,699 --> 00:16:48,620
bear with me now while I show you how

373
00:16:48,620 --> 00:16:51,250
this elliptic curve multiplication works

374
00:16:51,250 --> 00:16:55,730
so with the SEC P 2 5 6 K 1 it comes

375
00:16:55,730 --> 00:16:58,399
with a starting point and to do

376
00:16:58,399 --> 00:17:00,110
multiplication

377
00:17:00,110 --> 00:17:01,750
this is going to be a simplified

378
00:17:01,750 --> 00:17:05,329
explanation but it's basically this is

379
00:17:05,329 --> 00:17:06,829
called G blow away the starting point or

380
00:17:06,829 --> 00:17:08,869
the generated point but for

381
00:17:08,869 --> 00:17:10,839
multiplication

382
00:17:10,839 --> 00:17:15,199
it's basically draw a tangent on the

383
00:17:15,199 --> 00:17:20,359
cave starting by a tangent at the point

384
00:17:20,359 --> 00:17:22,250
on the curve so we'll start at this

385
00:17:22,250 --> 00:17:25,130
generate generate a point here and one

386
00:17:25,130 --> 00:17:26,839
of the properties of this elliptic curve

387
00:17:26,839 --> 00:17:29,510
is that if you draw a tangent on it then

388
00:17:29,510 --> 00:17:31,490
it's always going to intersect the curve

389
00:17:31,490 --> 00:17:34,520
at one other point and that's just one

390
00:17:34,520 --> 00:17:35,930
of the properties of this particular

391
00:17:35,930 --> 00:17:39,070
type of curve and that's why we use it

392
00:17:39,070 --> 00:17:42,860
so have you done that when it intersects

393
00:17:42,860 --> 00:17:45,740
this point you take that point called

394
00:17:45,740 --> 00:17:47,840
the intersect and then you just invert

395
00:17:47,840 --> 00:17:51,530
it and take the opposite point on the

396
00:17:51,530 --> 00:17:53,390
curve from this point here from the

397
00:17:53,390 --> 00:17:55,810
intersect I'm going to take this point

398
00:17:55,810 --> 00:17:59,150
this point here is like doing one round

399
00:17:59,150 --> 00:18:01,880
of multiplication so if this was one G

400
00:18:01,880 --> 00:18:06,560
this would be 2 G and then again if you

401
00:18:06,560 --> 00:18:07,820
want do another round of multiplication

402
00:18:07,820 --> 00:18:09,980
draw another tangent and it will

403
00:18:09,980 --> 00:18:12,260
intersect another point in the curve and

404
00:18:12,260 --> 00:18:13,910
that will give you well then you take

405
00:18:13,910 --> 00:18:16,520
the inverse of that and that will give

406
00:18:16,520 --> 00:18:18,500
you you know another point on the curve

407
00:18:18,500 --> 00:18:20,350
and is a second round of multiplication

408
00:18:20,350 --> 00:18:22,730
this is a bit simplified but this is

409
00:18:22,730 --> 00:18:26,120
basically how it works so again when you

410
00:18:26,120 --> 00:18:27,290
want to multiply again you just take

411
00:18:27,290 --> 00:18:31,580
another tangent again at the point in

412
00:18:31,580 --> 00:18:34,070
the curve and so on and so on so

413
00:18:34,070 --> 00:18:35,360
basically when you do an elliptic curve

414
00:18:35,360 --> 00:18:36,679
multiplication you're drawn all these

415
00:18:36,679 --> 00:18:38,570
tangents and taking the inverse points

416
00:18:38,570 --> 00:18:40,250
but ultimately ultimately what's

417
00:18:40,250 --> 00:18:41,540
happening you are bouncing around this

418
00:18:41,540 --> 00:18:48,770
curve in a particular way like this so

419
00:18:48,770 --> 00:18:50,360
what you do then you're bouncing on the

420
00:18:50,360 --> 00:18:52,550
curve this many times

421
00:18:52,550 --> 00:18:54,920
so you're bouncing on the key of private

422
00:18:54,920 --> 00:18:58,070
key times so obviously I don't end there

423
00:18:58,070 --> 00:19:00,890
but you'll keep doing this until you've

424
00:19:00,890 --> 00:19:02,160
done it

425
00:19:02,160 --> 00:19:05,309
private key times when she's done that

426
00:19:05,309 --> 00:19:07,960
maybe I when she done last you'll end up

427
00:19:07,960 --> 00:19:10,630
with a point on the curve and this point

428
00:19:10,630 --> 00:19:14,200
on the curve is the public key so there

429
00:19:14,200 --> 00:19:16,120
are many many many points on this curve

430
00:19:16,120 --> 00:19:18,520
basically about as many points in this

431
00:19:18,520 --> 00:19:23,620
cave as there are private keys so once

432
00:19:23,620 --> 00:19:25,480
you've got that public so basically like

433
00:19:25,480 --> 00:19:28,390
I said this final resting point on the

434
00:19:28,390 --> 00:19:30,040
curve after bouncing around it this many

435
00:19:30,040 --> 00:19:32,500
times gives you a public key and to be

436
00:19:32,500 --> 00:19:34,780
precise your public key is just the X&Y

437
00:19:34,780 --> 00:19:37,720
coordinates of this point so there we

438
00:19:37,720 --> 00:19:40,120
are nasty X and as to why put them

439
00:19:40,120 --> 00:19:42,010
together like this and that is your

440
00:19:42,010 --> 00:19:46,960
public key one of the reasons why we use

441
00:19:46,960 --> 00:19:49,990
this elliptic curve is because one of

442
00:19:49,990 --> 00:19:52,360
the properties of it is it this

443
00:19:52,360 --> 00:19:54,070
multiplication is what's called a

444
00:19:54,070 --> 00:19:56,230
trapdoor function which means that you

445
00:19:56,230 --> 00:19:59,850
can easily do private key multiplication

446
00:19:59,850 --> 00:20:02,140
well to multiplication using private key

447
00:20:02,140 --> 00:20:03,870
and I give you can bounce on the curve

448
00:20:03,870 --> 00:20:05,830
but going backwards

449
00:20:05,830 --> 00:20:08,740
taking this point on the curve and

450
00:20:08,740 --> 00:20:10,780
figuring out what the private key was

451
00:20:10,780 --> 00:20:16,510
from that is very difficult while it

452
00:20:16,510 --> 00:20:18,460
hasn't been solved yet no one knows how

453
00:20:18,460 --> 00:20:21,520
to take a public key or a point on the

454
00:20:21,520 --> 00:20:25,510
curve and figure out what the private

455
00:20:25,510 --> 00:20:27,760
key was the number we multiplied the

456
00:20:27,760 --> 00:20:33,010
generator point by it's a bit hard to

457
00:20:33,010 --> 00:20:37,500
explain why I think this elliptic curve

458
00:20:37,500 --> 00:20:42,940
deserves a video of its own but all I

459
00:20:42,940 --> 00:20:44,440
can say is that you're doing a lot of

460
00:20:44,440 --> 00:20:47,950
modulus modulus mathematics and so

461
00:20:47,950 --> 00:20:49,330
enough information gets thrown away

462
00:20:49,330 --> 00:20:53,250
whilst doing this multiplication stuff

463
00:20:53,250 --> 00:20:56,200
so you can't just just very difficult to

464
00:20:56,200 --> 00:20:58,900
go backwards and that's why we we rely

465
00:20:58,900 --> 00:21:00,370
on this little curve to basically

466
00:21:00,370 --> 00:21:06,000
protect our public keys and private keys

467
00:21:06,280 --> 00:21:08,809
and this if want to find out more about

468
00:21:08,809 --> 00:21:10,250
why can go backwards it's called the

469
00:21:10,250 --> 00:21:11,570
elliptic curve discrete logarithm

470
00:21:11,570 --> 00:21:14,690
problem but there we go

471
00:21:14,690 --> 00:21:16,880
so we've started with a random number

472
00:21:16,880 --> 00:21:18,110
we've done some elliptic curve

473
00:21:18,110 --> 00:21:20,750
mathematics and we've got a point on the

474
00:21:20,750 --> 00:21:23,360
curve and that is our public key so this

475
00:21:23,360 --> 00:21:24,890
is the mathematical connection this

476
00:21:24,890 --> 00:21:27,169
through this elliptic curve we have a

477
00:21:27,169 --> 00:21:28,730
mathematical connection from our private

478
00:21:28,730 --> 00:21:34,610
key to our public key yes yes so when

479
00:21:34,610 --> 00:21:36,950
you have different caves and this one's

480
00:21:36,950 --> 00:21:39,980
called SEC P you have this one and so

481
00:21:39,980 --> 00:21:43,250
that comes with a particular G generator

482
00:21:43,250 --> 00:21:53,240
point yeah yessum okay cryptography

483
00:21:53,240 --> 00:21:55,309
thing yeah so you can have 10 kids but

484
00:21:55,309 --> 00:21:57,110
it kind uses this particular curve and

485
00:21:57,110 --> 00:22:02,360
these particular parameters so there we

486
00:22:02,360 --> 00:22:06,169
are so that's creating our public key so

487
00:22:06,169 --> 00:22:08,270
now we've got you just generated our

488
00:22:08,270 --> 00:22:10,850
private key and a public key we can

489
00:22:10,850 --> 00:22:14,120
start using Bitcoin so if you want some

490
00:22:14,120 --> 00:22:15,830
people to send us bitcoins we just give

491
00:22:15,830 --> 00:22:18,440
them our public key like so so they've

492
00:22:18,440 --> 00:22:20,570
got a copy of our public key and then

493
00:22:20,570 --> 00:22:23,030
they can unlock any batteries a bitcoins

494
00:22:23,030 --> 00:22:26,539
that they own create a new batch and put

495
00:22:26,539 --> 00:22:29,419
a lock on it and lock this batch of

496
00:22:29,419 --> 00:22:34,700
bitcoins to our public key so when we

497
00:22:34,700 --> 00:22:38,210
want to send bitcoins then the ones

498
00:22:38,210 --> 00:22:40,490
we've received they've been locked to

499
00:22:40,490 --> 00:22:42,289
our public key that we've given away we

500
00:22:42,289 --> 00:22:44,990
just use what we create the transaction

501
00:22:44,990 --> 00:22:47,240
first we want to send them and then we

502
00:22:47,240 --> 00:22:50,539
use our private key to unlock this lock

503
00:22:50,539 --> 00:22:54,230
or basically prove that we created this

504
00:22:54,230 --> 00:22:56,360
public key or that we have the

505
00:22:56,360 --> 00:22:58,880
mathematical connection to this public

506
00:22:58,880 --> 00:23:01,880
key and no one else no one else should

507
00:23:01,880 --> 00:23:06,730
have it so how do we prove that

508
00:23:06,820 --> 00:23:10,280
we created this public key how can we

509
00:23:10,280 --> 00:23:11,809
show that we have the private key that

510
00:23:11,809 --> 00:23:16,610
this public key was created from well a

511
00:23:16,610 --> 00:23:19,700
bad way to do it would be to or one way

512
00:23:19,700 --> 00:23:21,500
of doing it that would be bad

513
00:23:21,500 --> 00:23:23,720
would be just to put your private key

514
00:23:23,720 --> 00:23:25,520
into this transaction into the

515
00:23:25,520 --> 00:23:28,130
transaction you've created so well that

516
00:23:28,130 --> 00:23:30,200
means is anyone could look at this

517
00:23:30,200 --> 00:23:32,530
private key in public key and say okay

518
00:23:32,530 --> 00:23:36,169
this public this person obviously has

519
00:23:36,169 --> 00:23:37,370
this private key because they've given

520
00:23:37,370 --> 00:23:39,770
it to us and they can they can see the

521
00:23:39,770 --> 00:23:41,179
mathematical connection for themselves

522
00:23:41,179 --> 00:23:42,220
they can do the elliptic curve

523
00:23:42,220 --> 00:23:44,450
multiplication and get the same public

524
00:23:44,450 --> 00:23:46,820
key and that proves that we created this

525
00:23:46,820 --> 00:23:50,540
public key but the problem is when this

526
00:23:50,540 --> 00:23:52,820
transaction goes out into the Bitcoin

527
00:23:52,820 --> 00:23:55,010
network it's gonna be in all of these

528
00:23:55,010 --> 00:24:01,700
nodes and so anyone can see this

529
00:24:01,700 --> 00:24:05,030
publicly exposed private key and if they

530
00:24:05,030 --> 00:24:07,340
can see it then what they can do they

531
00:24:07,340 --> 00:24:10,040
can take that public private key and if

532
00:24:10,040 --> 00:24:12,830
there are any other bitcoins locked to

533
00:24:12,830 --> 00:24:16,309
the same public key as this one they can

534
00:24:16,309 --> 00:24:19,610
just copy our private key and basically

535
00:24:19,610 --> 00:24:25,880
take all of the bitcoins or outputs that

536
00:24:25,880 --> 00:24:27,320
have been locked to this public key

537
00:24:27,320 --> 00:24:29,360
before so the last thing we want to do

538
00:24:29,360 --> 00:24:33,380
is give away this private key so that

539
00:24:33,380 --> 00:24:35,410
wouldn't work so what can we do instead

540
00:24:35,410 --> 00:24:37,669
we need to put something here

541
00:24:37,669 --> 00:24:40,970
in this transaction that proves that we

542
00:24:40,970 --> 00:24:43,220
created this public key and we need to

543
00:24:43,220 --> 00:24:44,780
put something here the only we can

544
00:24:44,780 --> 00:24:48,679
create that no one else can put here to

545
00:24:48,679 --> 00:24:52,130
unlock this batch of bitcoins it's what

546
00:24:52,130 --> 00:24:53,660
do we do well we use our private key

547
00:24:53,660 --> 00:24:55,850
again but instead of putting our actual

548
00:24:55,850 --> 00:24:59,120
private key into this transaction data

549
00:24:59,120 --> 00:25:02,480
you create what's called a signature now

550
00:25:02,480 --> 00:25:05,049
these signatures are very handy because

551
00:25:05,049 --> 00:25:07,250
they are created from the private key

552
00:25:07,250 --> 00:25:11,270
and they can actually still prove that

553
00:25:11,270 --> 00:25:13,620
we created this public key

554
00:25:13,620 --> 00:25:16,860
but the good thing is well one it

555
00:25:16,860 --> 00:25:18,300
doesn't give out a way our private key

556
00:25:18,300 --> 00:25:22,200
and also they only work for the

557
00:25:22,200 --> 00:25:25,950
transaction that we're signing so if

558
00:25:25,950 --> 00:25:28,380
someone else sees a signature and we've

559
00:25:28,380 --> 00:25:30,480
got other bitcoins locked to this public

560
00:25:30,480 --> 00:25:32,370
key they can't just look at this

561
00:25:32,370 --> 00:25:35,460
signature take it and put it into this

562
00:25:35,460 --> 00:25:37,620
transaction or transaction they create

563
00:25:37,620 --> 00:25:39,750
because that won't work because this

564
00:25:39,750 --> 00:25:42,780
signature only works for the one

565
00:25:42,780 --> 00:25:46,410
transaction that we are creating so you

566
00:25:46,410 --> 00:25:48,360
could think of the signature as a sort

567
00:25:48,360 --> 00:25:51,059
of special one-time private key that we

568
00:25:51,059 --> 00:25:55,470
use to unlock batches of bitcoins does

569
00:25:55,470 --> 00:25:56,130
that make sense

570
00:25:56,130 --> 00:25:58,080
I cover the details in a moment but as

571
00:25:58,080 --> 00:25:59,610
long as that makes some sense that's

572
00:25:59,610 --> 00:26:03,030
just the very basics of signatures so

573
00:26:03,030 --> 00:26:05,130
we've got a private key a public key but

574
00:26:05,130 --> 00:26:07,620
now we need to figure out how to create

575
00:26:07,620 --> 00:26:10,410
Dignitas digital signatures you know how

576
00:26:10,410 --> 00:26:11,910
can we create this thing here at the

577
00:26:11,910 --> 00:26:15,179
ball and lock this transaction or the

578
00:26:15,179 --> 00:26:16,559
batch of bitcoins for this transaction

579
00:26:16,559 --> 00:26:20,130
without giving away our private key so

580
00:26:20,130 --> 00:26:21,830
that's one of Kevin OH

581
00:26:21,830 --> 00:26:23,880
so a signature we need to create a

582
00:26:23,880 --> 00:26:28,710
signature I'm gonna run through this a

583
00:26:28,710 --> 00:26:31,290
little quickly and I'm gonna cover the

584
00:26:31,290 --> 00:26:33,150
absolute basics don't worry if it

585
00:26:33,150 --> 00:26:34,830
doesn't make complete sense on the first

586
00:26:34,830 --> 00:26:36,600
attempt just as long as you get the gist

587
00:26:36,600 --> 00:26:39,120
of it that's fine it involves some

588
00:26:39,120 --> 00:26:42,929
mathematics so let's move this all other

589
00:26:42,929 --> 00:26:43,320
way

590
00:26:43,320 --> 00:26:44,820
maybe I'll just move everything of the

591
00:26:44,820 --> 00:26:47,730
way but I don't that down here now we

592
00:26:47,730 --> 00:26:49,530
need to create a signature there's two

593
00:26:49,530 --> 00:26:51,480
steps to create a signature and it

594
00:26:51,480 --> 00:26:53,850
involves the use of this elliptic curve

595
00:26:53,850 --> 00:26:56,220
again no surprises that's why we use the

596
00:26:56,220 --> 00:26:57,210
elliptic curve in the first place

597
00:26:57,210 --> 00:26:59,520
because we can use it again to create

598
00:26:59,520 --> 00:27:03,600
signatures so the first part had this

599
00:27:03,600 --> 00:27:05,360
two-step process for creating a

600
00:27:05,360 --> 00:27:10,440
signature is you need a random part so

601
00:27:10,440 --> 00:27:12,600
what you do is you start out by Chariton

602
00:27:12,600 --> 00:27:14,559
a very big random number

603
00:27:14,559 --> 00:27:17,830
and doing some elliptic curve

604
00:27:17,830 --> 00:27:19,240
multiplication again just like we did

605
00:27:19,240 --> 00:27:23,440
earlier and that would give you a random

606
00:27:23,440 --> 00:27:25,240
point on the curve so this is very

607
00:27:25,240 --> 00:27:26,440
similar to what we did earlier we just

608
00:27:26,440 --> 00:27:28,330
took a private key and create a public

609
00:27:28,330 --> 00:27:29,919
key this is the exact same thing but

610
00:27:29,919 --> 00:27:31,659
we're just using a random number that's

611
00:27:31,659 --> 00:27:32,909
going to be used for this one-time

612
00:27:32,909 --> 00:27:36,879
signature for this transaction and so

613
00:27:36,879 --> 00:27:39,730
this random point on the curve that we

614
00:27:39,730 --> 00:27:43,059
generate is called our or what

615
00:27:43,059 --> 00:27:44,529
specifically more specifically we just

616
00:27:44,529 --> 00:27:46,529
need the x value for it

617
00:27:46,529 --> 00:27:51,070
secondly using that random point or the

618
00:27:51,070 --> 00:27:53,559
x value which is just a number we

619
00:27:53,559 --> 00:27:55,749
multiply that but our private key which

620
00:27:55,749 --> 00:27:58,720
again is just a number and then we add

621
00:27:58,720 --> 00:28:02,350
in what's called a message some thing we

622
00:28:02,350 --> 00:28:04,509
want to sign so the thing we want to

623
00:28:04,509 --> 00:28:06,070
create a signature for is this

624
00:28:06,070 --> 00:28:08,860
transaction here so we basically put

625
00:28:08,860 --> 00:28:10,899
that transaction into here as the

626
00:28:10,899 --> 00:28:12,549
message and this is all just a bunch of

627
00:28:12,549 --> 00:28:18,009
data but just we don't put the actual

628
00:28:18,009 --> 00:28:20,019
full data in there what we do we just

629
00:28:20,019 --> 00:28:22,779
hash it and put that the hash of the

630
00:28:22,779 --> 00:28:25,779
data in there but basically we've got

631
00:28:25,779 --> 00:28:28,419
the random part this x value we multiply

632
00:28:28,419 --> 00:28:30,129
that with a private key and then we just

633
00:28:30,129 --> 00:28:34,649
add in the fingerprint for the

634
00:28:34,649 --> 00:28:38,529
transaction we want to sign and then we

635
00:28:38,529 --> 00:28:42,460
just write all that then by our again so

636
00:28:42,460 --> 00:28:44,769
the key thing here really is that we've

637
00:28:44,769 --> 00:28:46,779
got a random point in the cave and we've

638
00:28:46,779 --> 00:28:48,700
got this special number here that

639
00:28:48,700 --> 00:28:50,740
contains a mix of our private key and

640
00:28:50,740 --> 00:28:53,259
the transaction we want the signature to

641
00:28:53,259 --> 00:28:58,809
work for and this is called s so as you

642
00:28:58,809 --> 00:29:00,700
can see the private key and the

643
00:29:00,700 --> 00:29:03,309
transaction data is in there but it's

644
00:29:03,309 --> 00:29:04,680
all jumbled up

645
00:29:04,680 --> 00:29:06,960
so if and we could look at this s value

646
00:29:06,960 --> 00:29:08,430
but they won't be able to see what our

647
00:29:08,430 --> 00:29:09,690
actual private key is because we've used

648
00:29:09,690 --> 00:29:12,720
this R and what not to scramble it up a

649
00:29:12,720 --> 00:29:15,720
little bit but it's all in there so the

650
00:29:15,720 --> 00:29:17,940
signature then is just these two parts

651
00:29:17,940 --> 00:29:20,250
so you put the R in there and you put

652
00:29:20,250 --> 00:29:21,180
the S value in there

653
00:29:21,180 --> 00:29:22,380
so the are just around a point in the

654
00:29:22,380 --> 00:29:25,680
cave the s is a special number that

655
00:29:25,680 --> 00:29:26,970
contains our private key and the

656
00:29:26,970 --> 00:29:28,500
transaction data we want to sign and

657
00:29:28,500 --> 00:29:31,620
that is our signature signature is just

658
00:29:31,620 --> 00:29:35,280
an R and an espalier so move out there

659
00:29:35,280 --> 00:29:45,690
that's the first part then go on through

660
00:29:45,690 --> 00:29:47,490
this again today it will be awesome so

661
00:29:47,490 --> 00:29:52,230
the first part you mentioned was we have

662
00:29:52,230 --> 00:29:54,980
the same gene

663
00:29:55,160 --> 00:29:58,020
generate a random number yes so this is

664
00:29:58,020 --> 00:30:00,090
just a random number yeah you just

665
00:30:00,090 --> 00:30:03,960
missed it yeah and we multiply that

666
00:30:03,960 --> 00:30:05,820
random number with G so we keep hopping

667
00:30:05,820 --> 00:30:07,860
around the curve until you get to a

668
00:30:07,860 --> 00:30:13,910
point just after that and at this point

669
00:30:13,910 --> 00:30:17,010
like our public or private he has not

670
00:30:17,010 --> 00:30:19,710
come into the picture this is random

671
00:30:19,710 --> 00:30:23,300
okay yeah let's go to number two now

672
00:30:23,300 --> 00:30:30,150
okay so we take X from the our with our

673
00:30:30,150 --> 00:30:32,160
private key so we again be hopping

674
00:30:32,160 --> 00:30:35,000
around no sorry this is uh this is not

675
00:30:35,000 --> 00:30:36,990
elliptic curve multiplication this is

676
00:30:36,990 --> 00:30:40,020
just pure mathis normal mathematics so

677
00:30:40,020 --> 00:30:41,790
if you remember our private key is just

678
00:30:41,790 --> 00:30:43,590
a number and this x-value is also just a

679
00:30:43,590 --> 00:30:46,410
number so we just so we just do normal

680
00:30:46,410 --> 00:30:50,730
mathematics so it's not elliptical

681
00:30:50,730 --> 00:30:53,850
multiplication okay okay okay and the

682
00:30:53,850 --> 00:30:57,480
message is basically our what was that

683
00:30:57,480 --> 00:31:00,240
again yeah just the transaction data so

684
00:31:00,240 --> 00:31:02,490
by putting the transaction data into

685
00:31:02,490 --> 00:31:04,770
here and that means this signature will

686
00:31:04,770 --> 00:31:07,070
only work for this particular

687
00:31:07,070 --> 00:31:10,350
transaction and obviously the private

688
00:31:10,350 --> 00:31:12,090
key is here just to prove that we own

689
00:31:12,090 --> 00:31:13,440
this public key

690
00:31:13,440 --> 00:31:16,380
like and from the previous video this is

691
00:31:16,380 --> 00:31:19,650
the transaction data without the single

692
00:31:19,650 --> 00:31:21,060
yes that's correct

693
00:31:21,060 --> 00:31:22,950
so you take all this thing it yeah so

694
00:31:22,950 --> 00:31:24,690
you take all the signatures out and then

695
00:31:24,690 --> 00:31:26,370
you put then you hatch the data and put

696
00:31:26,370 --> 00:31:29,960
it into here yes good good memory yep

697
00:31:29,960 --> 00:31:36,510
and we so these are values serve to help

698
00:31:36,510 --> 00:31:39,120
to scramble up this you know our private

699
00:31:39,120 --> 00:31:44,490
key basically okay yeah so that is a

700
00:31:44,490 --> 00:31:46,440
signature created house two parts random

701
00:31:46,440 --> 00:31:49,410
random point on the cave and a special

702
00:31:49,410 --> 00:31:52,620
number derived from using our private

703
00:31:52,620 --> 00:31:59,900
key now we'll see why this works now why

704
00:31:59,900 --> 00:32:02,190
did we create these two things for the

705
00:32:02,190 --> 00:32:06,750
signature well when we put where we send

706
00:32:06,750 --> 00:32:08,550
this transaction data or this whole

707
00:32:08,550 --> 00:32:10,010
transaction into the Bitcoin network

708
00:32:10,010 --> 00:32:13,410
every single node on the network is

709
00:32:13,410 --> 00:32:15,390
going to various verify that this is a

710
00:32:15,390 --> 00:32:18,270
this is a valid transaction so they're

711
00:32:18,270 --> 00:32:21,090
gonna take this signature and they want

712
00:32:21,090 --> 00:32:22,260
to fight and they want to be able to say

713
00:32:22,260 --> 00:32:24,780
okay this signature could only have been

714
00:32:24,780 --> 00:32:29,400
created by the person who owns the

715
00:32:29,400 --> 00:32:31,590
private key that this public key was

716
00:32:31,590 --> 00:32:36,510
created from so they need to verify that

717
00:32:36,510 --> 00:32:38,910
to make sure that their signature works

718
00:32:38,910 --> 00:32:40,290
always created from this particular

719
00:32:40,290 --> 00:32:43,950
private key so how can they do that they

720
00:32:43,950 --> 00:32:45,420
haven't got the private key or they've

721
00:32:45,420 --> 00:32:47,880
got these two values the R and the s

722
00:32:47,880 --> 00:32:50,160
value but the s value has been created

723
00:32:50,160 --> 00:32:53,400
from this private key so how do they do

724
00:32:53,400 --> 00:32:55,800
that well first of all they take this R

725
00:32:55,800 --> 00:32:57,270
value that it given them and this is the

726
00:32:57,270 --> 00:32:59,130
while they just start with that and

727
00:32:59,130 --> 00:33:01,290
again this is a two step process for

728
00:33:01,290 --> 00:33:02,180
them as well

729
00:33:02,180 --> 00:33:04,620
first of all

730
00:33:04,620 --> 00:33:08,290
they do some normal mathematics they

731
00:33:08,290 --> 00:33:12,160
just multiply the hash of the

732
00:33:12,160 --> 00:33:15,040
transaction data without our value and

733
00:33:15,040 --> 00:33:17,740
that will give them just a very big

734
00:33:17,740 --> 00:33:20,890
number and so what they do without very

735
00:33:20,890 --> 00:33:22,570
big number on this first step after

736
00:33:22,570 --> 00:33:23,940
multiplying these two values together

737
00:33:23,940 --> 00:33:26,380
they'll start at this generator point

738
00:33:26,380 --> 00:33:28,570
and they'll do elliptic curve

739
00:33:28,570 --> 00:33:30,250
multiplication using this big number

740
00:33:30,250 --> 00:33:34,090
they've multiplied starting at G and

741
00:33:34,090 --> 00:33:35,680
they'll bounce around it and that would

742
00:33:35,680 --> 00:33:39,510
give them this first point on the curve

743
00:33:39,510 --> 00:33:42,780
second of all they'll do some more

744
00:33:42,780 --> 00:33:45,700
normal multiplication again you'll just

745
00:33:45,700 --> 00:33:49,270
do s times R so they'll just take this s

746
00:33:49,270 --> 00:33:51,730
value multiply it by this R value and

747
00:33:51,730 --> 00:33:53,920
then starting this time at the public

748
00:33:53,920 --> 00:33:56,860
key they will bounce around the key of

749
00:33:56,860 --> 00:33:59,740
this many times so that bounce on the

750
00:33:59,740 --> 00:34:01,360
key of this many times and I'll give

751
00:34:01,360 --> 00:34:03,930
them a second point on the curve and now

752
00:34:03,930 --> 00:34:08,020
the magic part here is if all three of

753
00:34:08,020 --> 00:34:13,600
these points on the curve line up then

754
00:34:13,600 --> 00:34:17,310
that means that this signature is valid

755
00:34:17,310 --> 00:34:25,060
so with elliptic curves if you draw a

756
00:34:25,060 --> 00:34:26,590
line through two points on the curve

757
00:34:26,590 --> 00:34:28,510
just like a tangent will always

758
00:34:28,510 --> 00:34:30,010
intersect one other point on the curve

759
00:34:30,010 --> 00:34:33,100
if you draw a line through two points on

760
00:34:33,100 --> 00:34:35,590
the curve that will always intersect one

761
00:34:35,590 --> 00:34:38,380
other point on the curve as well so by

762
00:34:38,380 --> 00:34:41,820
generating these two points on the curve

763
00:34:41,820 --> 00:34:45,010
using these two values that we that we

764
00:34:45,010 --> 00:34:47,290
have been given along with the public

765
00:34:47,290 --> 00:34:50,409
key and the transaction data we can

766
00:34:50,409 --> 00:34:51,760
generate at these two points on the

767
00:34:51,760 --> 00:34:54,460
curve and if they all line up then the

768
00:34:54,460 --> 00:34:57,400
signature is valid so what that means is

769
00:34:57,400 --> 00:35:00,790
that if someone tampers with the

770
00:35:00,790 --> 00:35:02,560
transaction data so we give them as

771
00:35:02,560 --> 00:35:04,420
transaction data and the signature and

772
00:35:04,420 --> 00:35:06,280
then they try and send the bitcoins to

773
00:35:06,280 --> 00:35:07,930
their address they tamper with you know

774
00:35:07,930 --> 00:35:10,120
the transaction data that means that

775
00:35:10,120 --> 00:35:12,880
this value will be different and so when

776
00:35:12,880 --> 00:35:14,440
they generate the first point that'll be

777
00:35:14,440 --> 00:35:17,510
different and they won't all line up

778
00:35:17,510 --> 00:35:21,000
so the signature won't work then so that

779
00:35:21,000 --> 00:35:22,920
protects this transaction data from

780
00:35:22,920 --> 00:35:26,450
being altered

781
00:35:26,450 --> 00:35:29,480
similarly if someone tries to create a

782
00:35:29,480 --> 00:35:33,120
signature to spend our bitcoins using a

783
00:35:33,120 --> 00:35:36,030
private key of their own you know not

784
00:35:36,030 --> 00:35:38,370
the one that we created the public key

785
00:35:38,370 --> 00:35:40,440
from so a different private key

786
00:35:40,440 --> 00:35:42,510
altogether that means that when they

787
00:35:42,510 --> 00:35:44,370
generate this s value that be completely

788
00:35:44,370 --> 00:35:46,200
different and if that s value is

789
00:35:46,200 --> 00:35:49,650
different than this number here is gonna

790
00:35:49,650 --> 00:35:51,690
be different so when we do the elliptic

791
00:35:51,690 --> 00:35:53,430
curve multiplication starting from the

792
00:35:53,430 --> 00:35:55,470
public key this point is gonna be

793
00:35:55,470 --> 00:35:57,960
different again and the points won't

794
00:35:57,960 --> 00:36:02,850
line up so this is a very basic overview

795
00:36:02,850 --> 00:36:07,770
of how digital signatures work and if

796
00:36:07,770 --> 00:36:11,490
all you understand is that private keys

797
00:36:11,490 --> 00:36:14,370
and public keys are connected through

798
00:36:14,370 --> 00:36:16,260
elliptic curves and the reason we use

799
00:36:16,260 --> 00:36:18,600
elliptic curves is because we can create

800
00:36:18,600 --> 00:36:21,030
these signatures and other people can

801
00:36:21,030 --> 00:36:24,090
verify them doing some elliptic a of

802
00:36:24,090 --> 00:36:25,950
mathematics and these are the special

803
00:36:25,950 --> 00:36:31,950
properties of elliptic curves so again

804
00:36:31,950 --> 00:36:34,380
just to summarize like I said and you

805
00:36:34,380 --> 00:36:36,810
just take a private key you do elliptic

806
00:36:36,810 --> 00:36:39,270
eight of mathematics multiplication

807
00:36:39,270 --> 00:36:42,300
together public key and then you give

808
00:36:42,300 --> 00:36:43,620
that public key to other people and

809
00:36:43,620 --> 00:36:46,170
they'll put that or they'll lock up a

810
00:36:46,170 --> 00:36:48,600
batch of bitcoins to that public key but

811
00:36:48,600 --> 00:36:50,490
then from there we need to where we want

812
00:36:50,490 --> 00:36:52,950
to send them on to other people we want

813
00:36:52,950 --> 00:36:55,020
to send them on we need to prove that we

814
00:36:55,020 --> 00:36:57,330
are the creators of this public key so

815
00:36:57,330 --> 00:36:59,150
what we do we take our private key

816
00:36:59,150 --> 00:37:02,100
create a signal signature which again

817
00:37:02,100 --> 00:37:04,670
involves some elliptic curve mathematics

818
00:37:04,670 --> 00:37:07,320
and then we give them that signature and

819
00:37:07,320 --> 00:37:10,740
then they can do some verification to

820
00:37:10,740 --> 00:37:12,780
verify that we created this signature

821
00:37:12,780 --> 00:37:14,850
from the correct private key and they do

822
00:37:14,850 --> 00:37:17,280
that by taking this public key and the

823
00:37:17,280 --> 00:37:20,640
signature and also the data and they

824
00:37:20,640 --> 00:37:22,680
generates three points on the curve and

825
00:37:22,680 --> 00:37:27,120
if they line up and if they line up then

826
00:37:27,120 --> 00:37:29,240
that signature works

827
00:37:29,240 --> 00:37:31,820
and again if someone doesn't use the

828
00:37:31,820 --> 00:37:32,830
right private key

829
00:37:32,830 --> 00:37:35,660
they won't line up or if someone alters

830
00:37:35,660 --> 00:37:37,730
with the transaction data they won't

831
00:37:37,730 --> 00:37:41,540
line up either again so it's a bit magic

832
00:37:41,540 --> 00:37:44,660
this whole process but ultimately it's

833
00:37:44,660 --> 00:37:47,030
all mathematics and if what will you

834
00:37:47,030 --> 00:37:52,010
take away from this a few slides it's

835
00:37:52,010 --> 00:37:54,170
just that this elliptic curve

836
00:37:54,170 --> 00:37:57,290
mathematics is very good for

837
00:37:57,290 --> 00:38:01,600
cryptography and for you know creating

838
00:38:01,600 --> 00:38:04,010
account numbers and passwords and then

839
00:38:04,010 --> 00:38:05,660
being able to prove that you own the

840
00:38:05,660 --> 00:38:07,670
account number without ever given the

841
00:38:07,670 --> 00:38:11,960
password away which is very clever so

842
00:38:11,960 --> 00:38:14,300
this is called elliptic curve

843
00:38:14,300 --> 00:38:18,110
cryptography and it's very very useful

844
00:38:18,110 --> 00:38:20,600
and without it we would not be able to

845
00:38:20,600 --> 00:38:23,840
send and receive bitcoins safely without

846
00:38:23,840 --> 00:38:26,050
having a person in control of all the

847
00:38:26,050 --> 00:38:28,580
sets of keys so this means through this

848
00:38:28,580 --> 00:38:30,619
elliptic curve cryptography we can

849
00:38:30,619 --> 00:38:33,230
generate our own account numbers and

850
00:38:33,230 --> 00:38:34,820
passwords to be able to send and receive

851
00:38:34,820 --> 00:38:38,600
bitcoins which is very very handy and

852
00:38:38,600 --> 00:38:39,890
again like I said at the start this

853
00:38:39,890 --> 00:38:43,369
video crypto this is why Bitcoin another

854
00:38:43,369 --> 00:38:47,480
and currencies I get are called crypto

855
00:38:47,480 --> 00:38:49,520
currencies because they use cryptography

856
00:38:49,520 --> 00:38:52,810
as the backbone for the ownership of

857
00:38:52,810 --> 00:38:57,760
these batches of bitcoins

858
00:38:58,200 --> 00:39:01,030
so let me just move all this back to

859
00:39:01,030 --> 00:39:05,410
here so that is private key public key

860
00:39:05,410 --> 00:39:08,530
and the signatures done so this is the

861
00:39:08,530 --> 00:39:13,030
basics of sending or receiving and

862
00:39:13,030 --> 00:39:14,050
receiving bitcoins

863
00:39:14,050 --> 00:39:17,950
in a Bitcoin just these set keys and

864
00:39:17,950 --> 00:39:20,530
cretins digital signatures to prove that

865
00:39:20,530 --> 00:39:24,970
you own the public part of them so from

866
00:39:24,970 --> 00:39:26,680
there you've probably heard of addresses

867
00:39:26,680 --> 00:39:29,680
what our address is well addresses are

868
00:39:29,680 --> 00:39:33,310
just basically prettier versions of the

869
00:39:33,310 --> 00:39:36,010
public key more user-friendly versions

870
00:39:36,010 --> 00:39:39,880
of the public key so originally or you

871
00:39:39,880 --> 00:39:41,410
can still do this in Bitcoin you can

872
00:39:41,410 --> 00:39:43,420
just generate a private key and a public

873
00:39:43,420 --> 00:39:45,700
key for yourself give that public key to

874
00:39:45,700 --> 00:39:48,100
other people they will lock up bitcoins

875
00:39:48,100 --> 00:39:50,410
for you you know to that public key and

876
00:39:50,410 --> 00:39:52,690
then you can use that private key to

877
00:39:52,690 --> 00:39:56,820
create a signature and send them on but

878
00:39:56,820 --> 00:39:59,880
this all works well and it's fine

879
00:39:59,880 --> 00:40:03,160
if someone looks at this public key they

880
00:40:03,160 --> 00:40:04,510
can't figure out like I said before

881
00:40:04,510 --> 00:40:06,670
while the private key is because you

882
00:40:06,670 --> 00:40:09,250
can't go backwards through this I

883
00:40:09,250 --> 00:40:10,750
diptych hear of multiplication you can

884
00:40:10,750 --> 00:40:13,780
go this way we can't go that way but

885
00:40:13,780 --> 00:40:17,740
what it does mean is that this is not

886
00:40:17,740 --> 00:40:20,140
known to have been solved at this moment

887
00:40:20,140 --> 00:40:21,700
in time and it doesn't look like

888
00:40:21,700 --> 00:40:23,500
anyone's gonna find a solution for going

889
00:40:23,500 --> 00:40:25,780
backwards for the through the elliptic

890
00:40:25,780 --> 00:40:28,240
curve but it does mean that if it was

891
00:40:28,240 --> 00:40:32,350
ever broken then your public keys while

892
00:40:32,350 --> 00:40:35,230
your bitcoins can be stolen I mean

893
00:40:35,230 --> 00:40:39,580
there's no risk no one can see this

894
00:40:39,580 --> 00:40:41,260
happening for the foreseeable future but

895
00:40:41,260 --> 00:40:43,000
it does mean that this public key is

896
00:40:43,000 --> 00:40:45,220
like a sitting duck waiting to be broken

897
00:40:45,220 --> 00:40:48,910
if listen diptych if can be broken so in

898
00:40:48,910 --> 00:40:51,790
Bitcoin we like to use a bit more

899
00:40:51,790 --> 00:40:54,910
security how can we not have to just

900
00:40:54,910 --> 00:40:57,370
rely on this elliptic curve discrete

901
00:40:57,370 --> 00:40:59,800
logarithm problem to protect our

902
00:40:59,800 --> 00:41:01,440
bitcoins

903
00:41:01,440 --> 00:41:04,380
so the solution tart is and what we do

904
00:41:04,380 --> 00:41:07,370
is we just a hash this public key twice

905
00:41:07,370 --> 00:41:09,570
through tooth through two different

906
00:41:09,570 --> 00:41:12,060
hashing functions the first one first

907
00:41:12,060 --> 00:41:14,370
one is a sha-256 which is when you

908
00:41:14,370 --> 00:41:16,290
should be familiar with from mining and

909
00:41:16,290 --> 00:41:18,720
then also a second one is used called

910
00:41:18,720 --> 00:41:21,720
Reich MD 160 so what it says is like

911
00:41:21,720 --> 00:41:24,060
double hashing through different through

912
00:41:24,060 --> 00:41:25,950
two different hashing functions the

913
00:41:25,950 --> 00:41:27,960
public key and then what you do then

914
00:41:27,960 --> 00:41:31,080
you'll give that hashed version of the

915
00:41:31,080 --> 00:41:34,160
public key to the people instead of the

916
00:41:34,160 --> 00:41:37,380
standard public key so it's like a

917
00:41:37,380 --> 00:41:40,560
scrambled version of this public key you

918
00:41:40,560 --> 00:41:42,180
give that to other people and then

919
00:41:42,180 --> 00:41:45,450
they'll actually put these in the locks

920
00:41:45,450 --> 00:41:49,800
so what that means is whilst this hashed

921
00:41:49,800 --> 00:41:52,050
version of the public key is in the lock

922
00:41:52,050 --> 00:41:54,150
if someone wants to go all the way back

923
00:41:54,150 --> 00:41:56,550
to get to your private key instead of

924
00:41:56,550 --> 00:41:58,230
just going back from the public key and

925
00:41:58,230 --> 00:41:59,490
trying to go through backwards through

926
00:41:59,490 --> 00:42:02,250
the and it to cave which you can't do

927
00:42:02,250 --> 00:42:05,820
but that's the only here it'll jump over

928
00:42:05,820 --> 00:42:07,380
if you want to figure out your private

929
00:42:07,380 --> 00:42:08,790
key from this hashed version of the

930
00:42:08,790 --> 00:42:10,950
public key you have to go basically you

931
00:42:10,950 --> 00:42:12,900
have to break the ripe empty hash

932
00:42:12,900 --> 00:42:15,660
function which no one is done then you

933
00:42:15,660 --> 00:42:17,010
also have to be able to go backwards

934
00:42:17,010 --> 00:42:20,280
with a sha-256 hash function regional is

935
00:42:20,280 --> 00:42:22,620
done and after doing that I'll give you

936
00:42:22,620 --> 00:42:24,600
the private public key then using that

937
00:42:24,600 --> 00:42:26,840
you have to go back and break this

938
00:42:26,840 --> 00:42:30,300
elliptic curve mission was done either

939
00:42:30,300 --> 00:42:33,660
so this hashed version is a very very

940
00:42:33,660 --> 00:42:40,170
secure version of the public key so the

941
00:42:40,170 --> 00:42:41,850
reason we create this is because all of

942
00:42:41,850 --> 00:42:43,620
these batches of bitcoins they all gonna

943
00:42:43,620 --> 00:42:47,130
contain a public key so this is just a

944
00:42:47,130 --> 00:42:49,890
very safe version of the public key to

945
00:42:49,890 --> 00:42:52,170
give away because it's hard to get back

946
00:42:52,170 --> 00:42:53,460
to the private key so if there's gonna

947
00:42:53,460 --> 00:42:54,960
be a sitting duck let's make it very

948
00:42:54,960 --> 00:42:58,950
safe so there are two public key and

949
00:42:58,950 --> 00:43:01,020
what we call this there's Nvidia

950
00:43:01,020 --> 00:43:04,680
secretly a particularly a fancy name for

951
00:43:04,680 --> 00:43:07,020
it we just called it the hash 160 of the

952
00:43:07,020 --> 00:43:10,110
public key so they just hash because I'm

953
00:43:10,110 --> 00:43:11,700
using hash functions and that last one

954
00:43:11,700 --> 00:43:13,960
we use is to write BMD 160 so

955
00:43:13,960 --> 00:43:16,450
it's commonly shortened to hash 160

956
00:43:16,450 --> 00:43:22,000
public key so there we go so that's all

957
00:43:22,000 --> 00:43:24,040
well and good we've hashed this but the

958
00:43:24,040 --> 00:43:27,490
problem is now before we would have just

959
00:43:27,490 --> 00:43:29,320
put the public key in here and in

960
00:43:29,320 --> 00:43:31,360
created a signature and put that in

961
00:43:31,360 --> 00:43:34,870
there but after a hash in this public

962
00:43:34,870 --> 00:43:36,690
key you know there's no mathematical

963
00:43:36,690 --> 00:43:38,830
connection you know from this hashed

964
00:43:38,830 --> 00:43:41,230
version to the private key so we can't

965
00:43:41,230 --> 00:43:45,130
just put a signature in here so when we

966
00:43:45,130 --> 00:43:49,390
want to and send bitcoins what do we do

967
00:43:49,390 --> 00:43:49,780
now

968
00:43:49,780 --> 00:43:53,230
what we put in this space here this

969
00:43:53,230 --> 00:43:55,930
unlocking code well we still put the

970
00:43:55,930 --> 00:43:58,630
signature in here but along with the

971
00:43:58,630 --> 00:44:00,580
signature we actually put in the public

972
00:44:00,580 --> 00:44:04,000
key also so what that means is so this

973
00:44:04,000 --> 00:44:06,430
lock now has adjusted a little bit to

974
00:44:06,430 --> 00:44:09,090
say give me a public key and a signature

975
00:44:09,090 --> 00:44:11,950
and what I'll do then is the first thing

976
00:44:11,950 --> 00:44:14,350
you'll do is it will check that the

977
00:44:14,350 --> 00:44:16,480
public key that you've put here hashes

978
00:44:16,480 --> 00:44:18,910
to this hashed version of it you know

979
00:44:18,910 --> 00:44:20,710
through this to it and anyone can do

980
00:44:20,710 --> 00:44:21,970
that through these two hash functions

981
00:44:21,970 --> 00:44:24,910
and after - after doing that it will do

982
00:44:24,910 --> 00:44:27,460
what it did before just sack check that

983
00:44:27,460 --> 00:44:33,010
the signature works so whereas before we

984
00:44:33,010 --> 00:44:34,180
had the public key in here and there's

985
00:44:34,180 --> 00:44:36,510
like a one step process of comparing the

986
00:44:36,510 --> 00:44:39,070
signature to the public key this is now

987
00:44:39,070 --> 00:44:40,780
a two step process where it first

988
00:44:40,780 --> 00:44:42,730
compares the public key to the hashed

989
00:44:42,730 --> 00:44:44,590
version that you've given away and if

990
00:44:44,590 --> 00:44:46,990
that checks out they will check the

991
00:44:46,990 --> 00:44:50,020
signature against the public key so

992
00:44:50,020 --> 00:44:51,730
basically just adds another step okay go

993
00:44:51,730 --> 00:44:52,770
on

994
00:44:52,770 --> 00:44:59,220
so in that sense we do have public keys

995
00:44:59,220 --> 00:45:04,720
which are for the Asch 160s that is open

996
00:45:04,720 --> 00:45:10,720
information yes if I okay another

997
00:45:10,720 --> 00:45:12,100
question point that you'd be thinking

998
00:45:12,100 --> 00:45:13,810
now is okay well what's the point in

999
00:45:13,810 --> 00:45:16,630
hash in this and giving this away if

1000
00:45:16,630 --> 00:45:18,070
eventually we're going to be given the

1001
00:45:18,070 --> 00:45:21,300
public key away anyway

1002
00:45:23,610 --> 00:45:26,230
well the thinking is that this public

1003
00:45:26,230 --> 00:45:27,240
key and

1004
00:45:27,240 --> 00:45:29,990
is only given away at the last moment so

1005
00:45:29,990 --> 00:45:33,270
say it took some time to be able to you

1006
00:45:33,270 --> 00:45:34,650
know brute force and get backwards

1007
00:45:34,650 --> 00:45:37,320
through this elliptic curve that if it

1008
00:45:37,320 --> 00:45:40,350
was broken in some way well if it was

1009
00:45:40,350 --> 00:45:42,330
first of all if it's completely broken

1010
00:45:42,330 --> 00:45:44,460
then your bitcoins are safe so if you

1011
00:45:44,460 --> 00:45:45,840
just don't spend them then they're still

1012
00:45:45,840 --> 00:45:47,160
no one else can take them but they're

1013
00:45:47,160 --> 00:45:50,490
not obviously not very good but this

1014
00:45:50,490 --> 00:45:52,140
developed the thinking is that this is

1015
00:45:52,140 --> 00:45:53,610
like you only give away at the last

1016
00:45:53,610 --> 00:45:55,050
moment and if it's given away the last

1017
00:45:55,050 --> 00:45:58,200
moment then hopefully other people won't

1018
00:45:58,200 --> 00:46:01,470
have the time to be able to work

1019
00:46:01,470 --> 00:46:02,790
backwards quick enough to be able to

1020
00:46:02,790 --> 00:46:07,340
steal your bitcoins but on the plus side

1021
00:46:07,340 --> 00:46:09,510
well is I think it's better than nothing

1022
00:46:09,510 --> 00:46:13,410
really so this is why we use this hash

1023
00:46:13,410 --> 00:46:16,020
version so this hashed version you know

1024
00:46:16,020 --> 00:46:17,460
it doesn't give anyone any incentive to

1025
00:46:17,460 --> 00:46:19,619
try and work backwards through this I

1026
00:46:19,619 --> 00:46:21,510
have to give because I have to get

1027
00:46:21,510 --> 00:46:24,570
through these first so it's busy going

1028
00:46:24,570 --> 00:46:27,060
somewhere my thought is that let's say

1029
00:46:27,060 --> 00:46:32,369
we have ten bitcoins behind this work

1030
00:46:32,369 --> 00:46:37,580
yes yeah and we spend say one Bitcoin

1031
00:46:37,580 --> 00:46:40,410
out of those term declines so at this

1032
00:46:40,410 --> 00:46:46,080
time an attacker has the public key for

1033
00:46:46,080 --> 00:46:50,010
the hash 160 yes but what you boo and

1034
00:46:50,010 --> 00:46:51,780
yeah but what you do is say you want to

1035
00:46:51,780 --> 00:46:54,690
send a sin is 10 bitcoins here and we

1036
00:46:54,690 --> 00:46:56,970
want to send one Bitcoin to someone else

1037
00:46:56,970 --> 00:46:59,520
and then we want to keep the change for

1038
00:46:59,520 --> 00:47:02,550
ourselves what is recommended is that

1039
00:47:02,550 --> 00:47:06,930
you create a new address so that's why

1040
00:47:06,930 --> 00:47:10,109
everyone says don't reuse the same

1041
00:47:10,109 --> 00:47:12,660
address that's because when you send the

1042
00:47:12,660 --> 00:47:14,250
change to yourself if you use a

1043
00:47:14,250 --> 00:47:16,200
different address then even though you

1044
00:47:16,200 --> 00:47:18,300
give them away there's public key it's

1045
00:47:18,300 --> 00:47:20,040
effectively useless because all of the

1046
00:47:20,040 --> 00:47:22,980
bitcoins that were locked to this public

1047
00:47:22,980 --> 00:47:26,280
key and I've been spent and moved on so

1048
00:47:26,280 --> 00:47:28,890
that's why everyone says to not to use

1049
00:47:28,890 --> 00:47:31,770
different address or to use different

1050
00:47:31,770 --> 00:47:34,600
addresses every time for your change

1051
00:47:34,600 --> 00:47:37,450
right yeah then the last-minute logic

1052
00:47:37,450 --> 00:47:39,160
makes sense that is because if it's a

1053
00:47:39,160 --> 00:47:40,990
new address then again you don't know

1054
00:47:40,990 --> 00:47:46,060
the public Yeah right

1055
00:47:46,060 --> 00:47:48,070
so in kalameet sense but so obviously

1056
00:47:48,070 --> 00:47:53,650
now you can still use if you go back you

1057
00:47:53,650 --> 00:47:55,120
can still use this method I've just put

1058
00:47:55,120 --> 00:47:57,070
in the public key in here and you can

1059
00:47:57,070 --> 00:47:58,570
still create locks that do this and that

1060
00:47:58,570 --> 00:48:02,320
is perfectly fine but when people all of

1061
00:48:02,320 --> 00:48:04,210
the wallets these days they all built to

1062
00:48:04,210 --> 00:48:06,970
use this to hash vision the public key

1063
00:48:06,970 --> 00:48:08,770
because it's more secure but you can

1064
00:48:08,770 --> 00:48:10,480
still use this you know put a public key

1065
00:48:10,480 --> 00:48:12,010
in here and then just use one signature

1066
00:48:12,010 --> 00:48:15,070
that's how a lot of early transactions

1067
00:48:15,070 --> 00:48:16,480
in the blockchain if you check them out

1068
00:48:16,480 --> 00:48:18,400
they use a very simple public key and

1069
00:48:18,400 --> 00:48:21,400
one signature but all the transactions

1070
00:48:21,400 --> 00:48:26,560
now well you know more recent ones they

1071
00:48:26,560 --> 00:48:29,910
use the hash hashed version inside this

1072
00:48:29,910 --> 00:48:33,850
lock and then they put the public key

1073
00:48:33,850 --> 00:48:35,410
and signature in the unlocking code

1074
00:48:35,410 --> 00:48:40,240
afterwards so by here I've just done a

1075
00:48:40,240 --> 00:48:42,550
wordy wordy description of how these

1076
00:48:42,550 --> 00:48:45,040
locks work the next video I'll do will

1077
00:48:45,040 --> 00:48:46,930
be actually looking inside these locks

1078
00:48:46,930 --> 00:48:48,460
to look at the code to see how they

1079
00:48:48,460 --> 00:48:50,080
actually work so this is the locking

1080
00:48:50,080 --> 00:48:51,880
code the lock and this is the unlocking

1081
00:48:51,880 --> 00:48:56,880
code here so okay finally like I said

1082
00:48:56,880 --> 00:49:00,340
what is an address I have to go through

1083
00:49:00,340 --> 00:49:01,780
this just to show you an address comes

1084
00:49:01,780 --> 00:49:06,750
from so like I said in the last one and

1085
00:49:06,750 --> 00:49:10,180
maybe want to receive bitcoins we give

1086
00:49:10,180 --> 00:49:12,670
away this hashed version of the public

1087
00:49:12,670 --> 00:49:14,980
key but if you actually look at all this

1088
00:49:14,980 --> 00:49:17,860
data so let's say this is a private key

1089
00:49:17,860 --> 00:49:20,590
and then this is a public key which is a

1090
00:49:20,590 --> 00:49:23,740
big number as well these were typically

1091
00:49:23,740 --> 00:49:27,460
stored in hexadecimal format so let me

1092
00:49:27,460 --> 00:49:30,400
just convert those quickly and so many

1093
00:49:30,400 --> 00:49:32,500
hash all this data through those two

1094
00:49:32,500 --> 00:49:36,870
hash functions we end up with this

1095
00:49:37,049 --> 00:49:39,489
hexadecimal number here for that hashed

1096
00:49:39,489 --> 00:49:45,130
version of the public key this works and

1097
00:49:45,130 --> 00:49:46,089
we can give this way to other people

1098
00:49:46,089 --> 00:49:47,019
that's fine

1099
00:49:47,019 --> 00:49:49,420
there's no this is if you wanted to make

1100
00:49:49,420 --> 00:49:51,039
it simple you could just give people

1101
00:49:51,039 --> 00:49:53,200
this direct hashed version the public

1102
00:49:53,200 --> 00:49:55,390
key and that's fine but the problem is

1103
00:49:55,390 --> 00:49:56,729
it's not particularly user friendly

1104
00:49:56,729 --> 00:50:00,099
because so you give it away or you

1105
00:50:00,099 --> 00:50:03,640
describe the this public key over the

1106
00:50:03,640 --> 00:50:06,059
phone say someone else types it in and

1107
00:50:06,059 --> 00:50:09,190
they make a mistake and then they fill

1108
00:50:09,190 --> 00:50:12,039
it out if they make one single mistake

1109
00:50:12,039 --> 00:50:14,049
then it's gonna send the Bitcoin so

1110
00:50:14,049 --> 00:50:16,079
different completely different address

1111
00:50:16,079 --> 00:50:18,430
so it's going to lose those bitcoins and

1112
00:50:18,430 --> 00:50:20,789
this person is not going to receive them

1113
00:50:20,789 --> 00:50:24,880
so that's not good so there's no error

1114
00:50:24,880 --> 00:50:27,220
checking so when you type in this hashed

1115
00:50:27,220 --> 00:50:30,099
version the public key there's no way to

1116
00:50:30,099 --> 00:50:33,009
check it for errors secondly it's a bit

1117
00:50:33,009 --> 00:50:35,859
long so if you make it shorter that'd be

1118
00:50:35,859 --> 00:50:37,900
great but it's importantly there's no

1119
00:50:37,900 --> 00:50:40,779
way we check in so what can we do to

1120
00:50:40,779 --> 00:50:46,539
make these well basically the address is

1121
00:50:46,539 --> 00:50:47,799
just going to be a you more

1122
00:50:47,799 --> 00:50:50,049
user-friendly version of this public key

1123
00:50:50,049 --> 00:50:52,839
that contains error checking and it's a

1124
00:50:52,839 --> 00:50:55,839
bit shorter so how do we fix this error

1125
00:50:55,839 --> 00:50:58,569
checking problem well what we do is you

1126
00:50:58,569 --> 00:51:02,380
we create what's called a checksum so we

1127
00:51:02,380 --> 00:51:07,869
hash this hashed version of the perfect

1128
00:51:07,869 --> 00:51:10,739
key and that will give us a long number

1129
00:51:10,739 --> 00:51:13,509
if we just take the four bytes the first

1130
00:51:13,509 --> 00:51:16,779
four bytes of that the hash of this

1131
00:51:16,779 --> 00:51:18,999
public key and that is called the

1132
00:51:18,999 --> 00:51:21,719
checksum and so we stick that on the end

1133
00:51:21,719 --> 00:51:25,450
and so what that means is if someone was

1134
00:51:25,450 --> 00:51:29,619
to type in this whole entire public key

1135
00:51:29,619 --> 00:51:31,479
into their wallet software if they make

1136
00:51:31,479 --> 00:51:34,269
one mistake here the wallet software can

1137
00:51:34,269 --> 00:51:37,329
hash this and check to make sure for

1138
00:51:37,329 --> 00:51:40,450
this part of the key matches the

1139
00:51:40,450 --> 00:51:43,239
checksum and if it doesn't then they'll

1140
00:51:43,239 --> 00:51:44,489
know someone's made a mistake somewhere

1141
00:51:44,489 --> 00:51:46,539
they won't be you want be able to tell

1142
00:51:46,539 --> 00:51:49,119
you where it's made a mistake but it

1143
00:51:49,119 --> 00:51:50,770
will note it will say wait there

1144
00:51:50,770 --> 00:51:52,869
you made mistake here some man which is

1145
00:51:52,869 --> 00:51:55,350
better than nothing

1146
00:51:57,150 --> 00:52:00,610
similarly like I said it's a bit long

1147
00:52:00,610 --> 00:52:03,550
can we make this any shorter no I've got

1148
00:52:03,550 --> 00:52:06,670
the checksum here Smith the public key a

1149
00:52:06,670 --> 00:52:08,320
bit longer again can we shorten it down

1150
00:52:08,320 --> 00:52:13,119
well yes we can this version here has

1151
00:52:13,119 --> 00:52:16,680
been encoded in a hexadecimal format

1152
00:52:16,680 --> 00:52:20,140
which contains has 16 characters to

1153
00:52:20,140 --> 00:52:21,280
choose from

1154
00:52:21,280 --> 00:52:24,220
what if it's just a number instead of in

1155
00:52:24,220 --> 00:52:26,470
chord encoding it in a format there used

1156
00:52:26,470 --> 00:52:28,630
to 16 characters well if we just use a

1157
00:52:28,630 --> 00:52:32,290
lot more characters so it's a 16

1158
00:52:32,290 --> 00:52:33,730
characters here what if you use the

1159
00:52:33,730 --> 00:52:37,150
entire alphanumeric alphabet which has

1160
00:52:37,150 --> 00:52:39,010
six new characters if we can start using

1161
00:52:39,010 --> 00:52:42,160
these then we can represent this number

1162
00:52:42,160 --> 00:52:45,820
in a much shorter space with a lot less

1163
00:52:45,820 --> 00:52:50,320
characters problem with use in all of

1164
00:52:50,320 --> 00:52:51,940
these characters is some of them a bit

1165
00:52:51,940 --> 00:52:55,420
awkward type out you know like zeros and

1166
00:52:55,420 --> 00:52:56,410
all look the same

1167
00:52:56,410 --> 00:52:58,780
so we don't want to use those similarly

1168
00:52:58,780 --> 00:53:01,060
similarly an L and a big are you can

1169
00:53:01,060 --> 00:53:02,710
look the same so we don't wanna use

1170
00:53:02,710 --> 00:53:04,210
those either so if you just kick those

1171
00:53:04,210 --> 00:53:07,960
out we're left with 58 characters to

1172
00:53:07,960 --> 00:53:10,720
choose from so when you're encoding

1173
00:53:10,720 --> 00:53:13,359
numbers in a particular format and the

1174
00:53:13,359 --> 00:53:14,530
number of characters you have to choose

1175
00:53:14,530 --> 00:53:16,750
from is also known as the base so this

1176
00:53:16,750 --> 00:53:20,500
is base 16 and this is base 58 base 58

1177
00:53:20,500 --> 00:53:24,609
is just the alphanumeric alphabet our

1178
00:53:24,609 --> 00:53:28,150
characters with the awkward ones taken

1179
00:53:28,150 --> 00:53:30,970
out so what you do if you just take all

1180
00:53:30,970 --> 00:53:33,160
this data this public key with a check

1181
00:53:33,160 --> 00:53:35,830
sum at the end and you encode it in this

1182
00:53:35,830 --> 00:53:38,109
format using be a fifth base 58

1183
00:53:38,109 --> 00:53:39,790
characters you get something a little

1184
00:53:39,790 --> 00:53:41,680
bit shorter and a bit more slightly more

1185
00:53:41,680 --> 00:53:44,230
user-friendly but most importantly you

1186
00:53:44,230 --> 00:53:46,480
know it has this arrow tracking

1187
00:53:46,480 --> 00:53:48,670
capability and that's why you'll often

1188
00:53:48,670 --> 00:53:50,710
see addresses in this particular format

1189
00:53:50,710 --> 00:53:53,910
hopefully this looks a little familiar

1190
00:53:53,910 --> 00:53:56,310
so basically it's just basically eight

1191
00:53:56,310 --> 00:53:59,740
and this is what we call the address so

1192
00:53:59,740 --> 00:54:01,120
the address is just the pretty version

1193
00:54:01,120 --> 00:54:05,950
of this hashed public key there we are

1194
00:54:05,950 --> 00:54:08,410
so we give there so instead of given the

1195
00:54:08,410 --> 00:54:10,510
hashed version away we could give the

1196
00:54:10,510 --> 00:54:12,070
hashed version away away if we wanted to

1197
00:54:12,070 --> 00:54:14,950
that's perfectly fine but you know with

1198
00:54:14,950 --> 00:54:16,870
wallets these days everyone asked for an

1199
00:54:16,870 --> 00:54:19,270
address so you give the address away and

1200
00:54:19,270 --> 00:54:20,740
that means if they type it in and they

1201
00:54:20,740 --> 00:54:22,660
type it in wrong the wallet software can

1202
00:54:22,660 --> 00:54:24,340
say wait there something's not right so

1203
00:54:24,340 --> 00:54:26,290
it's more user-friendly it's used to use

1204
00:54:26,290 --> 00:54:32,380
this address or safer to do so just to

1205
00:54:32,380 --> 00:54:34,720
clarify you can easily go backwards and

1206
00:54:34,720 --> 00:54:36,910
forwards you know encode in a base 58

1207
00:54:36,910 --> 00:54:38,680
this isn't using any particular hash

1208
00:54:38,680 --> 00:54:40,450
function all it's doing it's just

1209
00:54:40,450 --> 00:54:42,550
converting from one number format to

1210
00:54:42,550 --> 00:54:44,860
another you know like converting from

1211
00:54:44,860 --> 00:54:49,600
decimal to hexadecimal that's one number

1212
00:54:49,600 --> 00:54:50,920
conversion but they're still seen the

1213
00:54:50,920 --> 00:54:52,360
number convicted they're still the same

1214
00:54:52,360 --> 00:54:54,430
number ultimately and you can go back

1215
00:54:54,430 --> 00:54:56,860
and forth between hexadecimal base 16

1216
00:54:56,860 --> 00:55:00,130
base 58 you can go back and 4 again so

1217
00:55:00,130 --> 00:55:02,050
what that means is when you do actually

1218
00:55:02,050 --> 00:55:05,860
give a address or type 1 into a wallet

1219
00:55:05,860 --> 00:55:07,480
while the wallet does when it creates

1220
00:55:07,480 --> 00:55:10,200
transaction it just works out what the

1221
00:55:10,200 --> 00:55:13,090
hash to public key is and then it'll put

1222
00:55:13,090 --> 00:55:16,000
that as the lock so even though you you

1223
00:55:16,000 --> 00:55:18,250
input a an address the wallet will

1224
00:55:18,250 --> 00:55:22,210
convert it to this and hashed version so

1225
00:55:22,210 --> 00:55:23,770
if you look at the blockchain there are

1226
00:55:23,770 --> 00:55:25,990
none aren't any actual addresses on the

1227
00:55:25,990 --> 00:55:30,310
blockchain in the locks at least it's

1228
00:55:30,310 --> 00:55:32,200
just the hashed version of the public

1229
00:55:32,200 --> 00:55:34,120
keys on the blockchain or inside the

1230
00:55:34,120 --> 00:55:41,280
transaction data so does that make sense

1231
00:55:41,280 --> 00:55:43,630
ok great

1232
00:55:43,630 --> 00:55:46,390
lastly some code examples so if all this

1233
00:55:46,390 --> 00:55:49,960
makes sense you understand how keys and

1234
00:55:49,960 --> 00:55:52,030
addresses work so you have the basic

1235
00:55:52,030 --> 00:55:53,980
private key and public key which is

1236
00:55:53,980 --> 00:55:56,470
basics needed for sending and receiving

1237
00:55:56,470 --> 00:55:59,170
transactions then you create digital

1238
00:55:59,170 --> 00:56:00,760
signatures so that we can prove they'll

1239
00:56:00,760 --> 00:56:02,590
be on a public key that the private key

1240
00:56:02,590 --> 00:56:04,920
is that while we can prove that we

1241
00:56:04,920 --> 00:56:06,610
created the public key

1242
00:56:06,610 --> 00:56:08,560
from a private key but I would actually

1243
00:56:08,560 --> 00:56:10,000
ever having to give away the private key

1244
00:56:10,000 --> 00:56:11,980
and that's how the transaction system

1245
00:56:11,980 --> 00:56:14,190
works creating digital signatures

1246
00:56:14,190 --> 00:56:21,540
finally we made a dress gone okay

1247
00:56:21,540 --> 00:56:26,770
actually all transaction data have

1248
00:56:26,770 --> 00:56:30,820
public keys and yes the address is just

1249
00:56:30,820 --> 00:56:32,830
like two of the the user-friendly top

1250
00:56:32,830 --> 00:56:35,800
layer but inside actual transactions or

1251
00:56:35,800 --> 00:56:37,330
they use is the public key and the

1252
00:56:37,330 --> 00:56:39,850
hashed public key the address is just

1253
00:56:39,850 --> 00:56:44,860
for user-friendly purposes so okay so if

1254
00:56:44,860 --> 00:56:45,970
you understand all that then you

1255
00:56:45,970 --> 00:56:47,460
understand how a keys and addresses work

1256
00:56:47,460 --> 00:56:50,650
in this final part now just went through

1257
00:56:50,650 --> 00:56:53,380
quite quickly not too complex just how

1258
00:56:53,380 --> 00:56:56,080
you can generate your own set of keys

1259
00:56:56,080 --> 00:56:58,870
and addresses I think this is quite fun

1260
00:56:58,870 --> 00:57:01,420
to do it's not terribly hard you know

1261
00:57:01,420 --> 00:57:04,210
take some coding but you can actually

1262
00:57:04,210 --> 00:57:06,880
easily create your own set of keys so

1263
00:57:06,880 --> 00:57:08,470
you can send and receive bitcoins and

1264
00:57:08,470 --> 00:57:09,790
it's quite a fun thing to do if you want

1265
00:57:09,790 --> 00:57:12,520
to get started working a Bitcoin so I'll

1266
00:57:12,520 --> 00:57:14,530
just show you now all the technical

1267
00:57:14,530 --> 00:57:16,480
stuff how to actually create your own

1268
00:57:16,480 --> 00:57:18,630
set of keys start with a private key so

1269
00:57:18,630 --> 00:57:21,580
let me just move this across make that

1270
00:57:21,580 --> 00:57:24,610
bit bigger so first of all let's see you

1271
00:57:24,610 --> 00:57:25,870
doing some programming and you want to

1272
00:57:25,870 --> 00:57:27,370
create your own statically generate your

1273
00:57:27,370 --> 00:57:29,710
own set of keys you first of all start

1274
00:57:29,710 --> 00:57:32,560
by generating a private key and if you

1275
00:57:32,560 --> 00:57:33,880
remember a private key just a random

1276
00:57:33,880 --> 00:57:36,550
number the most important thing we're

1277
00:57:36,550 --> 00:57:39,010
generating this random number is that

1278
00:57:39,010 --> 00:57:41,050
you use a secure source of randomness

1279
00:57:41,050 --> 00:57:43,620
this is the most important part by far

1280
00:57:43,620 --> 00:57:45,370
make sure it's secure

1281
00:57:45,370 --> 00:57:48,190
don't just use the standard random

1282
00:57:48,190 --> 00:57:50,590
number generators in your programming

1283
00:57:50,590 --> 00:57:52,270
language they're probably not secure

1284
00:57:52,270 --> 00:57:57,390
enough for this kind of stuff so good

1285
00:57:57,390 --> 00:57:59,740
sources of randomness as far as I'm

1286
00:57:59,740 --> 00:58:02,790
aware is using the open SSL library

1287
00:58:02,790 --> 00:58:04,930
every programming language so that

1288
00:58:04,930 --> 00:58:08,290
should have access to it or sorry or if

1289
00:58:08,290 --> 00:58:10,840
you're on Linux use dev read bytes from

1290
00:58:10,840 --> 00:58:12,580
dev you random that should be random

1291
00:58:12,580 --> 00:58:14,520
enough for you

1292
00:58:14,520 --> 00:58:17,440
alternatively if you just have a Googler

1293
00:58:17,440 --> 00:58:19,210
around for your programming language

1294
00:58:19,210 --> 00:58:21,450
there should be a library that gives you

1295
00:58:21,450 --> 00:58:24,010
quick and easy access to these two

1296
00:58:24,010 --> 00:58:27,700
things if they're available so in Ruby

1297
00:58:27,700 --> 00:58:31,540
it's called secure random not sure it is

1298
00:58:31,540 --> 00:58:33,430
in other languages but just have a look

1299
00:58:33,430 --> 00:58:36,130
around for the most secure source of

1300
00:58:36,130 --> 00:58:37,540
randomness in your programming language

1301
00:58:37,540 --> 00:58:41,560
it's very important so again okay so you

1302
00:58:41,560 --> 00:58:42,970
are secure a source of randomness you

1303
00:58:42,970 --> 00:58:46,030
need to generate a 256 bit number so

1304
00:58:46,030 --> 00:58:49,000
that's between one and a number that is

1305
00:58:49,000 --> 00:58:52,540
2 to the power of 256 which in decimal

1306
00:58:52,540 --> 00:58:59,349
is this but to be precise it's actually

1307
00:58:59,349 --> 00:59:02,530
the range of valid private keys is

1308
00:59:02,530 --> 00:59:04,810
slightly less than this and that's

1309
00:59:04,810 --> 00:59:06,460
because of the limitations of the

1310
00:59:06,460 --> 00:59:08,200
particular the particular curve used in

1311
00:59:08,200 --> 00:59:12,490
Bitcoin in this cave it has a parameter

1312
00:59:12,490 --> 00:59:14,170
called n which is just the number of

1313
00:59:14,170 --> 00:59:17,130
points on the curve and you cannot

1314
00:59:17,130 --> 00:59:19,710
exceed this for your private key and

1315
00:59:19,710 --> 00:59:23,349
it's only actually a little bit smaller

1316
00:59:23,349 --> 00:59:25,510
than 2 to the power of 256 it's very

1317
00:59:25,510 --> 00:59:28,329
close to it but just to be sure I don't

1318
00:59:28,329 --> 00:59:30,310
even see this number changing but this

1319
00:59:30,310 --> 00:59:36,430
is 2 2 power of 56 but this is the N or

1320
00:59:36,430 --> 00:59:38,170
the number of points on the curve so

1321
00:59:38,170 --> 00:59:40,000
make sure it's below this and if you

1322
00:59:40,000 --> 00:59:42,040
google around the name of the curve SEC

1323
00:59:42,040 --> 00:59:45,130
P 2 5 6 K 1 you can find the parameter

1324
00:59:45,130 --> 00:59:50,050
for n so there we are we just generate a

1325
00:59:50,050 --> 00:59:51,970
random number we can show us below this

1326
00:59:51,970 --> 00:59:54,940
maximum value here so that's the private

1327
00:59:54,940 --> 00:59:57,660
key done just generate a random number

1328
00:59:57,660 --> 01:00:00,490
secondly now we want to create the

1329
01:00:00,490 --> 01:00:02,859
public key we need to use the elliptic

1330
01:00:02,859 --> 01:00:08,680
curve this one and actually we do need

1331
01:00:08,680 --> 01:00:10,210
to do implicit elliptic curve

1332
01:00:10,210 --> 01:00:12,970
multiplication but actually in your

1333
01:00:12,970 --> 01:00:15,160
programming language there probably is a

1334
01:00:15,160 --> 01:00:17,410
library that gives you access to and if

1335
01:00:17,410 --> 01:00:20,020
to give stuff so you can just include

1336
01:00:20,020 --> 01:00:21,790
that in and just ask it to do some

1337
01:00:21,790 --> 01:00:24,339
implicit multiplication so you draft a

1338
01:00:24,339 --> 01:00:25,599
code in this for yourself you can just

1339
01:00:25,599 --> 01:00:26,710
get a librarian

1340
01:00:26,710 --> 01:00:29,619
do it for you so what you do is just to

1341
01:00:29,619 --> 01:00:32,349
indicate multiplication multiply this

1342
01:00:32,349 --> 01:00:36,580
generator point or this value and I'll

1343
01:00:36,580 --> 01:00:38,170
bounce on the cave and the final resting

1344
01:00:38,170 --> 01:00:41,619
point will be this public key and the

1345
01:00:41,619 --> 01:00:44,410
public key is the ax and y value at this

1346
01:00:44,410 --> 01:00:50,080
point obviously this public key is quite

1347
01:00:50,080 --> 01:00:53,200
large we've got to 256 bit numbers here

1348
01:00:53,200 --> 01:00:55,270
so that's gonna take up a lot of space

1349
01:00:55,270 --> 01:00:58,720
and ID be in Bitcoin because the

1350
01:00:58,720 --> 01:01:01,330
blockchain is a shared file we don't be

1351
01:01:01,330 --> 01:01:02,650
taking up too much space if we don't

1352
01:01:02,650 --> 01:01:04,450
have to so what we can do we can

1353
01:01:04,450 --> 01:01:05,470
actually shrink this number down a

1354
01:01:05,470 --> 01:01:08,550
little bit and we can do that because

1355
01:01:08,550 --> 01:01:10,750
one of the handy properties are this

1356
01:01:10,750 --> 01:01:13,030
elliptic curve is that it's symmetrical

1357
01:01:13,030 --> 01:01:15,490
along the x-axis so what that means is

1358
01:01:15,490 --> 01:01:17,800
if you have an x value then it's only

1359
01:01:17,800 --> 01:01:20,020
the Y value it's only gonna be one of

1360
01:01:20,020 --> 01:01:23,020
two different values so for every x

1361
01:01:23,020 --> 01:01:26,440
value there's only two given Y values so

1362
01:01:26,440 --> 01:01:29,040
you could think about being Y or minus y

1363
01:01:29,040 --> 01:01:35,320
and one of the handy properties of this

1364
01:01:35,320 --> 01:01:37,869
elliptic curve is that if this Y value

1365
01:01:37,869 --> 01:01:40,750
is even then it means it's it's one it's

1366
01:01:40,750 --> 01:01:42,369
one point on the curve say this one or

1367
01:01:42,369 --> 01:01:44,109
if it's odd it means it's the other

1368
01:01:44,109 --> 01:01:47,410
point on the curve so I mean when we

1369
01:01:47,410 --> 01:01:50,619
want to store this public key we don't

1370
01:01:50,619 --> 01:01:52,540
have to store the full Y value all we

1371
01:01:52,540 --> 01:01:54,750
need to know is whether it's even or odd

1372
01:01:54,750 --> 01:01:58,839
so this Y value here is even so all we

1373
01:01:58,839 --> 01:02:00,609
need to know just always full public key

1374
01:02:00,609 --> 01:02:02,980
is that it's even a name we can figure

1375
01:02:02,980 --> 01:02:05,020
out what it was from there based on the

1376
01:02:05,020 --> 01:02:09,040
x value so this is the x value and then

1377
01:02:09,040 --> 01:02:12,310
we can just put the whether the Y is

1378
01:02:12,310 --> 01:02:15,040
even or odd at the front obviously you

1379
01:02:15,040 --> 01:02:17,980
don't put the word even at the front or

1380
01:02:17,980 --> 01:02:20,020
odd there are two codes for that so if

1381
01:02:20,020 --> 01:02:22,540
it's e if it's even but o2 like so or if

1382
01:02:22,540 --> 01:02:27,210
it's odd over 3 and early on in Bitcoin

1383
01:02:27,210 --> 01:02:30,099
public keys were actually stored using

1384
01:02:30,099 --> 01:02:32,140
both the x and y value and these are

1385
01:02:32,140 --> 01:02:34,510
called uncompressed keys so this is a

1386
01:02:34,510 --> 01:02:36,070
compressed key because you don't use the

1387
01:02:36,070 --> 01:02:38,160
full y value because we don't need to

1388
01:02:38,160 --> 01:02:40,950
but this wasn't known by satoshi at the

1389
01:02:40,950 --> 01:02:44,299
start that you could compress them so a

1390
01:02:44,299 --> 01:02:47,299
lot of early on bit in any public keys

1391
01:02:47,299 --> 01:02:49,859
use the uncompressed format and if you

1392
01:02:49,859 --> 01:02:51,210
want to use number cut price for Matt

1393
01:02:51,210 --> 01:02:53,220
that'll start with over four zero four

1394
01:02:53,220 --> 01:02:57,029
sorry but this one zero two so there we

1395
01:02:57,029 --> 01:03:00,480
go that is the public key just in the X

1396
01:03:00,480 --> 01:03:06,720
x coordinate and whether the Y is even

1397
01:03:06,720 --> 01:03:08,549
or odd encoded as a zero two or zero

1398
01:03:08,549 --> 01:03:12,089
three don't need to convert all this tax

1399
01:03:12,089 --> 01:03:13,799
decimal i've been showing this in

1400
01:03:13,799 --> 01:03:15,240
numbers just to illustrate that this is

1401
01:03:15,240 --> 01:03:16,950
all just numbers but when you come to

1402
01:03:16,950 --> 01:03:20,549
look at private keys and public keys or

1403
01:03:20,549 --> 01:03:21,269
pass them around

1404
01:03:21,269 --> 01:03:23,819
they're usually stored in hexadecimal

1405
01:03:23,819 --> 01:03:27,900
format so there we go that's private key

1406
01:03:27,900 --> 01:03:30,509
is 32 bytes and this public key should

1407
01:03:30,509 --> 01:03:35,000
be future by it's also quick tip if this

1408
01:03:35,000 --> 01:03:37,829
public key it's quite a low number and

1409
01:03:37,829 --> 01:03:41,369
when you convert it into hexadecimal if

1410
01:03:41,369 --> 01:03:44,339
it's not 32 pipes in length make sure to

1411
01:03:44,339 --> 01:03:46,079
pad it out at the start with the zeros

1412
01:03:46,079 --> 01:03:49,319
to make sure the whole xx value part of

1413
01:03:49,319 --> 01:03:53,039
the public key is 32 bytes altogether so

1414
01:03:53,039 --> 01:03:57,420
just a quick tip otherwise you'll end up

1415
01:03:57,420 --> 01:04:02,210
creating an incorrect address later on

1416
01:04:03,230 --> 01:04:07,140
so okay that's the basics done private

1417
01:04:07,140 --> 01:04:10,200
key random number public key just

1418
01:04:10,200 --> 01:04:11,430
develop two key of multiplication and

1419
01:04:11,430 --> 01:04:14,069
store the Y value in a compressed format

1420
01:04:14,069 --> 01:04:15,329
we just need to know with it if it's

1421
01:04:15,329 --> 01:04:17,970
even or odd now we've got that we just

1422
01:04:17,970 --> 01:04:20,180
put that through two hash functions

1423
01:04:20,180 --> 01:04:23,609
because now you want the Hat to hash 160

1424
01:04:23,609 --> 01:04:26,220
of this to give a way to other people so

1425
01:04:26,220 --> 01:04:28,380
if we just put it through sha-256 first

1426
01:04:28,380 --> 01:04:32,369
then wipe mt 160 and that gives you this

1427
01:04:32,369 --> 01:04:33,809
digest this result

1428
01:04:33,809 --> 01:04:35,819
don't forget when you're hashing in

1429
01:04:35,819 --> 01:04:37,410
Bitcoin to configure this to binary

1430
01:04:37,410 --> 01:04:38,789
first before you put into the hash

1431
01:04:38,789 --> 01:04:41,130
function and a spirit of binary result

1432
01:04:41,130 --> 01:04:44,099
put that binary result into the next one

1433
01:04:44,099 --> 01:04:46,950
I'll spit up binary thank averted to

1434
01:04:46,950 --> 01:04:49,859
taxes a hexadecimal and this is that

1435
01:04:49,859 --> 01:04:51,190
gives you this hash one-sixth

1436
01:04:51,190 --> 01:04:56,020
here you might notice that this result

1437
01:04:56,020 --> 01:04:58,710
this digest is a bit smaller than these

1438
01:04:58,710 --> 01:05:01,710
32 byte public keys

1439
01:05:01,710 --> 01:05:05,920
that's because char 256 is 256 bits

1440
01:05:05,920 --> 01:05:10,599
produces 256 bit results which is 32

1441
01:05:10,599 --> 01:05:13,540
bytes but right the MT 160 produces

1442
01:05:13,540 --> 01:05:17,770
smaller results 160 bit digests which is

1443
01:05:17,770 --> 01:05:20,890
20 bytes so that's quite a bit smaller

1444
01:05:20,890 --> 01:05:26,349
like so fine okay

1445
01:05:26,349 --> 01:05:27,490
so this is what we give way to other

1446
01:05:27,490 --> 01:05:30,250
people this is the protected public key

1447
01:05:30,250 --> 01:05:32,530
if you will but now we want to create

1448
01:05:32,530 --> 01:05:34,540
the address which is like a prettier

1449
01:05:34,540 --> 01:05:35,710
version with some error checking

1450
01:05:35,710 --> 01:05:39,490
involved so what we do we need some base

1451
01:05:39,490 --> 01:05:43,119
58 this but before we do that we first

1452
01:05:43,119 --> 01:05:45,460
of all put a version byte at the start

1453
01:05:45,460 --> 01:05:48,520
which for most addresses is 0 0 I'll

1454
01:05:48,520 --> 01:05:50,400
explain why we do that in just a moment

1455
01:05:50,400 --> 01:05:53,050
and then like I said earlier we need a

1456
01:05:53,050 --> 01:05:55,720
checksum so we just hash all of this so

1457
01:05:55,720 --> 01:05:57,490
the public key with a version by at the

1458
01:05:57,490 --> 01:06:00,369
start hash at all here's the checksum

1459
01:06:00,369 --> 01:06:03,210
hash it twice you know like in mining

1460
01:06:03,210 --> 01:06:05,800
then we take the first four bytes last

1461
01:06:05,800 --> 01:06:07,240
to checksum that's all we need really to

1462
01:06:07,240 --> 01:06:09,640
be sure enough that this hash is

1463
01:06:09,640 --> 01:06:11,550
correctly for the error tracking and

1464
01:06:11,550 --> 01:06:14,410
then we put all that then through base

1465
01:06:14,410 --> 01:06:18,190
58 so public key well the hashed version

1466
01:06:18,190 --> 01:06:20,170
of it vision byte at the start check

1467
01:06:20,170 --> 01:06:21,640
them at the end stick it all through

1468
01:06:21,640 --> 01:06:23,920
base 58 and that would give us this

1469
01:06:23,920 --> 01:06:28,450
address the reason be append or prepend

1470
01:06:28,450 --> 01:06:29,109
sorry

1471
01:06:29,109 --> 01:06:31,270
this version byte at the start is

1472
01:06:31,270 --> 01:06:37,349
because it effects the leading character

1473
01:06:37,349 --> 01:06:40,300
of the address after weaving codes it in

1474
01:06:40,300 --> 01:06:44,730
base 58 format so for normal addresses

1475
01:06:44,730 --> 01:06:46,780
where we just want to send and receive

1476
01:06:46,780 --> 01:06:51,890
bitcoins in a typical way

1477
01:06:51,890 --> 01:06:53,840
we put zeros you at the start and that

1478
01:06:53,840 --> 01:06:55,310
gives us a one address so that means

1479
01:06:55,310 --> 01:06:56,540
that you just want to send and receive

1480
01:06:56,540 --> 01:07:00,170
bitcoins in typical way so if by

1481
01:07:00,170 --> 01:07:02,510
changing this version byte at the start

1482
01:07:02,510 --> 01:07:04,609
it changes the starting character of the

1483
01:07:04,609 --> 01:07:09,230
address so 0 0 is for typical sending or

1484
01:07:09,230 --> 01:07:11,330
receiving addresses on the on the main

1485
01:07:11,330 --> 01:07:13,880
net network but for test NAT so if

1486
01:07:13,880 --> 01:07:16,250
you're on a test net network you put 6 F

1487
01:07:16,250 --> 01:07:18,550
at the start and that will change the

1488
01:07:18,550 --> 01:07:21,500
leading character so there are quite a

1489
01:07:21,500 --> 01:07:23,390
few of these different version bytes of

1490
01:07:23,390 --> 01:07:24,940
the start to give you different

1491
01:07:24,940 --> 01:07:27,830
addresses but for most cases you're just

1492
01:07:27,830 --> 01:07:32,290
gonna use 0 0 to give you a 1 address

1493
01:07:32,380 --> 01:07:35,240
yes so I think I'll cover this a bit

1494
01:07:35,240 --> 01:07:39,740
more in the locking code or script video

1495
01:07:39,740 --> 01:07:42,430
which will be coming up after this one

1496
01:07:42,430 --> 01:07:44,990
but for most addresses just one stick

1497
01:07:44,990 --> 01:07:48,560
and zeros you at the start so there we

1498
01:07:48,560 --> 01:07:51,380
go that's how you create you can create

1499
01:07:51,380 --> 01:07:53,960
your own set of keys just through this

1500
01:07:53,960 --> 01:07:57,170
process here hopefully you all made some

1501
01:07:57,170 --> 01:08:02,480
sense or it's cleared up some issues so

1502
01:08:02,480 --> 01:08:05,740
there we go any questions about that

1503
01:08:08,010 --> 01:08:11,160
okay okay

1504
01:08:11,160 --> 01:08:12,690
just a quick question you mentioned

1505
01:08:12,690 --> 01:08:15,210
something about 32 bytes riding or some

1506
01:08:15,210 --> 01:08:22,560
yes okay okay um I probably do need to

1507
01:08:22,560 --> 01:08:25,560
mention that but when you private keys

1508
01:08:25,560 --> 01:08:26,460
and public keys

1509
01:08:26,460 --> 01:08:28,500
well this x coordinate is always 32

1510
01:08:28,500 --> 01:08:31,020
bytes and private keys or 32 bytes as

1511
01:08:31,020 --> 01:08:33,839
well and just a little tip that if you

1512
01:08:33,839 --> 01:08:36,000
when you do this lipstick you have

1513
01:08:36,000 --> 01:08:37,410
multiplication so you get a small number

1514
01:08:37,410 --> 01:08:39,299
for X and then you convert it to

1515
01:08:39,299 --> 01:08:41,370
hexadecimal then you might end up

1516
01:08:41,370 --> 01:08:44,399
getting a hexadecimal number that isn't

1517
01:08:44,399 --> 01:08:47,310
32 bytes long if that's the case just be

1518
01:08:47,310 --> 01:08:50,819
sure to pad it up and 0 to the start so

1519
01:08:50,819 --> 01:08:53,549
that the each X so the x coordinate is

1520
01:08:53,549 --> 01:08:56,520
the right length because that's

1521
01:08:56,520 --> 01:08:58,738
important because if you missed out a

1522
01:08:58,738 --> 01:09:00,270
character here that when they should

1523
01:09:00,270 --> 01:09:01,859
have been a zero there then this is

1524
01:09:01,859 --> 01:09:03,859
going to hash out to a different value

1525
01:09:03,859 --> 01:09:06,299
so you'll be sending bitcoins to the

1526
01:09:06,299 --> 01:09:08,700
wrong place so it's just I've made this

1527
01:09:08,700 --> 01:09:13,319
mistake before so I just wanted to bring

1528
01:09:13,319 --> 01:09:14,580
it up to make sure that no one else

1529
01:09:14,580 --> 01:09:18,649
makes the same mistake so there we go

1530
01:09:18,649 --> 01:09:23,270
and that's how to create your own

1531
01:09:23,270 --> 01:09:27,170
addresses and private keys and whatnot

1532
01:09:27,170 --> 01:09:35,370
so that's that part and my to know here

1533
01:09:35,370 --> 01:09:39,229
we go so I've made a little script here

1534
01:09:39,229 --> 01:09:42,479
it's written in Ruby and that will

1535
01:09:42,479 --> 01:09:45,359
create a set of keys tries to go through

1536
01:09:45,359 --> 01:09:47,160
an order it starts off by generating a

1537
01:09:47,160 --> 01:09:47,759
private key

1538
01:09:47,759 --> 01:09:50,520
just getting a secure random number the

1539
01:09:50,520 --> 01:09:52,170
maximum is this value here which is n

1540
01:09:52,170 --> 01:09:54,120
like I said earlier which is the number

1541
01:09:54,120 --> 01:09:56,100
of points on the curve so if asked to

1542
01:09:56,100 --> 01:09:59,040
big I'll just raise an error so that

1543
01:09:59,040 --> 01:10:01,790
generates a private key

1544
01:10:01,790 --> 01:10:04,110
after that he need to go from the

1545
01:10:04,110 --> 01:10:06,690
private to the public so we just use the

1546
01:10:06,690 --> 01:10:09,480
elliptic curve you do his ed up to give

1547
01:10:09,480 --> 01:10:11,639
multiplication

1548
01:10:11,639 --> 01:10:14,310
and then you that give you an x and y

1549
01:10:14,310 --> 01:10:17,690
value so in the old format it's just the

1550
01:10:17,690 --> 01:10:21,360
x and y but a new format if want to

1551
01:10:21,360 --> 01:10:22,619
compress the public key

1552
01:10:22,619 --> 01:10:25,349
you just take whether Y is even or odd

1553
01:10:25,349 --> 01:10:28,170
and then / - no - or no three at the

1554
01:10:28,170 --> 01:10:32,400
start based on that after the public key

1555
01:10:32,400 --> 01:10:33,840
you only get the hash 160 it's quite

1556
01:10:33,840 --> 01:10:36,150
simple just put it through two different

1557
01:10:36,150 --> 01:10:39,329
hashing functions so sha 256 and then

1558
01:10:39,329 --> 01:10:43,760
wipe MD 160 and then to get the address

1559
01:10:43,760 --> 01:10:47,429
you stick a prefix of the start create a

1560
01:10:47,429 --> 01:10:53,790
checksum by hashing the hash 160 and

1561
01:10:53,790 --> 01:10:55,349
then the address is just all about

1562
01:10:55,349 --> 01:10:58,710
encoded in base 58 so if you have some

1563
01:10:58,710 --> 01:11:00,659
utility functions like the base 58 and

1564
01:11:00,659 --> 01:11:04,380
stuff and there we are so here's the

1565
01:11:04,380 --> 01:11:07,530
code you just run Ruby key generator

1566
01:11:07,530 --> 01:11:09,060
I'll put this code on the website or a

1567
01:11:09,060 --> 01:11:11,070
link in the description and this will

1568
01:11:11,070 --> 01:11:14,159
give you a set of keys as you can see

1569
01:11:14,159 --> 01:11:16,139
it's quite fast so even though we did

1570
01:11:16,139 --> 01:11:18,389
all this you know crazy elliptic curve

1571
01:11:18,389 --> 01:11:21,210
multiplication when you run the code

1572
01:11:21,210 --> 01:11:24,360
it's pretty fast to give you you know

1573
01:11:24,360 --> 01:11:32,750
your psyches so just to prove to you um

1574
01:11:32,750 --> 01:11:37,619
here's an address I can send some

1575
01:11:37,619 --> 01:11:40,650
bitcoins there's a debt this address may

1576
01:11:40,650 --> 01:11:42,810
be our nest and the base description

1577
01:11:42,810 --> 01:11:54,860
sorry me not just for just to show up

1578
01:11:54,860 --> 01:11:59,300
send a low fee send

1579
01:12:01,230 --> 01:12:04,630
okay so the paper has been sent so copy

1580
01:12:04,630 --> 01:12:13,870
that I'm sorry maybe our browser send

1581
01:12:13,870 --> 01:12:16,620
the transaction look at the transaction

1582
01:12:16,620 --> 01:12:18,130
right there it is

1583
01:12:18,130 --> 01:12:23,199
so Wendy 9 that's the address I sent it

1584
01:12:23,199 --> 01:12:28,980
to so like I said earlier remember how

1585
01:12:28,980 --> 01:12:31,480
the electrum Wallace took care of my

1586
01:12:31,480 --> 01:12:33,880
change form for me and it sent it to a

1587
01:12:33,880 --> 01:12:35,889
different address like here so the

1588
01:12:35,889 --> 01:12:42,699
public here is protected okay a few

1589
01:12:42,699 --> 01:12:47,290
quick tips just before I go and this is

1590
01:12:47,290 --> 01:12:51,460
a very good graphical address generator

1591
01:12:51,460 --> 01:12:53,590
that shows you all the steps you need to

1592
01:12:53,590 --> 01:12:56,380
do to generate your own addresses if you

1593
01:12:56,380 --> 01:13:00,730
go on the Royal Fork blog Google that

1594
01:13:00,730 --> 01:13:03,219
cool and gone to the graphical address

1595
01:13:03,219 --> 01:13:05,320
general address generator it's very good

1596
01:13:05,320 --> 01:13:07,090
so if you're programming and you want to

1597
01:13:07,090 --> 01:13:08,230
create your own set of keys and

1598
01:13:08,230 --> 01:13:11,020
addresses this is very very helpful

1599
01:13:11,020 --> 01:13:14,100
it's helped me a lot it's very good

1600
01:13:14,100 --> 01:13:17,980
secondly and preset about you've got all

1601
01:13:17,980 --> 01:13:20,679
those different caves and you know the

1602
01:13:20,679 --> 01:13:24,820
SEC p25 6k one well they're all outlined

1603
01:13:24,820 --> 01:13:29,830
on the SEC website so here's a I put a

1604
01:13:29,830 --> 01:13:30,610
link in the description

1605
01:13:30,610 --> 01:13:38,800
here's the you are so here's the

1606
01:13:38,800 --> 01:13:40,719
parameters for that cave so you have

1607
01:13:40,719 --> 01:13:42,850
lots different caves but this is just

1608
01:13:42,850 --> 01:13:46,650
the one that Bitcoin uses that one so

1609
01:13:46,650 --> 01:13:50,130
yep there we go

1610
01:13:51,409 --> 01:13:56,809
one last thing don't forget for these

1611
01:13:56,809 --> 01:13:57,709
private keys

1612
01:13:57,709 --> 01:13:59,209
you also have lost like an address

1613
01:13:59,209 --> 01:14:00,530
version like a pretty version the

1614
01:14:00,530 --> 01:14:02,090
private key which is called wallet

1615
01:14:02,090 --> 01:14:03,829
import format I haven't covered it here

1616
01:14:03,829 --> 01:14:06,649
but it's very similar to this process

1617
01:14:06,649 --> 01:14:07,969
for getting a pretty version at the

1618
01:14:07,969 --> 01:14:10,699
public key so if you ever see wallet

1619
01:14:10,699 --> 01:14:12,499
import format it's just the pretty

1620
01:14:12,499 --> 01:14:18,729
version of the private key any questions

1621
01:14:21,789 --> 01:14:23,780
I'm glad it all made sense

1622
01:14:23,780 --> 01:14:28,159
I tried to make it as a flowing as

1623
01:14:28,159 --> 01:14:29,389
possible because it's quite a lot I

1624
01:14:29,389 --> 01:14:30,679
thought with the elliptic curves and

1625
01:14:30,679 --> 01:14:32,929
stuff to include that I don't cover how

1626
01:14:32,929 --> 01:14:35,510
that all works I just wanted to cover

1627
01:14:35,510 --> 01:14:41,530
the basics of keys what are you yeah and

1628
01:14:42,159 --> 01:14:45,050
yeah yeah no I felt like that I felt

1629
01:14:45,050 --> 01:14:46,219
that as well when I was doing the video

1630
01:14:46,219 --> 01:14:47,479
I was like oh god this is quite a lot of

1631
01:14:47,479 --> 01:14:49,729
information it's hard to you know do

1632
01:14:49,729 --> 01:14:51,309
it's hard to take it all in one sitting

1633
01:14:51,309 --> 01:15:01,669
but maybe if you want to learn yeah yeah

1634
01:15:01,669 --> 01:15:03,619
it's just numbers I think if you just

1635
01:15:03,619 --> 01:15:05,329
went through this process of creating

1636
01:15:05,329 --> 01:15:06,859
your own set of keys I think you'd learn

1637
01:15:06,859 --> 01:15:08,419
everything as you went along but

1638
01:15:08,419 --> 01:15:11,749
hopefully this gives you a primer to get

1639
01:15:11,749 --> 01:15:15,789
going I suppose and create them

