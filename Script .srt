00:00:00,030 --> 00:00:02,820
这个视频是关于脚本的，

00:00:02,820 --> 00:00:09,240
脚本就像是在比特币中用来锁定你的比特币的迷你编程语言。

00:00:09,240 --> 00:00:15,000
当你要给别人发送比特币时，

00:00:15,000 --> 00:00:19,920
你实际上在这些比特币上面加了一个小型的编程语言来锁定它们。

00:00:19,920 --> 00:00:21,990
然后当他们要解锁它们时，

00:00:21,990 --> 00:00:24,420
他们需要提供一些更多的代码，

00:00:24,420 --> 00:00:26,849
当它与原始的锁定代码一起运行时，

00:00:30,080 --> 00:00:32,640
它将开始工作，这些比特币就可以被花费了。

00:00:32,640 --> 00:00:38,969
这就是脚本。

00:00:38,969 --> 00:00:43,860
让我们从上次的演示中继续，

00:00:43,860 --> 00:00:46,829
假设这是一批比特币，

00:00:46,829 --> 00:00:53,780
世界上存在的每一批比特币都有一个锁。

00:00:53,780 --> 00:00:56,430
当你想要进行交易时，

00:00:56,430 --> 00:01:00,090
你会解锁那批比特币，

00:01:00,090 --> 00:01:02,340
从中创建一批新的比特币，

00:01:02,340 --> 00:01:04,589
并在上面放一个新的锁，

00:01:04,589 --> 00:01:07,860
这就是一个简单的交易，

00:01:07,860 --> 00:01:09,900
就是取出一批比特币，

00:01:09,900 --> 00:01:11,880
解锁它们，创建新的批次并锁定它们。

00:01:11,880 --> 00:01:15,119
当你要进行新的交易时，

00:01:15,119 --> 00:01:18,330
你就再次做同样的事情，

00:01:18,330 --> 00:01:20,640
你只是解锁一个现有的批次，

00:01:20,640 --> 00:01:22,799
创建一个新的批次，

00:01:22,799 --> 00:01:25,140
并在上面放一个新的锁，

00:01:25,140 --> 00:01:27,990
这就是比特币交易系统的工作原理。

00:01:27,990 --> 00:01:31,170
这是一个简化的一系列交易，

00:01:31,170 --> 00:01:35,369
如果你想了解更多关于交易如何进行的信息，

00:01:35,369 --> 00:01:38,610
请观看我之前做的关于交易的视频。

00:01:38,610 --> 00:01:45,689
但这只涵盖了比特币批次的基本移动。

00:01:45,689 --> 00:01:51,810
所以这意味着，当你想要给别人发送比特币时，

00:01:51,810 --> 00:01:55,560
你需要取出一批你可以解锁的比特币。

00:01:55,560 --> 00:02:00,000
比如说这是你，这是一批只有你可以解锁的比特币

00:02:00,000 --> 00:02:02,219
我过一会儿会解释这是如何工作的，

00:02:02,219 --> 00:02:04,649
但现在请相信我，

00:02:04,649 --> 00:02:05,939
你是唯一可以解锁这批比特币的人。

00:02:05,939 --> 00:02:08,459
这就是你要做的，

00:02:08,459 --> 00:02:10,190
你想要给某人发送一些比特币。

00:02:10,190 --> 00:02:15,629
这个方法的工作原理是，

00:02:15,629 --> 00:02:17,250
你会创建一批带有锁的比特币。

00:02:17,250 --> 00:02:19,160
只有这个人可以解锁，

00:02:19,160 --> 00:02:25,709
这是因为在比特币中，

00:02:25,709 --> 00:02:28,620
每个人都有自己的私钥和公钥，

00:02:28,620 --> 00:02:33,180
这就像每个人都有自己的密码和账号一样。

00:02:33,180 --> 00:02:34,590
当你想要给某人发送比特币时，

00:02:37,980 --> 00:02:41,010
他们会给你他们的公钥，

00:02:41,010 --> 00:02:43,799
你将创建一个交易，

00:02:43,799 --> 00:02:46,769
并锁定一些你拥有的比特币，

00:02:46,769 --> 00:02:48,930
创建一批新的比特币，

00:02:48,930 --> 00:02:53,599
然后在这批比特币的锁上放置他们的公钥。

00:02:53,599 --> 00:02:56,519
这就是为什么这个人拥有这批比特币的原因，

00:02:56,519 --> 00:03:02,280
因为这批比特币的锁上包含了他们的公钥，

00:03:02,280 --> 00:03:07,230
这是他们的唯一账号。

00:03:07,230 --> 00:03:14,280
如果他们想要花费这批比特币或者发送给其他人，

00:03:14,280 --> 00:03:17,130
他们将使用他们的私钥，

00:03:17,130 --> 00:03:21,959
就像他们的账号的密码一样，来解锁它。

00:03:21,959 --> 00:03:24,630
他们会从私钥创建一个签名，

00:03:26,430 --> 00:03:30,299
这就像一个一次性密码。

00:03:30,299 --> 00:03:36,389
任何人看到这个签名和这个公钥，

00:03:36,389 --> 00:03:44,940
都能够确定这个签名只能由拥有这个公钥的私钥的人创建。

00:03:44,940 --> 00:03:51,889
没有人能够创建一个能够与这个公钥特定匹配的签名。

00:03:51,889 --> 00:03:57,630
我在密钥和地址的视频中介绍了如何进行这个操作，

00:03:57,630 --> 00:04:02,940
但在这个视频，我只会介绍锁定机制，

00:04:02,940 --> 00:04:05,790
如果你对这些签名、私钥、公钥的来源以及工作原理感兴趣，

00:04:05,790 --> 00:04:07,860
可以观看那个视频。

00:04:07,860 --> 00:04:10,550
在常规交易中，

00:04:10,550 --> 00:04:13,260
比特币被锁定到一个公钥，

00:04:13,260 --> 00:04:14,970
然后当你想要解锁它们时，

00:04:14,970 --> 00:04:18,029
你提供一个签名来解锁它们，

00:04:18,029 --> 00:04:20,430
以证明你是这个公钥的所有者，

00:04:20,430 --> 00:04:25,920
因为你拥有从这个公钥创建的私钥。

00:04:25,920 --> 00:04:26,430
任何人都可以查看签名，

00:04:27,510 --> 00:04:30,150
与公钥进行对比，看到它们匹配，

00:04:30,150 --> 00:04:32,820
如果它们匹配，

00:04:32,820 --> 00:04:37,890
然后这些比特币可以被解锁并在新的交易中使用，

00:04:37,890 --> 00:04:39,560
它们可以被发送给其他人。

00:04:39,560 --> 00:04:45,240
显然，这批比特币将包含别人的公钥，

00:04:45,240 --> 00:04:49,110
这就是使用这些公钥和签名进行交易的方式。

00:04:52,770 --> 00:04:55,050
所以在这个视频中，就像我说的，

00:04:55,050 --> 00:04:57,600
我不会涉及交易和这些密钥是如何工作的。

00:04:57,600 --> 00:05:05,640
我只会关注锁定代码和解锁代码是如何交互的。

00:05:05,640 --> 00:05:07,950
这里有一个锁定机制，我们会在基础知识中介绍，

00:05:07,950 --> 00:05:12,870
你会发现这只是一个小型的编程语言坐在这些锁里，

00:05:12,870 --> 00:05:19,080
同样的事情再次出现在解锁代码里。

00:05:19,080 --> 00:05:23,580
实际上有很多不同的，

00:05:23,580 --> 00:05:27,570
因为这是一个位于这些锁内的编程语言，

00:05:27,570 --> 00:05:28,740
你可以创建不同类型的锁。

00:05:28,740 --> 00:05:34,950
我会介绍每种最常见的锁的工作原理，

00:05:34,950 --> 00:05:38,010
这是P2PK，

00:05:38,010 --> 00:05:39,870
这是最常见、最简单的锁定比特币的方式，

00:05:39,870 --> 00:05:41,510
对于锁定比特币很重要，

00:05:41,510 --> 00:05:44,130
还有P2PKH，

00:05:44,130 --> 00:05:45,600
这非常相似，但稍微复杂一些，

00:05:45,600 --> 00:05:46,740
这是现在最常见的比特币锁定。

00:05:49,740 --> 00:05:55,980
然后是P2MS，和P2SH，

00:05:55,980 --> 00:06:00,630
这些是你可以放在比特币批次上的最常见类型的锁。

00:06:00,630 --> 00:06:03,810
最后我会用一些代码和例子来结束，

00:06:03,810 --> 00:06:06,000
向你展示实际的脚本运行，

00:06:06,000 --> 00:06:08,270
向你展示它是多么简单。

00:06:08,270 --> 00:06:10,090
但在这个演示结束时，

00:06:10,090 --> 00:06:16,430
希望你你会熟悉所有这些不同的术语，

00:06:16,430 --> 00:06:18,500
如果你在研究比特币，

00:06:18,500 --> 00:06:19,700
你可能已经碰到了其中一些术语。

00:06:19,700 --> 00:06:33,620
但最终，如果你理解了基础的脚本是一种迷你编程语言，

00:06:33,620 --> 00:06:36,250
所以，到目前为止有任何问题吗？

00:06:36,610 --> 00:06:40,190
首先是基础知识，

00:06:40,190 --> 00:06:44,170
这两部分的锁是如何互动的呢？

00:06:44,170 --> 00:06:47,870
到现在为止，

00:06:47,870 --> 00:06:56,660
我一直使用这个小锁符号来说明放在比特币批次上的锁。

00:06:56,660 --> 00:07:01,580
这只是一些包含一个叫做脚本的迷你编程语言的代码。

00:07:01,580 --> 00:07:09,350
我们称这个锁住一批比特币的代码为锁定脚本。

00:07:09,350 --> 00:07:15,410
这个锁定脚本被放在这个第一笔交易的输出上，

00:07:15,410 --> 00:07:18,230
当这些比特币被创建或者输出被创建的时候。

00:07:20,630 --> 00:07:24,530
然后在你想要解锁这批比特币并从中创建新的批次时，

00:07:24,530 --> 00:07:30,230
你需要提供一些额外的代码来匹配这个锁定脚本，

00:07:30,230 --> 00:07:38,840
这就叫做解锁脚本。

00:07:38,840 --> 00:07:47,420
这个锁定部分通常被称为脚本公钥，

00:07:47,420 --> 00:07:49,220
因为它通常包含一个公钥，

00:07:49,220 --> 00:07:52,220
并且显然是一个脚本。

00:07:52,220 --> 00:07:53,900
这个解锁脚本有时被称为脚本签名，

00:07:53,900 --> 00:07:55,490
因为它也是一个脚本，

00:07:55,490 --> 00:07:59,360
并且通常包含一个签名。

00:07:59,360 --> 00:08:01,490
但是在这个视频中，

00:08:01,490 --> 00:08:03,890
我会坚持称它们锁定脚本和解锁脚本，

00:08:03,890 --> 00:08:07,280
因为我认为它们更具描述性，

00:08:07,280 --> 00:08:09,560
而且并不是所有的脚本公钥都需要包含一个公钥，

00:08:09,560 --> 00:08:11,450
也不是所有的解锁脚本都需要包含一个签名。

00:08:11,450 --> 00:08:18,020
我更喜欢更通用和多功能的使用锁定脚本和解锁脚本这两个术语。

00:08:18,020 --> 00:08:22,310
这就是这些脚本的基础知识。

00:08:22,310 --> 00:08:26,060
那么它是如何交互的呢？

00:08:26,060 --> 00:08:34,969
我们在这个小型编程语言中可以使用的是这些叫做操作码的东西，

00:08:34,969 --> 00:08:41,029
它们就像是内置在脚本语言中的小型函数。

00:08:41,029 --> 00:08:46,130
对于特定类型的锁定有好处，

00:08:46,130 --> 00:08:48,800
我们称它为CHECKSIG。

00:08:48,800 --> 00:08:50,510
我们将其放入锁定脚本中。

00:08:50,510 --> 00:08:54,709
现在我们有了一个完整的脚本，

00:08:54,709 --> 00:08:57,589
包括锁定部分和解锁部分。

00:08:57,589 --> 00:09:04,880
这个特定的函数将会检查一个签名与公钥是否匹配。

00:09:04,880 --> 00:09:10,640
你可能猜到了这种脚本将如何运行和验证。

00:09:10,640 --> 00:09:13,399
就像我说的，每个脚本只包含一些数据，

00:09:13,399 --> 00:09:16,550
比如这里的公钥和签名，

00:09:16,550 --> 00:09:19,130
以及一些操作符或操作码，

00:09:19,130 --> 00:09:21,709
这就是脚本的全部内容，

00:09:21,709 --> 00:09:28,490
只有一些数据和一些被称为操作码的函数。

00:09:28,490 --> 00:09:33,140
当你试图将这个交易插入到比特币网络，

00:09:33,140 --> 00:09:36,050
或者说任何一个节点中时，

00:09:36,050 --> 00:09:38,959
他们会接收这个完整的脚本。

00:09:38,959 --> 00:09:43,820
他们会接收最初放在输出上的锁定脚本，

00:09:43,820 --> 00:09:50,649
然后他们会接收你提供的解锁脚本并运行整个脚本以确保它验证通过。

00:09:50,649 --> 00:09:53,450
如果验证通过，

00:09:53,450 --> 00:09:55,640
那么这个交易就是有效的，

00:09:55,640 --> 00:09:57,470
可以添加到区块链中，或者说他们会接受它，

00:09:57,470 --> 00:09:59,720
并将其转发给其他节点

00:09:59,720 --> 00:10:02,480
甚至是矿工，

00:10:02,480 --> 00:10:03,950
他们有可能将其挖掘到区块链上。

00:10:03,950 --> 00:10:11,450
如果你创建了一个更复杂的交易，

00:10:11,450 --> 00:10:16,279
你选择了许多不同的输出作为这个交易的输入，

00:10:16,279 --> 00:10:18,920
每一个都会有自己的锁定脚本，

00:10:18,920 --> 00:10:26,029
所以你需要为每一个提供解锁脚本，

00:10:26,029 --> 00:10:30,410
每一个解锁脚本也必须对整个交易有效，

00:10:30,410 --> 00:10:32,690
整个交易才能被网络上的节点接受。

00:10:32,690 --> 00:10:39,740
这就是脚本的基础，

00:10:39,740 --> 00:10:41,180
它只是一些数据和一些函数。

00:10:41,180 --> 00:10:45,829
这是如何运行的呢？

00:10:45,829 --> 00:10:47,779
就像我说的那样，

00:10:47,779 --> 00:10:49,579
你可能会猜到它是如何运行，

00:10:49,579 --> 00:10:53,959
我将介绍节点如何运行整个脚本的步骤。

00:10:53,959 --> 00:10:58,819
我有个小问题，

00:10:58,819 --> 00:11:03,110
解锁脚本是交易的一部分，

00:11:03,110 --> 00:11:05,930
而我们所说的锁定脚本，

00:11:05,930 --> 00:11:12,290
实际上就是数字签名。

00:11:12,290 --> 00:11:13,610
你提到的解锁脚本，

00:11:13,610 --> 00:11:20,180
实际上是由花费比特币的人创建的。

00:11:20,180 --> 00:11:23,329
谢谢你的回答，

00:11:23,329 --> 00:11:25,569
在第一个交易中，

00:11:25,569 --> 00:11:29,810
某人会设置这个锁定代码。

00:11:29,810 --> 00:11:31,279
这个人就会进行这笔交易，

00:11:31,279 --> 00:11:33,079
并将解锁代码放在这里

00:11:33,079 --> 00:11:37,970
当他来解锁它时，

00:11:37,970 --> 00:11:41,660
他们只需要引用这批比特币，

00:11:41,660 --> 00:11:43,490
并将解锁代码输入到这个交易中。

00:11:43,490 --> 00:11:57,759
整个脚本实际上是分布在两个不同的交易中。

00:11:57,759 --> 00:12:04,610
这个新的锁定脚本会被放在这个交易的顶部。

00:12:04,610 --> 00:12:08,480
这有点复杂，

00:12:08,480 --> 00:12:13,610
因为锁定部分和解锁部分实际上是在两个不同的交易中。

00:12:13,610 --> 00:12:15,410
所以如果你看这一笔交易，

00:12:15,410 --> 00:12:17,380
实际上不会有一整个脚本来一起运行，

00:12:17,380 --> 00:12:21,829
它可能稍后在运行，

00:12:21,829 --> 00:12:24,579
据我所知，解锁脚本，

00:12:24,579 --> 00:12:28,370
就是那个红色的波浪，

00:12:28,370 --> 00:12:32,430
它将是黄色交易的一部分，

00:12:32,430 --> 00:12:40,279
在这个特定的交易中

00:12:40,279 --> 00:12:48,060
在交易数据中有输入和输出，

00:12:48,060 --> 00:12:54,060
对于每个输入，

00:12:54,060 --> 00:12:58,110
我们实际上并没有看到或输入这个锁定代码，

00:12:58,110 --> 00:13:03,200
我们所做的就是为我们选择的每个输入应用或输入一个锁定代码。

00:13:03,200 --> 00:13:08,760
即使我已经把锁定代码放在这里，

00:13:08,760 --> 00:13:12,570
实际上不会看到它们。

00:13:12,570 --> 00:13:13,830
然后在交易的第二部分，我们创建输出时，

00:13:13,830 --> 00:13:21,390
我们将在这里放一些新的锁定代码，

00:13:21,390 --> 00:13:23,430
无论我们想要什么样的锁。

00:13:23,430 --> 00:13:26,010
输入有解锁代码，

00:13:26,010 --> 00:13:29,790
输出有锁定代码。

00:13:29,790 --> 00:13:33,390
我想当我在最后展示交易数据时，

00:13:33,390 --> 00:13:34,320
你可能会更能理解。

00:13:34,320 --> 00:13:35,700
这有点令人困惑，

00:13:35,700 --> 00:13:36,990
因为我把这个锁定代码放在这里，

00:13:36,990 --> 00:13:39,120
但在这个交易中，

00:13:39,120 --> 00:13:40,350
你实际上不会看到锁定代码，

00:13:40,350 --> 00:13:42,470
我们只知道它在那里，

00:13:42,470 --> 00:13:45,029
所以我们只是在这里引用它，

00:13:45,029 --> 00:13:50,070
我现在继续运行这个完整脚本的内容。

00:13:50,070 --> 00:13:55,350
当一个节点接收到一个交易时，

00:13:55,350 --> 00:13:56,880
他们会有解锁代码，

00:13:56,880 --> 00:14:01,050
并且他们有对之前有锁定代码的输出的引用，

00:14:01,050 --> 00:14:06,140
它们将获取整个内容并一起运行，

00:14:06,140 --> 00:14:13,470
节点如何运行这两部分脚本来确保这批比特币可以被解锁和花费呢?

00:14:13,470 --> 00:14:16,890
他们会把这个解锁代码，

00:14:16,890 --> 00:14:25,079
它是在这个二级交易中提供的，

00:14:25,079 --> 00:14:28,230
将其放在锁定代码的前面，

00:14:28,230 --> 00:14:31,649
像这样，

00:14:31,649 --> 00:14:37,149
然后他们将从左到右运行这个脚本。

00:14:37,149 --> 00:14:43,180
他们运行这个代码的方式是使用一个叫做栈的数据结构，

00:14:43,180 --> 00:14:43,930
如果你之前做过任何编程，

00:14:43,930 --> 00:14:46,390
栈就是一个简单的数据结构，

00:14:46,390 --> 00:14:49,029
它很像一个数组，

00:14:49,029 --> 00:14:57,730
我们只是在栈顶或数组的末尾推入和弹出元素

00:14:57,730 --> 00:14:59,170
我们有这个脚本，一堆数据和函数，

00:14:59,170 --> 00:15:02,399
它们都在栈顶上运行。

00:15:02,399 --> 00:15:09,040
所以我们现在会用这个栈从左到右运行这个脚本。

00:15:09,040 --> 00:15:10,660
首先，当我们从左到右进行时，

00:15:10,660 --> 00:15:13,510
我们遇到了一些数据，签名，

00:15:13,510 --> 00:15:18,640
你在脚本中遇到的任何数据都会被推入栈顶，

00:15:18,640 --> 00:15:23,589
所以这个签名再次被推入了栈顶。

00:15:23,589 --> 00:15:25,690
我们遇到了一个公钥，

00:15:25,690 --> 00:15:27,490
这只是更多的数据，

00:15:27,490 --> 00:15:30,910
它也会被推入栈顶。

00:15:30,910 --> 00:15:34,269
最后，我们遇到了一个操作码，

00:15:34,269 --> 00:15:35,860
操作码与数据的操作方式有些不同。

00:15:35,860 --> 00:15:38,140
数据只是被推入栈顶，

00:15:38,140 --> 00:15:41,890
而操作码可以做什么呢？

00:15:41,890 --> 00:15:46,209
它会从栈顶弹出一个或多个项目，

00:15:46,209 --> 00:15:48,370
对它们执行某些操作后，

00:15:48,370 --> 00:15:52,810
它可以选择性地在堆栈顶部推回项目，

00:15:52,810 --> 00:15:54,790
在处理这些项目之后，

00:15:54,790 --> 00:15:58,660
我们会使用CHECKSIG，

00:15:58,660 --> 00:16:03,910
它会从堆栈顶部弹出两个项目。

00:16:03,910 --> 00:16:06,310
这里，它弹出了公钥和签名，

00:16:06,310 --> 00:16:08,410
然后它会对这两个项目做一些处理。

00:16:08,410 --> 00:16:12,160
CHECKSIG会检查这个签名是否匹配这个公钥，

00:16:12,160 --> 00:16:19,600 
或者这个签名是否是这个特定公钥的有效签名。

00:16:19,600 --> 00:16:21,610
如果你想了解这个过程，你就可以去看看关于密钥和地址的视频。

00:16:21,610 --> 00:16:22,959
你就可以去看看关于密钥和地址的视频。

00:16:22,959 --> 00:16:25,180
但是这个例子，

00:16:25,180 --> 00:16:30,790
让我们假设这个签名是这个公钥的有效签名。

00:16:30,790 --> 00:16:34,779
在CHECKSIG操作完成后

00:16:34,779 --> 00:16:37,959
如果这个签名是有效的，

00:16:37,959 --> 00:16:42,290
它会把1推到堆栈的顶部。

00:16:42,290 --> 00:16:44,269
或将数字1推到堆栈的顶部。

00:16:44,269 --> 00:16:46,249
这个脚本就被完全执行了。

00:16:46,249 --> 00:16:53,089
那么什么使这个脚本是有效的呢，

00:16:53,089 --> 00:16:55,639
或者说一批比特币可以被花费吗？

00:16:55,639 --> 00:16:58,730
如果在运行整个脚本后，

00:16:58,730 --> 00:17:02,540
堆栈顶部留下了一个1，

00:17:02,540 --> 00:17:05,209
那么这就意味着这个脚本是有效的，

00:17:05,209 --> 00:17:08,209
这批比特币可以被花费。

00:17:08,209 --> 00:17:12,260
如果在脚本运行后，

00:17:12,260 --> 00:17:15,619
堆栈为空，则它无效，

00:17:15,619 --> 00:17:21,679
如果在整个脚本运行后堆栈顶部留下零，

00:17:21,679 --> 00:17:25,849
那么脚本同样无效。

00:17:25,849 --> 00:17:28,580
因此在这最后一个示例中，

00:17:28,580 --> 00:17:30,020
如果这个检查签名没有正确执行，

00:17:30,020 --> 00:17:34,340
我认为它会将零或者什么都不推到堆栈顶部，

00:17:34,340 --> 00:17:36,740
可能是零，堆栈就会被判定为无效。

00:17:36,740 --> 00:17:38,720
但在这个示例中，

00:17:38,720 --> 00:17:41,090
签名与公钥匹配，

00:17:41,090 --> 00:17:42,649
检查签名操作码执行所有这些操作，

00:17:42,649 --> 00:17:45,380
如果正确，

00:17:45,380 --> 00:17:49,730
它会将1推到堆栈顶部，

00:17:49,730 --> 00:17:53,480
如果在脚本运行后堆栈顶部留下1，

00:17:53,480 --> 00:17:59,230
那么这批比特币可以被花费，这是有道理的。

00:17:59,230 --> 00:18:04,029
让我把这些都移回来，

00:18:04,029 --> 00:18:10,899
我们知道为什么刚才有一个所谓的p2pk的例子，

00:18:10,899 --> 00:18:14,320
它非常简单，

00:18:14,320 --> 00:18:18,250
一批比特币上的锁定代码只包含别人的公钥和检查签名操作码，

00:18:18,250 --> 00:18:23,620
然后当那个人想要解锁他们时，

00:18:23,620 --> 00:18:25,299
他们要的就是解锁这批比特币

00:18:25,299 --> 00:18:29,559
我所要做的是提供私钥的有效签名，

00:18:29,559 --> 00:18:32,620
该公钥是从现在开始创建的，

00:18:32,620 --> 00:18:40,809
这可能是锁定一批比特币的最简单的方式，

00:18:40,809 --> 00:18:46,360
矿工们在区块内的coinbase交易中大量使用了这种方式，

00:18:46,360 --> 00:18:52,539
但通常今天我们使用这种锁定机制的一种变体。

00:18:52,539 --> 00:18:54,070
这是最简单的一种，

00:18:54,070 --> 00:18:57,730
但我们现在使用的是一种有点不同的东西。

00:18:57,730 --> 00:19:06,100
这被称为Pay To Pubkey或简称P2PK。

00:19:06,100 --> 00:19:09,789
请注意，这些P 2 P K和Pay To Pubkey，

00:19:09,789 --> 00:19:13,960
这些名字适用于你应用到一批比特币的锁定脚本的模式。

00:19:13,960 --> 00:19:15,909
所以如果你看到一批比特币，

00:19:15,909 --> 00:19:19,960
它有一个公钥和一个检查操作码，没有别的，

00:19:19,960 --> 00:19:24,360
那个模式就是一个Pay To Pubkey脚本，

00:19:24,360 --> 00:19:30,940
这个脚本是一组最常用的标准脚本中的一个。

00:19:30,940 --> 00:19:33,190
我将介绍其中的五个，

00:19:33,190 --> 00:19:37,230
这是最简单的一个，

00:19:37,230 --> 00:19:42,490
叫做Pay To Pubkey。

00:19:42,490 --> 00:19:44,830
接下来我们有一个叫做Pay To Pubkey Hash的，

00:19:44,830 --> 00:19:46,659
它与这个非常相似，只是稍微有些不同，

00:19:46,659 --> 00:19:48,870
我会在一会儿后解释原因。

00:19:48,870 --> 00:19:55,570
如果你还记得在关于密钥和地址的视频中，

00:19:55,570 --> 00:19:57,279
我们创建了一个私钥和公钥，

00:19:57,279 --> 00:19:58,480
这就是我们在比特币中发送和接收比特币所需要的全部，

00:19:58,480 --> 00:20:03,519
我们通常会先对公钥进行哈希，

00:20:03,519 --> 00:20:06,340
我提到这是因为安全性，

00:20:06,340 --> 00:20:09,220
我认为，这主要是因为一开始，

00:20:09,220 --> 00:20:12,519
这是一种简单的减小公钥大小的方式，

00:20:12,519 --> 00:20:15,879
所以当我们把这个给别人的时候。
of the public key so that's when we give

448
00:20:15,879 --> 00:20:19,479
我们可以给他们一个更小的公钥，

00:20:19,479 --> 00:20:21,909
但这仍然是我们的公钥，
but it's still a unique vision of our

451
00:20:21,909 --> 00:20:25,919
所以我们会做的是，
public key so what we would do

452
00:20:25,919 --> 00:20:27,789
当我们创建了我们的密钥和地址后，
whence we've created our keys in the

453
00:20:27,789 --> 00:20:30,489
我们会对我们的公钥进行哈希，
dress is we will hash our public key

454
00:20:30,489 --> 00:20:33,070
这样就减小了它的大小，
which produces its size we'll give that

455
00:20:33,070 --> 00:20:36,009
然后我们会将这个哈希值给别人，
some else and then they'll put that into

456
00:20:36,009 --> 00:20:38,499
然后他们会将这个哈希值放入锁定代码中，
the locking code instead of our original

457
00:20:38,499 --> 00:20:42,209
而不是我们原来的公钥，
public key so the way this particular

458
00:20:42,209 --> 00:20:47,129
这种特殊的锁定脚本是使用我们公钥的哈希版本，

00:20:47,129 --> 00:20:49,690
而不是标准的原始公钥。
standard you know original public key is

461
00:20:49,690 --> 00:20:56,049
我们会在它周围放一个类似的锁定脚本，
we put a locking script like this around

462
00:20:53,169 --> 00:20:56,049
it so it's a little bit similar we still

463
00:20:56,049 --> 00:20:58,299
我们仍然有这个检查签名函数，
have this check sync function but now

464
00:20:58,299 --> 00:20:59,649
但现在不是只有哈希公钥和check sig，
instead of having the public key and

465
00:20:59,649 --> 00:21:01,179

just the check sig we have hash the

466
00:21:01,179 --> 00:21:03,309
我们对哈希公钥和这些额外的操作码进行哈希处理。
public key and these extra operators

467
00:21:03,309 --> 00:21:08,820
稍后就会知道原因。
here and we'll see why in a moment so

468
00:21:08,820 --> 00:21:13,089
这就是Pay To Pubkey Hash，


this is the paid up key hash pattern or

469
00:21:13,089 --> 00:21:14,739
或者说Pay To Pubkey Hash锁定脚本，
the pattern for a paid-up key hash

470
00:21:14,739 --> 00:21:20,019
当你来解锁这个特定的锁定脚本时

00:21:20,019 --> 00:21:22,629
我们需要做的就像之前一样，
what we need to do like before all we

473
00:21:22,629 --> 00:21:27,909
我们需要一个签名，
need is a signature from for from the

474
00:21:27,909 --> 00:21:29,409
这个签名来自于生成这个公钥的私钥，
private key that this public key is made

475
00:21:29,409 --> 00:21:32,679
除此之外，
from and then also in addition to that

476
00:21:32,679 --> 00:21:34,599
我们还需要提供原始的公钥。
we all need to provide the original

477
00:21:34,599 --> 00:21:40,779
当一个节点来运行这个脚本，

00:21:40,779 --> 00:21:43,059
确保它是有效的时，
to make sure it's valid they do the same

480
00:21:43,059 --> 00:21:45,999
他们会再次确保解锁脚本从左到右运行。

00:21:45,999 --> 00:21:48,129
他们会把他们的堆栈，
left to right so what they'll do they'll

483
00:21:48,129 --> 00:21:50,679
显然数据会被推到堆栈上，
take their stack they'll obviously data

484
00:21:50,679 --> 00:21:52,419
签名会在顶部，
gets pushed onto the stack the signature

485
00:21:52,419 --> 00:21:55,690
然后是公钥。
goes on top top then the public key let

486
00:21:55,690 --> 00:21:59,049
然后我们遇到这个复制操作码，
me hit this dupe up code and it does

487
00:21:59,049 --> 00:22:01,869
它会做你期望它做的事情，
what you expect it would it pops the top

488
00:22:01,869 --> 00:22:04,419
它会弹出堆栈的顶部元素，复制它，
element of the stack duplicates it and

489
00:22:04,419 --> 00:22:13,240
然后把这个复制的顶部元素推回到堆栈上。

00:22:13,240 --> 00:22:16,570
我们有哈希160，
done next up we have the hash 160

493
00:22:16,570 --> 00:22:19,300
它会弹出顶部元素，对它进行哈希，
that'll pop the top element off hash it

494
00:22:19,300 --> 00:22:20,920
然后把它推回到堆栈的顶部。
and then push it back on top of the

495
00:22:20,920 --> 00:22:25,300
然后我们来看原始锁定脚本中的哈希公钥，
start then we went into the hashed

496
00:22:25,300 --> 00:22:27,040
public key that was a in the original

497
00:22:27,040 --> 00:22:28,920
它被推到了顶部。
locking script that gets pushed on top

498
00:22:28,920 --> 00:22:31,180
然后我们来到EQUALVERIFY操作码，
then we went into the equal verify

499
00:22:31,180 --> 00:22:35,050
这个操作码会从堆栈的顶部弹出两个元素，

00:22:35,050 --> 00:22:37,510
检查它们是否相等，如果它们相等，
checks are they equal and if they are

502
00:22:37,510 --> 00:22:39,970
它不会把任何东西推回到堆栈上。
equal it won't push anything back onto

503
00:22:39,970 --> 00:22:42,550
然后是EQUALVERIFY操作码，


the stack so whereas the equal up code

504
00:22:42,550 --> 00:22:44,410
它会把1推到堆栈的顶部，
would push the number one on top equal

505
00:22:44,410 --> 00:22:46,510
检查签名是否匹配公钥，
verify checks the equal and if they are

506
00:22:46,510 --> 00:22:48,370
如果匹配，它不会把任何内容推回到堆栈上。
doesn't push anything on top of the

507
00:22:48,370 --> 00:22:54,040
然后我们遇到了熟悉的CHECKSIG操作码，

00:22:54,040 --> 00:22:56,770
该代码将弹出，
pop to its off check that the signature

510
00:22:56,770 --> 00:22:58,870
检查签名与公钥是否匹配，
matches the public key and if it does

511
00:22:58,870 --> 00:23:00,640
如果匹配，它会把一个数字推到堆栈的顶部。
you're pushing one on to the top of the

512
00:23:00,640 --> 00:23:10,810
所以与pay to pub key hash的唯一真正区别是，

00:23:10,810 --> 00:23:18,630
你需要检查你提供的公钥，

00:23:18,630 --> 00:23:25,480
是否与最初提供的公钥的哈希匹配，

00:23:25,480 --> 00:23:31,350
如果匹配，

it does it will just check the signature

520
00:23:31,350 --> 00:23:37,060
它就会像Pay To Pubkey 那样检查签名。

00:23:37,060 --> 00:23:39,240
有其他问题吗？

523
00:23:39,660 --> 00:23:43,930
我们是否可以自己创建，
are you aware if we can come up with our

524
00:23:43,930 --> 00:23:48,810
比如Pay To Pubkey，
own like you know you have paid to

525
00:23:48,810 --> 00:23:52,570
比如Pay To Pubkey Hash，
publicly paid to public key hash let's

526
00:23:52,570 --> 00:23:54,880
假设我想做一个Pay To Pubkey Hash，
say I want to do a play to public key

527
00:23:54,880 --> 00:23:57,850
这是用户实际可以做的吗？
hash of hash is that something that

528
00:23:57,850 --> 00:24:06,460
答案是肯定的，
users can actually do yes yes yes yes I

529
00:24:06,460 --> 00:24:08,440
我会在稍后解释为什么。
know and I'll explain why in a moment

530
00:24:08,440 --> 00:24:12,040
好的问题，
but good question okay oh yeah I'll come

531
00:24:12,040 --> 00:24:16,690
现在我将继续讲解这些标准脚本。

00:24:16,690 --> 00:24:20,410
Pay To Pubkey和Pay To Pubkey Hash相同，

00:24:20,410 --> 00:24:29,420
它只是首先检查你在解锁脚本中提供的公钥哈希是否与最初提供的哈希匹配，

00:24:29,420 --> 00:24:32,300
然后像往常一样检查签名。
just check the singer's normal so this

540
00:24:32,300 --> 00:24:33,740
我想说，

00:24:33,740 --> 00:24:36,530
Pay To Pubkey是针对公钥的，
yeah people pika is for the public keys

542
00:24:36,530 --> 00:24:38,810
而Pay To Pubkey Hash是针对比特币地址的。
but we do PK H is for the Bitcoin

543
00:24:38,810 --> 00:24:40,430
是的，

00:24:40,430 --> 00:24:46,250
这是你在比特币上最常见的锁定脚本。

00:24:46,250 --> 00:24:55,610
为了方便实用，
days for convenience instead of when you

547
00:24:55,610 --> 00:24:57,530
当你想接收比特币时，
want to receive bitcoins instead of you

548
00:24:57,530 --> 00:24:59,390
我们有一种更方便的方式，而不是创建这个哈希，
know creating this hash and then

549
00:24:59,390 --> 00:25:02,120
然后用你想用的所有操作码包围它，
surrounding it with all the opcodes you

550
00:25:02,120 --> 00:25:05,570
基本上构造了整个锁定脚本，
want to use around it so basically

551
00:25:03,860 --> 00:25:05,570
construct this entire lock-in script and

552
00:25:05,570 --> 00:25:06,790
然后给别人。
then giving it to someone else

553
00:25:06,790 --> 00:25:11,480
我们在比特币中有很多更方便的方法来做到这一点，

00:25:11,480 --> 00:25:14,120
我们创建一个地址，
we create an address which is basically

556
00:25:14,120 --> 00:25:22,270
这基本上是公钥的哈希160，
a the hash 160 of the public key

557
00:25:22,270 --> 00:25:24,530
转换成用户更好使用的格式，
converted into a more user-friendly

558
00:25:24,530 --> 00:25:28,100
它有一个校验和，
format it has a checksum and uses more

559
00:25:28,100 --> 00:25:29,810
使用对用户更友好的字符。
user-friendly characters so it's harder

560
00:25:29,810 --> 00:25:32,630
to make make mistakes with and then this

561
00:25:32,630 --> 00:25:35,720
address will be prepended with a one at

562
00:25:35,720 --> 00:25:38,830
the front so that means if you give an

563
00:25:38,830 --> 00:25:41,240
address to someone else where the one at

564
00:25:41,240 --> 00:25:43,850
the start they will be able to decode it

565
00:25:43,850 --> 00:25:46,490
to get the original hash of the public

566
00:25:46,490 --> 00:25:48,860
key and because they see that there's a

567
00:25:48,860 --> 00:25:51,860
one at the front they'll go okay this

568
00:25:51,860 --> 00:25:53,960
person wants to pay to pub key hash so

569
00:25:53,960 --> 00:25:57,440
they will decode it and form this

570
00:25:57,440 --> 00:25:59,929
locking script with the

571
00:25:59,929 --> 00:26:02,450
hache 160 the public key placed inside

572
00:26:02,450 --> 00:26:05,090
it so this address here is just a

573
00:26:05,090 --> 00:26:07,580
convenient way of telling people how you

574
00:26:07,580 --> 00:26:10,119
want your bitcoins to be locked up

575
00:26:10,119 --> 00:26:15,080
so Peter PK does not have a address

576
00:26:15,080 --> 00:26:17,059
format so if you want bitcoins to be

577
00:26:17,059 --> 00:26:18,580
locked up in this format you have to

578
00:26:18,580 --> 00:26:21,259
send them the entire locking script and

579
00:26:21,259 --> 00:26:23,200
the after the person will have to

580
00:26:23,200 --> 00:26:26,330
construct the transaction manually to

581
00:26:26,330 --> 00:26:29,659
put this locking script inside but the

582
00:26:29,659 --> 00:26:31,850
Pater pub key hash the more common

583
00:26:31,850 --> 00:26:34,369
format has this address so whenever you

584
00:26:34,369 --> 00:26:36,289
send someone an address all you're

585
00:26:36,289 --> 00:26:39,230
sending them is the hash of your public

586
00:26:39,230 --> 00:26:42,080
key and telling them to lock it up in a

587
00:26:42,080 --> 00:26:48,830
certain way thirdly I'm gonna do five

588
00:26:48,830 --> 00:26:50,480
just a third one so these are just pay

589
00:26:50,480 --> 00:26:54,019
into a single person's public key you

590
00:26:54,019 --> 00:26:56,840
have what's called pay to multi-sig so

591
00:26:56,840 --> 00:26:58,850
what you can do in Bitcoin instead of

592
00:26:58,850 --> 00:27:00,470
just lock in a batch of bitcoins up to

593
00:27:00,470 --> 00:27:02,690
one person's public key see there are

594
00:27:02,690 --> 00:27:04,490
three of you in a company or inside a

595
00:27:04,490 --> 00:27:06,789
business and you want to receive

596
00:27:06,789 --> 00:27:09,830
bitcoins together or you can do you can

597
00:27:09,830 --> 00:27:12,379
all put your public keys into a locking

598
00:27:12,379 --> 00:27:17,869
script and then what you'll do your put

599
00:27:17,869 --> 00:27:20,389
in number after it which is n the number

600
00:27:20,389 --> 00:27:22,669
of public keys inside the locking script

601
00:27:22,669 --> 00:27:26,210
and then another number called M which

602
00:27:26,210 --> 00:27:29,269
is the number of signatures that needs

603
00:27:29,269 --> 00:27:32,389
to be provided for this locking script

604
00:27:32,389 --> 00:27:34,850
to be unlocked or this but so I

605
00:27:34,850 --> 00:27:38,600
Bitcoin assign to be unlocked and then

606
00:27:38,600 --> 00:27:40,429
at the end of it then you'll use the

607
00:27:40,429 --> 00:27:44,139
check multi-sig function so this is a

608
00:27:44,139 --> 00:27:47,899
Peter multi-sig locking script so like I

609
00:27:47,899 --> 00:27:50,740
said the M here just indicates how many

610
00:27:50,740 --> 00:27:53,960
signatures are going to be needed for

611
00:27:53,960 --> 00:27:57,940
this lock in scope to be unlocked

612
00:27:57,940 --> 00:28:01,809
so when it comes to so say you give this

613
00:28:01,809 --> 00:28:03,429
locking script to someone else they put

614
00:28:03,429 --> 00:28:05,139
a batch of bitcoins with this locking

615
00:28:05,139 --> 00:28:08,470
script on it so when these three people

616
00:28:08,470 --> 00:28:10,870
here want to come to unlock this batch

617
00:28:10,870 --> 00:28:12,070
of bitcoins are send them on to someone

618
00:28:12,070 --> 00:28:15,309
else or we all need is two signatures

619
00:28:15,309 --> 00:28:20,110
from any two of these people they also

620
00:28:20,110 --> 00:28:22,419
need to be in the correct order so if

621
00:28:22,419 --> 00:28:24,549
these public keys were put into the

622
00:28:24,549 --> 00:28:26,980
locking code in a specific order these

623
00:28:26,980 --> 00:28:28,450
signatures will be need to be in the

624
00:28:28,450 --> 00:28:30,309
correct order also which you will see

625
00:28:30,309 --> 00:28:31,889
why in a moment

626
00:28:31,889 --> 00:28:34,929
so that is a typical Paton multi-sig and

627
00:28:34,929 --> 00:28:37,539
I'll run it in a moment just a quick

628
00:28:37,539 --> 00:28:40,990
note there's a little bug in this check

629
00:28:40,990 --> 00:28:46,200
multi-sig function or the way it works

630
00:28:46,200 --> 00:28:49,870
and this was just a boat from the start

631
00:28:49,870 --> 00:28:51,250
of Bitcoin that we just need to account

632
00:28:51,250 --> 00:28:54,100
for now basically what happens is the M

633
00:28:54,100 --> 00:28:56,950
at the start here has an off by one

634
00:28:56,950 --> 00:29:00,960
error so what happens is it will consume

635
00:29:00,960 --> 00:29:04,750
one more item from the stack then we've

636
00:29:04,750 --> 00:29:07,779
indicated here so to get around that for

637
00:29:07,779 --> 00:29:09,669
every pay to multi-sig we just need to

638
00:29:09,669 --> 00:29:13,980
put a dummy or zero opcode at the start

639
00:29:13,980 --> 00:29:16,629
so this is the bug that need to account

640
00:29:16,629 --> 00:29:19,590
for let me use the check multi-sig

641
00:29:19,590 --> 00:29:24,120
script so anyway let's run this script

642
00:29:24,120 --> 00:29:26,110
how does it get run how does it get

643
00:29:26,110 --> 00:29:29,289
checked and put the locking code at the

644
00:29:29,289 --> 00:29:32,500
start then go from left to right numbers

645
00:29:32,500 --> 00:29:34,059
they just get pushed onto the stack

646
00:29:34,059 --> 00:29:36,519
just like data like so so the zeros on

647
00:29:36,519 --> 00:29:38,620
the stack there then we push on the

648
00:29:38,620 --> 00:29:40,960
signatures because their data then we

649
00:29:40,960 --> 00:29:42,220
have the two again number just gets

650
00:29:42,220 --> 00:29:43,840
pushed numbers just get pushed on top of

651
00:29:43,840 --> 00:29:46,929
the stack then each of these public keys

652
00:29:46,929 --> 00:29:48,789
again they're just data can push on top

653
00:29:48,789 --> 00:29:52,330
the stack and then the three finally we

654
00:29:52,330 --> 00:29:54,639
come to the check mark multi-sig opcode

655
00:29:54,639 --> 00:29:56,980
what this does first of all it'll pop

656
00:29:56,980 --> 00:29:58,899
the top element off see that's a three

657
00:29:58,899 --> 00:30:01,629
when it sees us a three it means it will

658
00:30:01,629 --> 00:30:02,950
pop the next three elements off the top

659
00:30:02,950 --> 00:30:05,259
the stack then you'll pop the next

660
00:30:05,259 --> 00:30:07,029
element off which is a two and when it

661
00:30:07,029 --> 00:30:08,889
sees that it'll pop the next 2 ms off

662
00:30:08,889 --> 00:30:09,960
the stack

663
00:30:09,960 --> 00:30:13,250
but like I mentioned earlier this M here

664
00:30:13,250 --> 00:30:16,110
hasn't off by one error so it will

665
00:30:16,110 --> 00:30:19,440
consume three instead of two but this is

666
00:30:19,440 --> 00:30:21,390
just a little bug in Bitcoin attack you

667
00:30:21,390 --> 00:30:24,960
can pretend it's not there anyway so now

668
00:30:24,960 --> 00:30:27,510
it has to come to check the signatures

669
00:30:27,510 --> 00:30:29,309
against the public keys that's why

670
00:30:29,309 --> 00:30:30,870
you'll do it we'll start with the first

671
00:30:30,870 --> 00:30:32,970
signature it's got at the bottom of the

672
00:30:32,970 --> 00:30:35,070
stack and then check it against the

673
00:30:35,070 --> 00:30:37,230
first public key there's got to check

674
00:30:37,230 --> 00:30:40,140
there's and check their matches so let's

675
00:30:40,140 --> 00:30:41,700
say this to it and doesn't match but

676
00:30:41,700 --> 00:30:42,390
that's fine

677
00:30:42,390 --> 00:30:44,309
if that doesn't match it I'll move on to

678
00:30:44,309 --> 00:30:45,600
the next public key to see if that

679
00:30:45,600 --> 00:30:48,210
matches and this one does much so let's

680
00:30:48,210 --> 00:30:49,620
put a little one here to see the lab

681
00:30:49,620 --> 00:30:54,059
matter that hasn't matched the reason I

682
00:30:54,059 --> 00:30:56,130
said to put these signatures into the

683
00:30:56,130 --> 00:30:59,669
correct order is because after the check

684
00:30:59,669 --> 00:31:02,490
multi-sig function has checked a

685
00:31:02,490 --> 00:31:05,490
signature against public keys it won't

686
00:31:05,490 --> 00:31:08,460
check those public keys again so when

687
00:31:08,460 --> 00:31:10,740
you come to match the second signature

688
00:31:10,740 --> 00:31:13,470
against the public keys instead of going

689
00:31:13,470 --> 00:31:14,820
from the start and match them against

690
00:31:14,820 --> 00:31:16,770
each of the individual public keys it

691
00:31:16,770 --> 00:31:18,240
will start from where it left off or the

692
00:31:18,240 --> 00:31:22,200
last match so again you'll check the

693
00:31:22,200 --> 00:31:23,610
signature against this public key here

694
00:31:23,610 --> 00:31:25,980
if that matches the near we are we have

695
00:31:25,980 --> 00:31:28,980
got too much in signatures and therefore

696
00:31:28,980 --> 00:31:32,279
because we asked for asked for - after

697
00:31:32,279 --> 00:31:36,380
three signatures for this lock in script

698
00:31:36,380 --> 00:31:39,799
this script is Viator check multi-sig is

699
00:31:39,799 --> 00:31:43,409
happy with this so it'll push a one on

700
00:31:43,409 --> 00:31:45,990
top of the stack obviously if there's

701
00:31:45,990 --> 00:31:49,140
only 0 or 1 matches signatures for these

702
00:31:49,140 --> 00:31:51,840
public keys they were pushes you on top

703
00:31:51,840 --> 00:31:53,250
but because we've got enough matching

704
00:31:53,250 --> 00:31:55,620
signatures it pushes a one on top of the

705
00:31:55,620 --> 00:32:03,539
stack as that make sense ok so there we

706
00:32:03,539 --> 00:32:03,750
are

707
00:32:03,750 --> 00:32:06,480
8a multi-sig obviously now you know how

708
00:32:06,480 --> 00:32:10,380
these scripts work is quite simple

709
00:32:10,380 --> 00:32:13,290
before we move on to the fourth one

710
00:32:13,290 --> 00:32:15,730
there's a little bit of a problem but

711
00:32:15,730 --> 00:32:19,380
it's all Peter multi-sig setup because

712
00:32:19,380 --> 00:32:22,120
say there are three of us or more of us

713
00:32:22,120 --> 00:32:24,760
in a company and we just want to accept

714
00:32:24,760 --> 00:32:29,140
bitcoins to a multi-sig lock-in script

715
00:32:29,140 --> 00:32:31,180
will obviously have to construct this

716
00:32:31,180 --> 00:32:33,450
lock-in script and give to someone else

717
00:32:33,450 --> 00:32:36,880
and they'll have to construct a

718
00:32:36,880 --> 00:32:39,070
transaction and put the entire script we

719
00:32:39,070 --> 00:32:42,390
have given them into the locking code

720
00:32:42,390 --> 00:32:45,630
for the bitcoins they are sending us

721
00:32:45,630 --> 00:32:49,090
like so so they construct this entire

722
00:32:49,090 --> 00:32:51,490
track transaction and they all have to

723
00:32:51,490 --> 00:32:53,380
put the locking code that we want onto

724
00:32:53,380 --> 00:32:57,460
this batch of bitcoins problem with this

725
00:32:57,460 --> 00:33:00,720
check multi-sig is that they can get

726
00:33:00,720 --> 00:33:03,580
these particular locking scripts can get

727
00:33:03,580 --> 00:33:06,040
become quite big so this two or three

728
00:33:06,040 --> 00:33:08,350
multi-sig locking script is a hundred

729
00:33:08,350 --> 00:33:13,000
and five bytes but with every public key

730
00:33:13,000 --> 00:33:16,180
that we add in to the pater multi-sig it

731
00:33:16,180 --> 00:33:18,010
gets bigger and bigger and bigger

732
00:33:18,010 --> 00:33:21,370
because every public key takes up 33

733
00:33:21,370 --> 00:33:23,910
bytes of space inside transaction data

734
00:33:23,910 --> 00:33:27,070
so if we were to give this you know a

735
00:33:27,070 --> 00:33:30,910
very big locking script a very big paid

736
00:33:30,910 --> 00:33:32,470
to multi-sig locking script to someone

737
00:33:32,470 --> 00:33:35,020
to lock up our bitcoins they're probably

738
00:33:35,020 --> 00:33:37,150
not gonna be very happy because this is

739
00:33:37,150 --> 00:33:39,400
going to take up a lot of data inside

740
00:33:39,400 --> 00:33:41,530
their transaction and they're gonna have

741
00:33:41,530 --> 00:33:44,940
to pay for that data in transaction fees

742
00:33:44,940 --> 00:33:48,370
so you know especially when you consider

743
00:33:48,370 --> 00:33:51,280
that pay to public is 35 bytes paid to

744
00:33:51,280 --> 00:33:54,130
public key hash 25 bytes and typically

745
00:33:54,130 --> 00:33:57,190
the smallest peter multi-sig locking

746
00:33:57,190 --> 00:34:00,040
script is gonna be 105 bytes it's not

747
00:34:00,040 --> 00:34:05,470
too exciting for this person to want to

748
00:34:05,470 --> 00:34:07,540
send bitcoins to anything other than

749
00:34:07,540 --> 00:34:09,550
Peter pop key or pay to pokey hash

750
00:34:09,550 --> 00:34:14,199
scripts so what can we do to sort of

751
00:34:14,199 --> 00:34:17,020
avoid this problem of this person having

752
00:34:17,020 --> 00:34:20,839
to pay for these large locking scripts

753
00:34:20,839 --> 00:34:24,679
you know through creating transactions

754
00:34:24,679 --> 00:34:27,619
that contain more trent data than they

755
00:34:27,619 --> 00:34:33,379
would like so that's where peter script

756
00:34:33,379 --> 00:34:34,099
ash comes in

757
00:34:34,099 --> 00:34:36,559
it's basically there to make these more

758
00:34:36,559 --> 00:34:41,899
complex scripts shorter and easier for

759
00:34:41,899 --> 00:34:45,460
someone else to creat transactions with

760
00:34:45,460 --> 00:34:48,018
so this is called peter script hash and

761
00:34:48,018 --> 00:34:50,268
i'll explain how this works now so let's

762
00:34:50,268 --> 00:34:53,599
say we want to receive bitcoins to a

763
00:34:53,599 --> 00:34:57,710
peter multi-sig locking script what

764
00:34:57,710 --> 00:34:59,479
we'll do instead of given them is in

765
00:34:59,479 --> 00:35:03,109
this entire locking script your first of

766
00:35:03,109 --> 00:35:04,880
all just hash it together

767
00:35:04,880 --> 00:35:06,289
the unique hash of this particular

768
00:35:06,289 --> 00:35:08,119
script and this is called the script

769
00:35:08,119 --> 00:35:13,130
hash so what we can do then you can just

770
00:35:13,130 --> 00:35:14,479
give this script hash to someone else

771
00:35:14,479 --> 00:35:17,479
and then they can put this into the

772
00:35:17,479 --> 00:35:20,960
locking script wrap it with a sick of a

773
00:35:20,960 --> 00:35:25,789
set of opcodes and so there we have he

774
00:35:25,789 --> 00:35:29,269
paid to script hash lock so it's

775
00:35:29,269 --> 00:35:30,890
obviously a lot smaller so instead of

776
00:35:30,890 --> 00:35:33,259
giving this person the entire original

777
00:35:33,259 --> 00:35:35,299
locking script we just give them a hash

778
00:35:35,299 --> 00:35:37,249
of it then which shrinks it shrinks it

779
00:35:37,249 --> 00:35:39,529
down a lot they just have to apply to

780
00:35:39,529 --> 00:35:41,539
opcodes around it and then we have a

781
00:35:41,539 --> 00:35:45,589
page of script hash locking script and

782
00:35:45,589 --> 00:35:47,690
this is much shorter so whereas the

783
00:35:47,690 --> 00:35:50,269
original 105 bytes a page of script hash

784
00:35:50,269 --> 00:35:53,150
is similar to a peter pub key hash about

785
00:35:53,150 --> 00:35:55,969
23 bytes which makes them happy because

786
00:35:55,969 --> 00:35:58,039
they don't have to construct these huge

787
00:35:58,039 --> 00:36:01,279
transactions and pay for the fees from

788
00:36:01,279 --> 00:36:06,079
these large locking scripts so that

789
00:36:06,079 --> 00:36:09,380
works but then how do we unlock or

790
00:36:09,380 --> 00:36:11,779
redeem this batch of bitcoins for this

791
00:36:11,779 --> 00:36:14,479
painter script hash code on it lock and

792
00:36:14,479 --> 00:36:17,539
script on it well what we do if it's a

793
00:36:17,539 --> 00:36:19,950
peter multi-sig

794
00:36:19,950 --> 00:36:21,930
same as before you just need to provide

795
00:36:21,930 --> 00:36:25,860
two signatures but then in addition to

796
00:36:25,860 --> 00:36:28,020
that we also have to provide the

797
00:36:28,020 --> 00:36:31,920
original locking script though this hash

798
00:36:31,920 --> 00:36:34,460
of the locking script was created from

799
00:36:34,460 --> 00:36:36,750
but instead of putting the individual op

800
00:36:36,750 --> 00:36:38,610
codes we just squeeze it all together

801
00:36:38,610 --> 00:36:41,580
into a single piece of data or serialize

802
00:36:41,580 --> 00:36:44,340
it to a single piece of data so all the

803
00:36:44,340 --> 00:36:46,140
op codes are in there but instead of

804
00:36:46,140 --> 00:36:47,940
them peered individual op codes it's

805
00:36:47,940 --> 00:36:54,050
just a bunch of data right so let's run

806
00:36:54,050 --> 00:36:59,060
this locking code and a knockin code

807
00:36:59,060 --> 00:37:02,010
right so once again you put the locking

808
00:37:02,010 --> 00:37:06,180
code at the start but the thing is with

809
00:37:06,180 --> 00:37:08,430
a pager script hash and even though it

810
00:37:08,430 --> 00:37:11,000
gets executed in roughly the same way

811
00:37:11,000 --> 00:37:14,300
this particular format of locking code

812
00:37:14,300 --> 00:37:17,430
is like it's a special form and it will

813
00:37:17,430 --> 00:37:19,830
be executed slightly differently and

814
00:37:19,830 --> 00:37:23,940
I'll show you how that works now so it

815
00:37:23,940 --> 00:37:26,130
starts off as normal using the stack we

816
00:37:26,130 --> 00:37:28,710
put the locking code at the start and we

817
00:37:28,710 --> 00:37:30,960
all just push the signatures onto the

818
00:37:30,960 --> 00:37:35,340
stack then we run into this see realized

819
00:37:35,340 --> 00:37:38,910
lock in script also call the redeem

820
00:37:38,910 --> 00:37:41,250
script and because it's just data just

821
00:37:41,250 --> 00:37:43,020
shove together that just goes on top of

822
00:37:43,020 --> 00:37:44,960
the stack as well and that is the

823
00:37:44,960 --> 00:37:49,350
unlocking code part done because it's a

824
00:37:49,350 --> 00:37:51,000
pager script hash this is where the

825
00:37:51,000 --> 00:37:53,490
difference comes in it will make a copy

826
00:37:53,490 --> 00:37:57,420
of the stack after the unlocking code or

827
00:37:57,420 --> 00:38:00,210
a knockin script has been run so it

828
00:38:00,210 --> 00:38:03,150
takes a copy of it now it will run the

829
00:38:03,150 --> 00:38:07,110
original locking script with the stack

830
00:38:07,110 --> 00:38:10,440
we've got from the unlocking script so

831
00:38:10,440 --> 00:38:14,040
first of all it there's a hash 160 of

832
00:38:14,040 --> 00:38:16,440
the top element on the stack so it will

833
00:38:16,440 --> 00:38:19,450
hash this piece of data the

834
00:38:19,450 --> 00:38:22,750
see realized lock-in script the original

835
00:38:22,750 --> 00:38:24,849
one and they were hash it put it back on

836
00:38:24,849 --> 00:38:27,609
top then the hash from the locking

837
00:38:27,609 --> 00:38:29,260
script again put on top of the stack as

838
00:38:29,260 --> 00:38:33,880
well and then they're equal opcode will

839
00:38:33,880 --> 00:38:36,250
pop two elements off check that they

840
00:38:36,250 --> 00:38:38,440
equal and if they are it'll put a one on

841
00:38:38,440 --> 00:38:41,109
top of the stack and so this stack no

842
00:38:41,109 --> 00:38:43,299
this script part the unlocking script

843
00:38:43,299 --> 00:38:44,650
and the locking script has been

844
00:38:44,650 --> 00:38:47,799
completely run and we are left with a 1

845
00:38:47,799 --> 00:38:49,900
on top of the stack so this first part

846
00:38:49,900 --> 00:38:57,400
checks that the locking script the

847
00:38:57,400 --> 00:38:58,950
serialized locking script we've provided

848
00:38:58,950 --> 00:39:01,780
matches the one that was originally

849
00:39:01,780 --> 00:39:05,460
hashed and put into the locking script

850
00:39:05,460 --> 00:39:09,119
so that part is done

851
00:39:10,080 --> 00:39:12,720
then after it's been run because it's a

852
00:39:12,720 --> 00:39:16,320
descriptive it brings the copy back and

853
00:39:16,320 --> 00:39:18,630
uses that as the stack so the first part

854
00:39:18,630 --> 00:39:22,220
checks that the the hash match is the

855
00:39:22,220 --> 00:39:25,980
Redeem script that we provided and in

856
00:39:25,980 --> 00:39:27,210
the second part of the page a script

857
00:39:27,210 --> 00:39:30,300
hash it will pop the top element off

858
00:39:30,300 --> 00:39:32,220
which is the regime script it will

859
00:39:32,220 --> 00:39:35,970
deserialize it and then run the stack

860
00:39:35,970 --> 00:39:39,680
again so like before in PT multi-sig

861
00:39:39,680 --> 00:39:42,210
this is a number two gets pushed on top

862
00:39:42,210 --> 00:39:44,790
then all the public keys then the three

863
00:39:44,790 --> 00:39:47,040
then we went into chat multi C again

864
00:39:47,040 --> 00:39:49,310
you'll do the exact same as last time

865
00:39:49,310 --> 00:39:51,900
pop all the ailments off check the

866
00:39:51,900 --> 00:39:53,310
signatures against public keys make sure

867
00:39:53,310 --> 00:39:54,660
it's got enough and if that's correct

868
00:39:54,660 --> 00:39:56,790
it'll push someone back onto the stack

869
00:39:56,790 --> 00:40:03,860
and that is that done do you follow that

870
00:40:03,860 --> 00:40:07,670
okay okay so this page of script hash

871
00:40:07,670 --> 00:40:10,440
it's the only one that gets run a little

872
00:40:10,440 --> 00:40:13,890
differently to these typical scripts and

873
00:40:13,890 --> 00:40:15,630
it's only and it was added into Bitcoin

874
00:40:15,630 --> 00:40:21,840
later on as a way to be able to create

875
00:40:21,840 --> 00:40:26,250
simple complex scripts basically then

876
00:40:26,250 --> 00:40:28,410
have other that have other people only

877
00:40:28,410 --> 00:40:32,400
have to put a simple format of locking

878
00:40:32,400 --> 00:40:34,200
script on top of bitcoins to make it

879
00:40:34,200 --> 00:40:37,530
easier for them these peter script

880
00:40:37,530 --> 00:40:39,090
hashes also have their own address

881
00:40:39,090 --> 00:40:42,510
similar to the peter pub key hash so the

882
00:40:42,510 --> 00:40:44,430
way you get a way you form an address

883
00:40:44,430 --> 00:40:46,140
for a

884
00:40:46,140 --> 00:40:49,619
pay to script hash locking script is you

885
00:40:49,619 --> 00:40:55,650
will hash the script that you the

886
00:40:55,650 --> 00:40:57,539
locking script they or basically how you

887
00:40:57,539 --> 00:40:58,829
want this matchup it going to be locked

888
00:40:58,829 --> 00:41:00,869
up like before great a hash remit and

889
00:41:00,869 --> 00:41:03,779
then from this hash you will encode it

890
00:41:03,779 --> 00:41:07,799
into a pretty format of an address and

891
00:41:07,799 --> 00:41:09,390
you can go back and forth between these

892
00:41:09,390 --> 00:41:12,869
two and whereas in a pay to pop key hash

893
00:41:12,869 --> 00:41:18,150
you have the hash they create well in

894
00:41:18,150 --> 00:41:19,739
this page script - you couldn't address

895
00:41:19,739 --> 00:41:22,470
and the hash is inside there and you put

896
00:41:22,470 --> 00:41:24,690
a three at the start so when you give

897
00:41:24,690 --> 00:41:26,880
this three to someone else they'll be

898
00:41:26,880 --> 00:41:29,160
able to decode it get the hash and then

899
00:41:29,160 --> 00:41:32,190
form this particular format of locking

900
00:41:32,190 --> 00:41:35,339
script so a one address I need any

901
00:41:35,339 --> 00:41:37,380
address begins with the one corresponds

902
00:41:37,380 --> 00:41:39,059
to this particular type of lock in

903
00:41:39,059 --> 00:41:43,049
script and any address you find the

904
00:41:43,049 --> 00:41:45,859
start with a three correspond to this

905
00:41:45,859 --> 00:41:49,079
kind of locking script so it's typically

906
00:41:49,079 --> 00:41:51,539
going to be you know a paid to multi-sig

907
00:41:51,539 --> 00:41:55,319
or more recently pay into a segregated

908
00:41:55,319 --> 00:41:57,720
witness type transaction which I'm not

909
00:41:57,720 --> 00:42:00,299
going to cover here but segregated

910
00:42:00,299 --> 00:42:03,660
witness has used this format for locking

911
00:42:03,660 --> 00:42:08,579
up their coins so that's page script

912
00:42:08,579 --> 00:42:10,829
hash then that's the most complex part

913
00:42:10,829 --> 00:42:12,839
of this whole presentation so if that

914
00:42:12,839 --> 00:42:14,220
made sense then everything else gonna be

915
00:42:14,220 --> 00:42:14,549
easy

916
00:42:14,549 --> 00:42:17,190
um but this is just like a special form

917
00:42:17,190 --> 00:42:19,170
that gets asked executed slightly

918
00:42:19,170 --> 00:42:23,670
differently finally the last standard

919
00:42:23,670 --> 00:42:26,130
script that gets used in Bitcoin it's

920
00:42:26,130 --> 00:42:30,539
called a null data locking script and

921
00:42:30,539 --> 00:42:33,569
that uses this up code called opie

922
00:42:33,569 --> 00:42:37,559
return or just return and what this our

923
00:42:37,559 --> 00:42:40,650
code does it invalidates the script so

924
00:42:40,650 --> 00:42:43,319
no matter what you put in the unlocking

925
00:42:43,319 --> 00:42:46,739
code whenever you run or a node runs

926
00:42:46,739 --> 00:42:49,309
this

927
00:42:51,160 --> 00:42:54,340
up code it's going to invalidate the

928
00:42:54,340 --> 00:42:56,620
script which means that this batch of

929
00:42:56,620 --> 00:43:00,250
bitcoins can never be spent so why would

930
00:43:00,250 --> 00:43:02,110
you do that it seems quite pointless why

931
00:43:02,110 --> 00:43:03,340
would you create a batch of bitcoins

932
00:43:03,340 --> 00:43:06,070
that can never be spent well what

933
00:43:06,070 --> 00:43:08,910
typically happens in Bitcoin is they

934
00:43:08,910 --> 00:43:11,560
someone will create a transaction but

935
00:43:11,560 --> 00:43:15,190
then they'll also create a output with

936
00:43:15,190 --> 00:43:17,680
no bitcoins in it so like an like almost

937
00:43:17,680 --> 00:43:19,900
like a dummy output and in the locking

938
00:43:19,900 --> 00:43:21,730
script they'll put the return opcode in

939
00:43:21,730 --> 00:43:24,010
there so it can't be spent but there's

940
00:43:24,010 --> 00:43:25,750
no bitcoins in there so you know be

941
00:43:25,750 --> 00:43:28,540
spent anyway and then after the return

942
00:43:28,540 --> 00:43:31,330
up code they'll just put some data after

943
00:43:31,330 --> 00:43:34,720
it for example you could take the text

944
00:43:34,720 --> 00:43:36,940
will you marry me convert to text XML

945
00:43:36,940 --> 00:43:39,880
hexadecimal and put it in the lock in

946
00:43:39,880 --> 00:43:42,280
script after this return up code and

947
00:43:42,280 --> 00:43:49,060
this is a standard format for a or

948
00:43:49,060 --> 00:43:51,990
standard transaction format so basically

949
00:43:51,990 --> 00:43:57,580
this format is just a way of adding some

950
00:43:57,580 --> 00:44:00,610
arbitrary data to a Bitcoin transaction

951
00:44:00,610 --> 00:44:02,920
so when you hear people inserting data

952
00:44:02,920 --> 00:44:06,760
into the blockchain this is the easiest

953
00:44:06,760 --> 00:44:10,690
way for a typical person creating a

954
00:44:10,690 --> 00:44:12,370
transaction to add data to the

955
00:44:12,370 --> 00:44:14,620
blockchain you just create an empty

956
00:44:14,620 --> 00:44:17,350
output and on the locking script use the

957
00:44:17,350 --> 00:44:20,680
return opcode and put any teacher in

958
00:44:20,680 --> 00:44:23,050
after it that you want

959
00:44:23,050 --> 00:44:30,670
that make sense okay so that is the top

960
00:44:30,670 --> 00:44:33,610
five or five main standard scripts using

961
00:44:33,610 --> 00:44:38,320
bitcoins if you yeah is the use of the

962
00:44:38,320 --> 00:44:42,370
return keyword kind of okay with the

963
00:44:42,370 --> 00:44:46,770
community or the they are not very happy

964
00:44:49,740 --> 00:44:51,970
sound very interesting right yeah I

965
00:44:51,970 --> 00:44:53,500
think it is a bit controversial because

966
00:44:53,500 --> 00:44:55,750
it kind should just be like a simple

967
00:44:55,750 --> 00:44:58,650
transaction system but this noble turn

968
00:44:58,650 --> 00:45:03,070
I'm not sure why yeah it was sort of

969
00:45:03,070 --> 00:45:05,530
allowed or why it's allowed in a way I

970
00:45:05,530 --> 00:45:08,230
don't understand because bitcoin is

971
00:45:08,230 --> 00:45:10,660
quite strict really with you know it

972
00:45:10,660 --> 00:45:14,020
wants to be a small database and this

973
00:45:14,020 --> 00:45:18,010
just allows people to so I'm not sure a

974
00:45:18,010 --> 00:45:20,860
bit but for the time being for now this

975
00:45:20,860 --> 00:45:25,180
is a allowed standard script that you

976
00:45:25,180 --> 00:45:27,610
can use to insert arbitrary data into

977
00:45:27,610 --> 00:45:30,420
the blog chain through transactions

978
00:45:30,420 --> 00:45:33,850
anyway so coming back to your question

979
00:45:33,850 --> 00:45:35,710
earlier these are the standard scripts

980
00:45:35,710 --> 00:45:37,750
that you're most commonly see on the

981
00:45:37,750 --> 00:45:40,540
blockchain these top four obviously just

982
00:45:40,540 --> 00:45:43,240
pay public keys this fifth one just like

983
00:45:43,240 --> 00:45:46,310
an extra additional one

984
00:45:46,310 --> 00:45:50,850
but inside the script pro mini

985
00:45:50,850 --> 00:45:53,040
programming language you have a wide

986
00:45:53,040 --> 00:45:55,080
variety of different operators so far

987
00:45:55,080 --> 00:45:57,119
I've just covered these ones standard

988
00:45:57,119 --> 00:45:59,190
scripts but you might have noticed that

989
00:45:59,190 --> 00:46:01,890
we have these little numbers up codes

990
00:46:01,890 --> 00:46:04,800
just just numbers then we also have some

991
00:46:04,800 --> 00:46:06,450
other operators like mathematical winds

992
00:46:06,450 --> 00:46:08,750
like addition and subtraction

993
00:46:08,750 --> 00:46:11,010
conditional operators if and else and

994
00:46:11,010 --> 00:46:17,430
then or sorry more hashing operators you

995
00:46:17,430 --> 00:46:20,580
know like sha-256 and ymd 160 so you

996
00:46:20,580 --> 00:46:22,740
know this script programming language

997
00:46:22,740 --> 00:46:25,470
has a quite a few different opera op

998
00:46:25,470 --> 00:46:27,030
codes that we can use to create

999
00:46:27,030 --> 00:46:29,130
different types of scripts so for

1000
00:46:29,130 --> 00:46:32,750
example you could create a put a lock on

1001
00:46:32,750 --> 00:46:35,520
top of a batch of bitcoins there's just

1002
00:46:35,520 --> 00:46:37,590
a mathematical puzzle so you could use

1003
00:46:37,590 --> 00:46:41,190
add 8 and then equal so when when

1004
00:46:41,190 --> 00:46:42,570
someone comes to want to unlock this

1005
00:46:42,570 --> 00:46:43,770
script if they want to unlock it and

1006
00:46:43,770 --> 00:46:46,380
spend it all they need to do is provide

1007
00:46:46,380 --> 00:46:49,650
two numbers that when you add them then

1008
00:46:49,650 --> 00:46:51,359
so basically two numbers get pushed onto

1009
00:46:51,359 --> 00:46:53,550
the stack add will take those two add

1010
00:46:53,550 --> 00:46:55,530
them push them back onto the stack eight

1011
00:46:55,530 --> 00:46:57,390
goes on top of the stack and if those

1012
00:46:57,390 --> 00:46:59,250
two items on top of the stack are equal

1013
00:46:59,250 --> 00:47:02,430
then the bitcoins can be spent so for

1014
00:47:02,430 --> 00:47:04,380
example to unlock this batch of bitcoins

1015
00:47:04,380 --> 00:47:06,420
in the unlocking script you just need to

1016
00:47:06,420 --> 00:47:08,600
provide two numbers that add up to eight

1017
00:47:08,600 --> 00:47:13,050
like so similarly you could create a

1018
00:47:13,050 --> 00:47:15,930
hash puzzle so you could use a char 256

1019
00:47:15,930 --> 00:47:18,420
up code put some data in there after it

1020
00:47:18,420 --> 00:47:22,260
and then the equal up code so if you

1021
00:47:22,260 --> 00:47:23,820
want to unlock this batch of bitcoins

1022
00:47:23,820 --> 00:47:25,710
all you need to do is provide some data

1023
00:47:25,710 --> 00:47:30,600
that's hashes to this piece of data in

1024
00:47:30,600 --> 00:47:35,400
the locking code so this kind of locking

1025
00:47:35,400 --> 00:47:37,170
script you can find these on the

1026
00:47:37,170 --> 00:47:40,080
blockchain I haven't got any links off

1027
00:47:40,080 --> 00:47:42,450
the top of my head but you know you can

1028
00:47:42,450 --> 00:47:44,790
create scripts like these and they can

1029
00:47:44,790 --> 00:47:50,000
be mined onto the Bachchan however

1030
00:47:50,000 --> 00:47:53,970
in Bitcoin you can't create a

1031
00:47:53,970 --> 00:47:56,640
non-standard script but if you're trying

1032
00:47:56,640 --> 00:48:00,780
to insert it into a Bitcoin core node so

1033
00:48:00,780 --> 00:48:02,850
the Bitcoin coin program implementation

1034
00:48:02,850 --> 00:48:06,000
it actually keeps a list of standard

1035
00:48:06,000 --> 00:48:07,950
scripts so if you create one that is

1036
00:48:07,950 --> 00:48:10,940
non-standard they actually rejected

1037
00:48:10,940 --> 00:48:15,150
which is a bit of shame the reason for

1038
00:48:15,150 --> 00:48:19,430
that is as far as I'm aware it's because

1039
00:48:19,430 --> 00:48:22,230
there's a wide variety of these up codes

1040
00:48:22,230 --> 00:48:24,420
and operators and not all combinations

1041
00:48:24,420 --> 00:48:27,240
of them have been thoroughly tested so

1042
00:48:27,240 --> 00:48:29,640
it could be that someone could create a

1043
00:48:29,640 --> 00:48:32,040
combination of up codes that when they

1044
00:48:32,040 --> 00:48:35,310
insert the transaction into a node the

1045
00:48:35,310 --> 00:48:37,680
node might end up taking a while to

1046
00:48:37,680 --> 00:48:40,800
process it or validate it so all of the

1047
00:48:40,800 --> 00:48:43,170
standard scripts are known to be run

1048
00:48:43,170 --> 00:48:45,420
quickly and you know can be validated

1049
00:48:45,420 --> 00:48:48,270
quickly so to protect against anyone

1050
00:48:48,270 --> 00:48:50,280
trying to attack the network by creating

1051
00:48:50,280 --> 00:48:54,510
you know thousands of slow or expensive

1052
00:48:54,510 --> 00:48:56,460
to verify scripts and insert and enter

1053
00:48:56,460 --> 00:48:59,700
them into a node a Bitcoin or Bitcoin

1054
00:48:59,700 --> 00:49:01,290
core node will actually just reject

1055
00:49:01,290 --> 00:49:03,570
anything that's non-standard which i

1056
00:49:03,570 --> 00:49:05,700
think is a bit aim because you know

1057
00:49:05,700 --> 00:49:08,370
script it's a simple language but it

1058
00:49:08,370 --> 00:49:10,830
does have a variety of operators to use

1059
00:49:10,830 --> 00:49:13,860
and create scripts with but Bitcoin core

1060
00:49:13,860 --> 00:49:16,320
limits the number all the types of

1061
00:49:16,320 --> 00:49:17,910
scripts you can put on batches of

1062
00:49:17,910 --> 00:49:23,700
bitcoins however none that doesn't mean

1063
00:49:23,700 --> 00:49:25,380
that nonce on standard scripts are

1064
00:49:25,380 --> 00:49:28,080
actually invalid even though a Bitcoin

1065
00:49:28,080 --> 00:49:31,770
core node will reject them or not accept

1066
00:49:31,770 --> 00:49:34,350
them into their memory pools if a

1067
00:49:34,350 --> 00:49:36,330
non-standard script were to be mined

1068
00:49:36,330 --> 00:49:39,120
onto the blockchain then those blocks

1069
00:49:39,120 --> 00:49:41,820
would be valid so as long as the actual

1070
00:49:41,820 --> 00:49:47,220
script itself is valid you know contains

1071
00:49:47,220 --> 00:49:49,710
all the standard operators and data if

1072
00:49:49,710 --> 00:49:52,590
it gets mind into a block every noodle

1073
00:49:52,590 --> 00:49:56,850
accept it but they won't accept it if a

1074
00:49:56,850 --> 00:49:58,080
non-standard script

1075
00:49:58,080 --> 00:50:00,000
tries to enter their mempool

1076
00:50:00,000 --> 00:50:02,040
and the reason for that is the memory

1077
00:50:02,040 --> 00:50:03,570
pool can receive a large quantity of

1078
00:50:03,570 --> 00:50:04,980
transactions in a small period of time

1079
00:50:04,980 --> 00:50:08,160
so you know you could create a slow to

1080
00:50:08,160 --> 00:50:11,070
verify transaction and try and insert

1081
00:50:11,070 --> 00:50:13,200
thousands into the network which could

1082
00:50:13,200 --> 00:50:14,970
bring the network down because everyone

1083
00:50:14,970 --> 00:50:16,500
slowly trying to verify all these

1084
00:50:16,500 --> 00:50:18,360
non-standard transactions

1085
00:50:18,360 --> 00:50:23,690
however a block can only hold the

1086
00:50:23,690 --> 00:50:26,280
limited number of transactions so if

1087
00:50:26,280 --> 00:50:28,290
someone did insert you know stow to

1088
00:50:28,290 --> 00:50:31,350
verify transactions into a block because

1089
00:50:31,350 --> 00:50:32,760
blocks only get added every 10 minutes

1090
00:50:32,760 --> 00:50:35,070
they'll probably be validated it be

1091
00:50:35,070 --> 00:50:38,970
easier to validate them or be an ass of

1092
00:50:38,970 --> 00:50:42,060
a problem whereas having thousands of

1093
00:50:42,060 --> 00:50:44,280
non-standard scripts hit in the memory

1094
00:50:44,280 --> 00:50:48,080
pool could be a big risk but like I said

1095
00:50:48,080 --> 00:50:50,370
non-standard scripts are valid but

1096
00:50:50,370 --> 00:50:52,080
unfortunately it's hard to get their

1097
00:50:52,080 --> 00:50:55,860
mind onto the blockchain so I'm not sure

1098
00:50:55,860 --> 00:50:58,140
how you'll end up getting it mind if the

1099
00:50:58,140 --> 00:51:00,450
nodes don't accept it because even a

1100
00:51:00,450 --> 00:51:07,980
minor is like yeah right so yeah don't

1101
00:51:07,980 --> 00:51:10,890
make that make sense so options you have

1102
00:51:10,890 --> 00:51:14,970
which aren't many options is one to send

1103
00:51:14,970 --> 00:51:18,240
your non-standard transaction to a minor

1104
00:51:18,240 --> 00:51:21,810
who will accept them and will add it to

1105
00:51:21,810 --> 00:51:25,470
the proxy for you which I don't know of

1106
00:51:25,470 --> 00:51:26,640
any miners that you can send a

1107
00:51:26,640 --> 00:51:29,460
non-standard transaction to or secondly

1108
00:51:29,460 --> 00:51:32,190
which is an option but not necessarily

1109
00:51:32,190 --> 00:51:34,470
easy is just to mine it onto the pocket

1110
00:51:34,470 --> 00:51:37,110
in yourself so unless effort however

1111
00:51:37,110 --> 00:51:38,610
unless you've got a lot of processing

1112
00:51:38,610 --> 00:51:40,860
power that's gonna be a bit tricky so

1113
00:51:40,860 --> 00:51:43,080
you know practically you know you are

1114
00:51:43,080 --> 00:51:44,910
right you're probably not going to be

1115
00:51:44,910 --> 00:51:46,680
able to get a non-standard transactions

1116
00:51:46,680 --> 00:51:48,420
into the blockchain which is a very

1117
00:51:48,420 --> 00:51:52,830
shame however like I said it's only the

1118
00:51:52,830 --> 00:51:56,070
Bitcoin core implementation that keeps a

1119
00:51:56,070 --> 00:51:58,140
list i don't well it might be other ones

1120
00:51:58,140 --> 00:52:01,320
but you could create your Bitcoin node

1121
00:52:01,320 --> 00:52:03,210
written in your own programming language

1122
00:52:03,210 --> 00:52:06,090
with your own rules and you could accept

1123
00:52:06,090 --> 00:52:08,130
non-standard scripts but if there's no

1124
00:52:08,130 --> 00:52:09,630
one else you know on the network when in

1125
00:52:09,630 --> 00:52:11,370
your same software every time you try

1126
00:52:11,370 --> 00:52:12,549
and be lame

1127
00:52:12,549 --> 00:52:14,009
Bitcoin core knows they're just gonna

1128
00:52:14,009 --> 00:52:18,160
reject them so yeah for all intents and

1129
00:52:18,160 --> 00:52:19,349
purposes

1130
00:52:19,349 --> 00:52:21,910
unfortunately non-standard scripts are

1131
00:52:21,910 --> 00:52:25,239
not really going to be used and mind

1132
00:52:25,239 --> 00:52:27,400
onto the blockchain in Bitcoin at the

1133
00:52:27,400 --> 00:52:32,160
moment which i think is a bit of a shame

1134
00:52:34,769 --> 00:52:36,459
finally ok so that's basically

1135
00:52:36,459 --> 00:52:38,259
everything you need to know about script

1136
00:52:38,259 --> 00:52:39,969
and how it works if you understand all

1137
00:52:39,969 --> 00:52:41,410
these op codes and data and the stack

1138
00:52:41,410 --> 00:52:43,689
that's just how script works it's just a

1139
00:52:43,689 --> 00:52:45,579
mini programming language that executes

1140
00:52:45,579 --> 00:52:49,089
on a stack and if there's a one left on

1141
00:52:49,089 --> 00:52:50,859
top of the stack at the end the script

1142
00:52:50,859 --> 00:52:52,859
is valid and the bitcoins can be spent

1143
00:52:52,859 --> 00:52:57,359
so you know it was always like this or

1144
00:52:57,359 --> 00:52:59,709
more recently they actually stopped

1145
00:52:59,709 --> 00:53:01,420
allowing it because they probably wanted

1146
00:53:01,420 --> 00:53:06,059
to reduce the size of the block yeah I

1147
00:53:06,059 --> 00:53:12,729
think I think the standard you know

1148
00:53:12,729 --> 00:53:17,589
having this set of standard scripts was

1149
00:53:17,589 --> 00:53:20,769
in Bitcoin from the start but from what

1150
00:53:20,769 --> 00:53:24,789
I understand I know the restriction of

1151
00:53:24,789 --> 00:53:27,819
non-standard yeah I think ultimately it

1152
00:53:27,819 --> 00:53:31,569
was planned for it to be lifted so but

1153
00:53:31,569 --> 00:53:39,449
it hasn't happened so yeah so finally

1154
00:53:39,449 --> 00:53:41,979
where do you find you know I've done

1155
00:53:41,979 --> 00:53:44,199
I've just used simple you know locking

1156
00:53:44,199 --> 00:53:46,809
script and locking script you know

1157
00:53:46,809 --> 00:53:50,469
little diagrams to symbolize it where'd

1158
00:53:50,469 --> 00:53:51,939
you find this actual a knocking code

1159
00:53:51,939 --> 00:53:55,529
inside transaction data well like I said

1160
00:53:55,529 --> 00:53:58,209
when you make a Bitcoin transaction you

1161
00:53:58,209 --> 00:54:01,929
say this is transaction data you the

1162
00:54:01,929 --> 00:54:03,609
first part of transaction data just

1163
00:54:03,609 --> 00:54:05,319
selects an input so that's selecting

1164
00:54:05,319 --> 00:54:07,059
this input here and the second part

1165
00:54:07,059 --> 00:54:09,819
creates the output and so inside this

1166
00:54:09,819 --> 00:54:13,449
output code of transaction data contains

1167
00:54:13,449 --> 00:54:16,630
the script pub key which is the lock in

1168
00:54:16,630 --> 00:54:19,619
script so this part here this first part

1169
00:54:19,619 --> 00:54:23,109
is the amount of bitcoins and the second

1170
00:54:23,109 --> 00:54:24,090
part

1171
00:54:24,090 --> 00:54:26,160
I think I've highlighted I finally that

1172
00:54:26,160 --> 00:54:27,330
I did this a bit wrong but don't worry

1173
00:54:27,330 --> 00:54:31,140
this second part here is the script pub

1174
00:54:31,140 --> 00:54:33,450
key so move that there that is the

1175
00:54:33,450 --> 00:54:36,330
locking script as found inside

1176
00:54:36,330 --> 00:54:39,120
transaction data so where is the

1177
00:54:39,120 --> 00:54:41,090
unlocking script for this particular

1178
00:54:41,090 --> 00:54:44,220
locking script well that will appear in

1179
00:54:44,220 --> 00:54:47,240
a second transaction that tries to spend

1180
00:54:47,240 --> 00:54:50,850
this batch of bitcoins or this output so

1181
00:54:50,850 --> 00:54:52,920
in this second transaction you have an

1182
00:54:52,920 --> 00:54:55,230
input which all that does really is

1183
00:54:55,230 --> 00:54:58,350
reference an output from a previous

1184
00:54:58,350 --> 00:55:00,690
transaction so that's referencing this

1185
00:55:00,690 --> 00:55:02,760
year and the second transaction will

1186
00:55:02,760 --> 00:55:05,790
also create new outputs from it but what

1187
00:55:05,790 --> 00:55:07,680
we're interested in here in the second

1188
00:55:07,680 --> 00:55:10,920
transaction is the unlocking code so

1189
00:55:10,920 --> 00:55:14,330
when it references this previous output

1190
00:55:14,330 --> 00:55:18,290
inside the input sits the unlocking code

1191
00:55:18,290 --> 00:55:21,240
so this here is the unlocking code and

1192
00:55:21,240 --> 00:55:23,520
this is also referred to sometimes as a

1193
00:55:23,520 --> 00:55:25,950
script sig because it's a script and it

1194
00:55:25,950 --> 00:55:28,320
typically contains the signature for the

1195
00:55:28,320 --> 00:55:31,200
public key so there we have the

1196
00:55:31,200 --> 00:55:35,730
unlocking code so this is obviously or

1197
00:55:35,730 --> 00:55:41,370
in hexadecimal how do we get the opcodes

1198
00:55:41,370 --> 00:55:46,910
out of this well just need to decode it

1199
00:55:46,910 --> 00:55:49,380
if you weren't if we run through every

1200
00:55:49,380 --> 00:55:51,030
single byte inside the lock in script

1201
00:55:51,030 --> 00:55:53,520
and the unlocking script each byte will

1202
00:55:53,520 --> 00:55:56,750
correspond to a particular up code so

1203
00:55:56,750 --> 00:56:01,200
the byte in hexadecimal 76 is equal to

1204
00:56:01,200 --> 00:56:05,910
the tip or duplicate up code so there we

1205
00:56:05,910 --> 00:56:07,170
are a nine

1206
00:56:07,170 --> 00:56:12,810
that is hash 160 14 14 isn't actually

1207
00:56:12,810 --> 00:56:15,650
that doesn't have a corresponding opcode

1208
00:56:15,650 --> 00:56:19,080
but if anything is below for B in

1209
00:56:19,080 --> 00:56:22,440
hexadecimal what that means is that this

1210
00:56:22,440 --> 00:56:26,520
number indicates that this many bytes is

1211
00:56:26,520 --> 00:56:29,610
the piece of data to be pushed onto the

1212
00:56:29,610 --> 00:56:30,710
stack

1213
00:56:30,710 --> 00:56:35,000
so 14 is below for beef that says push

1214
00:56:35,000 --> 00:56:37,040
this many bytes onto the stack or this

1215
00:56:37,040 --> 00:56:39,950
is just the data and not an opcode so 14

1216
00:56:39,950 --> 00:56:43,730
in decimal is 20 bytes so there we have

1217
00:56:43,730 --> 00:56:45,560
this next 20 bytes it's just a piece of

1218
00:56:45,560 --> 00:56:50,510
data then carrying on we have 8 8 that's

1219
00:56:50,510 --> 00:56:53,870
equal verify and AC which is check sick

1220
00:56:53,870 --> 00:56:55,280
so then we ha

1221
00:56:55,280 --> 00:56:58,610
we've just decoded the docking script

1222
00:56:58,610 --> 00:57:01,010
it's just a bunch of bytes correspondent

1223
00:57:01,010 --> 00:57:01,490
opcodes

1224
00:57:01,490 --> 00:57:03,350
and if a byte is below a certain number

1225
00:57:03,350 --> 00:57:06,260
then that means the next X number of

1226
00:57:06,260 --> 00:57:10,190
bytes is a bunch of data so there we are

1227
00:57:10,190 --> 00:57:12,290
that's locking script decoded then we

1228
00:57:12,290 --> 00:57:14,000
come to the unlocking script and if you

1229
00:57:14,000 --> 00:57:16,330
remember all the unlocking script is is

1230
00:57:16,330 --> 00:57:19,970
free this particular kind of lock is

1231
00:57:19,970 --> 00:57:23,000
just a signature and a public key so 4 7

1232
00:57:23,000 --> 00:57:25,100
that's lesson for B so that's saying

1233
00:57:25,100 --> 00:57:28,520
this number of bytes is just in data and

1234
00:57:28,520 --> 00:57:32,180
that is the signature and then for when

1235
00:57:32,180 --> 00:57:34,550
this number of bytes and that is just a

1236
00:57:34,550 --> 00:57:35,990
more data again which is going to be the

1237
00:57:35,990 --> 00:57:39,500
public key so there we ha just decoded

1238
00:57:39,500 --> 00:57:44,570
the locking and unlocking script so make

1239
00:57:44,570 --> 00:57:50,600
sense ok so yeah the locking scripts can

1240
00:57:50,600 --> 00:57:51,290
be found

1241
00:57:51,290 --> 00:57:53,830
locking script is inside the output of

1242
00:57:53,830 --> 00:57:56,540
one transaction and then the Enochian

1243
00:57:56,540 --> 00:58:00,440
script is found in the input of a new

1244
00:58:00,440 --> 00:58:03,320
transaction that tries to spend the

1245
00:58:03,320 --> 00:58:05,740
image output

1246
00:58:06,560 --> 00:58:09,510
so there we are summarize now everything

1247
00:58:09,510 --> 00:58:13,170
that we've done in this video in a

1248
00:58:13,170 --> 00:58:14,610
Bitcoin transaction you just take a

1249
00:58:14,610 --> 00:58:16,440
batch of bitcoins akut create a new

1250
00:58:16,440 --> 00:58:18,720
batch from it and what do you want to

1251
00:58:18,720 --> 00:58:21,000
send it someone else they'll have a

1252
00:58:21,000 --> 00:58:24,900
public key they'll give you you know

1253
00:58:24,900 --> 00:58:28,290
probably an address and then your

1254
00:58:28,290 --> 00:58:32,160
construct the locking script for them

1255
00:58:32,160 --> 00:58:35,520
and lock up bitcoins until they either

1256
00:58:35,520 --> 00:58:37,410
the public key or the hash of their

1257
00:58:37,410 --> 00:58:41,430
public key so this one here this is this

1258
00:58:41,430 --> 00:58:42,990
particular format it's called pay to pop

1259
00:58:42,990 --> 00:58:47,580
key hash this is the locking script so

1260
00:58:47,580 --> 00:58:50,190
when you want to come to or this person

1261
00:58:50,190 --> 00:58:52,440
wants to come to spend these bitcoins

1262
00:58:52,440 --> 00:58:54,480
they will need to provide an unlocking

1263
00:58:54,480 --> 00:58:57,930
script like so and then this script will

1264
00:58:57,930 --> 00:59:00,480
get run so the unlocking script gets

1265
00:59:00,480 --> 00:59:02,460
provided second in the second

1266
00:59:02,460 --> 00:59:04,800
transaction but when we come to run the

1267
00:59:04,800 --> 00:59:06,960
full script together we put this at the

1268
00:59:06,960 --> 00:59:09,210
start so this gets added to the stack

1269
00:59:09,210 --> 00:59:11,609
first and then we run the script using

1270
00:59:11,609 --> 00:59:14,940
the opcodes and data and if a one is

1271
00:59:14,940 --> 00:59:16,800
left on the stack after you've run the

1272
00:59:16,800 --> 00:59:18,600
entire script then this batch of

1273
00:59:18,600 --> 00:59:21,780
bitcoins or the script is valid and this

1274
00:59:21,780 --> 00:59:23,520
batch bitcoins can be successfully

1275
00:59:23,520 --> 00:59:27,320
unlocked and spent and that is how the

1276
00:59:27,320 --> 00:59:31,710
mechanism for locking up bitcoins works

1277
00:59:31,710 --> 00:59:34,080
it works using this mini programming

1278
00:59:34,080 --> 00:59:36,210
language poor script that contains data

1279
00:59:36,210 --> 00:59:39,030
and up codes and it all works on top of

1280
00:59:39,030 --> 00:59:43,859
a stack this script has lots of

1281
00:59:43,859 --> 00:59:44,790
different approach

1282
00:59:44,790 --> 00:59:50,700
like so however we are the Bitcoin core

1283
00:59:50,700 --> 00:59:52,980
implementation kony restricts you to

1284
00:59:52,980 --> 00:59:57,240
these five main formats for locking up

1285
00:59:57,240 --> 00:59:59,780
bitcoins

1286
00:59:59,780 --> 01:00:01,520
and these are the four words you've got

1287
01:00:01,520 --> 01:00:03,200
Peter pepper key hash which is the most

1288
01:00:03,200 --> 01:00:05,780
commonly one used got Peter purp key

1289
01:00:05,780 --> 01:00:08,360
which is a simplified version of Peter

1290
01:00:08,360 --> 01:00:12,080
pop key hash but it's not really used

1291
01:00:12,080 --> 01:00:14,780
these days this page cache is the most

1292
01:00:14,780 --> 01:00:18,320
common one there we have Peter multi-sig

1293
01:00:18,320 --> 01:00:20,180
and then paint a script hash which is

1294
01:00:20,180 --> 01:00:22,220
just the easier way to pass around a

1295
01:00:22,220 --> 01:00:25,730
painting multi-sig lock in script like

1296
01:00:25,730 --> 01:00:31,940
so there we have script and how batches

1297
01:00:31,940 --> 01:00:33,800
of bitcoins are locked and unlocked in

1298
01:00:33,800 --> 01:00:36,850
Bitcoin any questions about that

1299
01:00:36,850 --> 01:00:40,780
presentation or any part of it

1300
01:00:40,780 --> 01:00:46,630
okay it's less tender than presentation

1301
01:00:46,630 --> 01:00:49,520
if that made sense then you understand

1302
01:00:49,520 --> 01:00:50,780
that script works I don't think it's

1303
01:00:50,780 --> 01:00:53,330
terribly difficult there only a few you

1304
01:00:53,330 --> 01:00:57,020
know things to note about the paid to

1305
01:00:57,020 --> 01:01:01,070
script hash part but the actual

1306
01:01:01,070 --> 01:01:02,840
execution of stuff is quite simple just

1307
01:01:02,840 --> 01:01:10,540
a simple programming language so yeah

1308
01:01:10,540 --> 01:01:12,890
involving and the other ones are pretty

1309
01:01:12,890 --> 01:01:16,790
yeah this page script hash he was sort

1310
01:01:16,790 --> 01:01:18,560
of added on to Bitcoin later on so it

1311
01:01:18,560 --> 01:01:19,430
wasn't part of the original

1312
01:01:19,430 --> 01:01:22,760
implementation so that's why it feels a

1313
01:01:22,760 --> 01:01:27,380
bit hacky I suppose but you know we were

1314
01:01:27,380 --> 01:01:29,150
sort of added on so it has these extra

1315
01:01:29,150 --> 01:01:34,640
rules of validation I made a little I

1316
01:01:34,640 --> 01:01:39,230
wrote some little bit of code to that

1317
01:01:39,230 --> 01:01:42,560
will basically decode or encode a script

1318
01:01:42,560 --> 01:01:45,860
and run it for you so if you wanted to

1319
01:01:45,860 --> 01:01:47,720
play with it it's very simple I wouldn't

1320
01:01:47,720 --> 01:01:51,230
use it properly in production it's more

1321
01:01:51,230 --> 01:01:52,880
just for us all of you know to learn

1322
01:01:52,880 --> 01:01:54,380
from it just to see how simple the

1323
01:01:54,380 --> 01:01:58,560
script is so for example

1324
01:01:58,560 --> 01:02:02,230
once cryptic odor it'll take a lock in

1325
01:02:02,230 --> 01:02:05,589
script so here's a typical Bitcoin

1326
01:02:05,589 --> 01:02:10,300
transaction obviously locking script and

1327
01:02:10,300 --> 01:02:11,829
unlocking scripted even provided for it

1328
01:02:11,829 --> 01:02:14,980
so it's been spent but say you wanted to

1329
01:02:14,980 --> 01:02:18,609
decode some script you can put the

1330
01:02:18,609 --> 01:02:21,369
locking script in there it's identified

1331
01:02:21,369 --> 01:02:23,619
that as a to pop key hash because it has

1332
01:02:23,619 --> 01:02:26,800
a special format so it's off to you

1333
01:02:26,800 --> 01:02:29,950
decoded it there and then when you want

1334
01:02:29,950 --> 01:02:31,630
to unlock something you need to provide

1335
01:02:31,630 --> 01:02:35,619
the locking script so there we are

1336
01:02:35,619 --> 01:02:38,230
this is just two pieces of data there's

1337
01:02:38,230 --> 01:02:40,030
no up codes in it so I want to run this

1338
01:02:40,030 --> 01:02:42,220
script and this little program will just

1339
01:02:42,220 --> 01:02:45,490
run it for you just to simulate it so

1340
01:02:45,490 --> 01:02:48,369
this is the entire script if I can pull

1341
01:02:48,369 --> 01:02:51,520
this across anyway so it's basically

1342
01:02:51,520 --> 01:02:54,339
just one big array of all the individual

1343
01:02:54,339 --> 01:02:57,579
pieces of the script so let's say this

1344
01:02:57,579 --> 01:03:00,670
is the stack here it pushes the data on

1345
01:03:00,670 --> 01:03:03,369
to the stack then this is the remainder

1346
01:03:03,369 --> 01:03:05,500
of the script so we got dope duplicate

1347
01:03:05,500 --> 01:03:07,690
here I'll duplicate the top element hash

1348
01:03:07,690 --> 01:03:10,300
160 and they'll hash table moment then

1349
01:03:10,300 --> 01:03:14,020
we've got the public key hash I guess

1350
01:03:14,020 --> 01:03:16,540
pressed on top equal verify that I'll

1351
01:03:16,540 --> 01:03:17,980
take the top two elements and if they're

1352
01:03:17,980 --> 01:03:20,020
equal we'll push anything back onto the

1353
01:03:20,020 --> 01:03:23,079
stack so after we've executed this these

1354
01:03:23,079 --> 01:03:24,849
two elements should disappear because

1355
01:03:24,849 --> 01:03:27,250
they are equal and then hope you check

1356
01:03:27,250 --> 01:03:31,200
sig so this will check this public key

1357
01:03:31,200 --> 01:03:34,089
against this signature and there we are

1358
01:03:34,089 --> 01:03:36,940
and so we'll push true on to the stack

1359
01:03:36,940 --> 01:03:39,069
true isn't actually using Bitcoin it

1360
01:03:39,069 --> 01:03:41,710
should be one but same thing so there we

1361
01:03:41,710 --> 01:03:44,650
are that's a valid script so I'll add a

1362
01:03:44,650 --> 01:03:47,589
link to this into the description if you

1363
01:03:47,589 --> 01:03:49,030
want to play with this code it's just

1364
01:03:49,030 --> 01:03:50,920
there so you can sort of see how the

1365
01:03:50,920 --> 01:03:53,219
code runs

1366
01:03:53,219 --> 01:03:58,359
alternatively if you go on Bitcoin dye

1367
01:03:58,359 --> 01:04:01,689
t4 just Wiki going to the script page it

1368
01:04:01,689 --> 01:04:04,749
covers all the different up codes that

1369
01:04:04,749 --> 01:04:06,609
you can use so I was you can see there's

1370
01:04:06,609 --> 01:04:08,439
quite a few I only really scratched the

1371
01:04:08,439 --> 01:04:10,539
surface of all the ones you can use but

1372
01:04:10,539 --> 01:04:12,279
like I said unfortunately we are

1373
01:04:12,279 --> 01:04:14,859
restricted really to only be able to use

1374
01:04:14,859 --> 01:04:17,829
the standard scripts even though script

1375
01:04:17,829 --> 01:04:19,719
does contain all these various different

1376
01:04:19,719 --> 01:04:26,640
codes lastly I found this little IDE

1377
01:04:26,640 --> 01:04:30,130
which allows you to enter a script and

1378
01:04:30,130 --> 01:04:32,289
it will visualize the running of the

1379
01:04:32,289 --> 01:04:35,829
script on the stack for you I think it

1380
01:04:35,829 --> 01:04:37,569
covers every single opcode so you know

1381
01:04:37,569 --> 01:04:43,569
you could add you know much more complex

1382
01:04:43,569 --> 01:04:47,619
script in here and then try and run it

1383
01:04:47,619 --> 01:04:52,719
and it will run it for you so I didn't

1384
01:04:52,719 --> 01:04:54,729
make this someone else did but it might

1385
01:04:54,729 --> 01:04:57,130
be a very good way to visualize how the

1386
01:04:57,130 --> 01:04:59,859
stack works and actually inserts your

1387
01:04:59,859 --> 01:05:02,439
own scripts and watch them run and it's

1388
01:05:02,439 --> 01:05:04,179
adhere I provide another link in the

1389
01:05:04,179 --> 01:05:09,009
description and then lastly if you want

1390
01:05:09,009 --> 01:05:11,799
to browse scripts on my blog in Explorer

1391
01:05:11,799 --> 01:05:18,009
go to any transaction as you can see

1392
01:05:18,009 --> 01:05:20,199
this is a transaction has inputs and

1393
01:05:20,199 --> 01:05:23,469
outputs click on the unlocking part or

1394
01:05:23,469 --> 01:05:25,390
the locking part and it will show you

1395
01:05:25,390 --> 01:05:28,390
the unlocking code also at the locking

1396
01:05:28,390 --> 01:05:30,249
code that was placed on top of the

1397
01:05:30,249 --> 01:05:33,029
transaction and this was the subsequent

1398
01:05:33,029 --> 01:05:37,569
and locking code so when you run this

1399
01:05:37,569 --> 01:05:39,309
all together you'll put this onto a

1400
01:05:39,309 --> 01:05:41,979
stack you should be able to visualize

1401
01:05:41,979 --> 01:05:44,339
you know it all working or hopefully

1402
01:05:44,339 --> 01:05:46,419
doesn't actually visualize anything for

1403
01:05:46,419 --> 01:05:48,999
you but you know all the opcodes and

1404
01:05:48,999 --> 01:05:50,380
data is there if you to look at and

1405
01:05:50,380 --> 01:05:52,979
maybe get a feel for

