00:00:00,030 --> 00:00:02,820
这个视频是关于脚本的内容。

00:00:02,820 --> 00:00:09,240
脚本就像是在比特币中用来锁定比特币的小型编程语言。

00:00:09,240 --> 00:00:15,000
当你要给别人发送比特币时，

00:00:15,000 --> 00:00:19,920
你实际上在这些比特币上面加了一个小型的编程语言来锁定它们。

00:00:19,920 --> 00:00:24,420
然后当他们要解锁它们时，

00:00:24,420 --> 00:00:26,849
他们需要提供更多的代码，

00:00:26,849 --> 00:00:30,080
当它与原始的锁定代码一起运行时，

00:00:30,080 --> 00:00:32,640
它将开始工作，这些比特币就可以被花费了。

00:00:32,640 --> 00:00:38,969
这就是脚本。

00:00:38,969 --> 00:00:43,860
让我们从上次的演示中继续，

00:00:43,860 --> 00:00:46,829
假设这是一批比特币，

00:00:46,829 --> 00:00:53,780
世界上存在的每一批比特币都有一个锁。

00:00:53,780 --> 00:00:56,430
当你想要进行交易时，

00:00:56,430 --> 00:01:00,090
你会解锁那批比特币，

00:01:00,090 --> 00:01:02,340
从中创建一批新的比特币，

00:01:02,340 --> 00:01:04,589
并在上面放一个新的锁，

00:01:04,589 --> 00:01:07,860
这就是一个简单的交易，

00:01:07,860 --> 00:01:09,900
只需取出一批比特币，

00:01:09,900 --> 00:01:11,880
解锁它们，创建新的批次并再次锁定它们。

00:01:11,880 --> 00:01:15,119
当你要进行新的交易时，

00:01:15,119 --> 00:01:18,330
你就再次做同样的事情，

00:01:18,330 --> 00:01:20,640
你只是解锁一个现有的批次，

00:01:20,640 --> 00:01:22,799
创建一个新的批次，

00:01:22,799 --> 00:01:25,140
并在上面放一个新的锁，

00:01:25,140 --> 00:01:27,990
这就是比特币交易系统的工作原理。

00:01:27,990 --> 00:01:31,170
这是简化的一系列交易，

00:01:31,170 --> 00:01:35,369
如果你想了解关于交易如何进行的更多信息，

00:01:35,369 --> 00:01:38,610
请观看我之前做的关于交易的视频。

00:01:38,610 --> 00:01:45,689
但这只涵盖了比特币批次的基本移动。

00:01:45,689 --> 00:01:51,810
所以这意味着当你想要给别人发送比特币时，

00:01:51,810 --> 00:01:55,560
你需要取出一批你可以解锁的比特币。

00:01:55,560 --> 00:02:00,000
比如说这是你，这是一批只有你可以解锁的比特币，

00:02:00,000 --> 00:02:02,219
我过一会儿会解释这是如何工作的，

00:02:02,219 --> 00:02:04,649
但现在请相信我，

00:02:04,649 --> 00:02:05,939
你是唯一可以解锁这批比特币的人。

00:02:05,939 --> 00:02:08,459
这就是你要做的，

00:02:08,459 --> 00:02:10,190
你想要给某人发送一些比特币。

00:02:10,190 --> 00:02:15,629
这个方法的工作原理是，

00:02:15,629 --> 00:02:17,250
你会创建一批带有锁的比特币。

00:02:17,250 --> 00:02:19,160
只有这个人可以解锁，

00:02:19,160 --> 00:02:25,709
这是因为在比特币中，

00:02:25,709 --> 00:02:28,620
每个人都有自己的私钥和公钥，

00:02:28,620 --> 00:02:33,180
这就像每个人都有自己的密码和账号一样。

00:02:33,180 --> 00:02:37,980
当你想要给某人发送比特币时，

00:02:37,980 --> 00:02:41,010
他们会给你他们的公钥，

00:02:41,010 --> 00:02:43,799
你将创建一个交易，

00:02:43,799 --> 00:02:46,769
并锁定一些你拥有的比特币，

00:02:46,769 --> 00:02:48,930
创建一批新的比特币，

00:02:48,930 --> 00:02:53,599
然后在这批比特币的锁上放置他们的公钥。

00:02:53,599 --> 00:02:56,519
这就是为什么这个人拥有这批比特币的原因，

00:02:56,519 --> 00:03:02,280
因为这批比特币的锁上包含了他们的公钥，

00:03:02,280 --> 00:03:07,230
这是他们的唯一账号。

00:03:07,230 --> 00:03:14,280
如果他们想要花费这批比特币或者发送给其他人，

00:03:14,280 --> 00:03:17,130
他们将使用他们的私钥，

00:03:17,130 --> 00:03:21,959
就像他们的账号的密码一样来解锁它。

00:03:21,959 --> 00:03:24,630
他们会从私钥创建一个签名，

00:03:26,430 --> 00:03:30,299
这就像一个一次性密码，它们是签名。

00:03:30,299 --> 00:03:36,389
如果任何人看到这个签名和这个公钥，

00:03:36,389 --> 00:03:44,940
都能够确定这个签名只能由拥有这个公钥的私钥的人创建。

00:03:44,940 --> 00:03:51,889
没有人能够创建一个能够与这个公钥特定匹配的签名。

00:03:51,889 --> 00:03:57,630
我在密钥和地址的视频中介绍了如何进行这个操作，

00:03:57,630 --> 00:04:02,940
但在这个视频，我只会介绍锁定机制，

00:04:02,940 --> 00:04:05,790
如果你对这些签名、私钥、公钥的来源以及工作原理感兴趣，

00:04:05,790 --> 00:04:07,860
可以观看那个视频。

00:04:07,860 --> 00:04:10,550
在常规交易中，

00:04:10,550 --> 00:04:13,260
比特币被锁定到一个公钥，

00:04:13,260 --> 00:04:14,970
然后当你想要解锁它们时，

00:04:14,970 --> 00:04:18,029
你提供一个签名来解锁它们，

00:04:18,029 --> 00:04:20,430
以证明你是这个公钥的所有者，

00:04:20,430 --> 00:04:25,920
因为你拥有创建这个公钥的私钥。

00:04:25,920 --> 00:04:27,510
任何人都可以查看签名，

00:04:27,510 --> 00:04:30,150
与公钥进行对比，查看它们是否匹配，

00:04:30,150 --> 00:04:32,820
如果它们匹配，

00:04:32,820 --> 00:04:37,890
然后这些比特币可以被解锁并在新的交易中使用，

00:04:37,890 --> 00:04:39,560
它们可以被发送给其他人。

00:04:39,560 --> 00:04:45,240
显然这批比特币将包含别人的公钥，

00:04:45,240 --> 00:04:52,770
这就是使用这些公钥和签名进行交易的方式。

00:04:52,770 --> 00:04:55,050
所以在这个视频中，就像我说的，

00:04:55,050 --> 00:04:57,600
我不会介绍交易和这些密钥是如何工作的。

00:04:57,600 --> 00:05:05,640
我只会关注锁定代码和解锁代码是如何交互的。

00:05:05,640 --> 00:05:07,950
这里有一个锁定机制，我们会在基础知识中介绍，

00:05:07,950 --> 00:05:12,870
你会发现在这些锁里只是一个小型的编程语言，

00:05:12,870 --> 00:05:19,080
同样的事情再次出现在解锁代码里。

00:05:19,080 --> 00:05:23,580
实际上有很多不同的，

00:05:23,580 --> 00:05:27,570
因为这是一个位于这些锁内的编程语言，

00:05:27,570 --> 00:05:28,740
你可以创建不同类型的锁。

00:05:28,740 --> 00:05:34,950
我会介绍每种最常见的锁的工作原理，

00:05:34,950 --> 00:05:38,010
这是P2PK，

00:05:38,010 --> 00:05:39,870
这是最常见、最简单的锁定比特币的方式，

00:05:39,870 --> 00:05:41,510
对于锁定比特币很重要，

00:05:41,510 --> 00:05:44,130
还有P2PKH，

00:05:44,130 --> 00:05:45,600
这非常相似，但稍微复杂一些，

00:05:45,600 --> 00:05:49,740
这是现在最常见的比特币锁定。

00:05:49,740 --> 00:05:55,980
然后是P2MS和P2SH，

00:05:55,980 --> 00:06:00,630
这些是你可以放在比特币批次上的最常见类型的锁。

00:06:00,630 --> 00:06:03,810
最后我会用一些代码和例子，

00:06:03,810 --> 00:06:06,000
来向你展示实际的脚本运行，

00:06:06,000 --> 00:06:08,270
向你展示它是多么简单。

00:06:08,270 --> 00:06:10,090
但在这个演示结束时，

00:06:10,090 --> 00:06:16,430
希望你会熟悉所有这些不同的术语，

00:06:16,430 --> 00:06:18,500
如果你在研究比特币，

00:06:18,500 --> 00:06:19,700
你可能已经碰到了其中一些术语。

00:06:19,700 --> 00:06:24,920
如果你理解了基础知识，

00:06:24,920 --> 00:06:26,300
脚本是一种小型编程语言，

00:06:26,300 --> 00:06:33,620
那么你可以很好地理解这些锁是如何工作的，

00:06:33,620 --> 00:06:36,610
所以到目前为止有任何问题吗？

00:06:36,610 --> 00:06:40,190
首先是基础知识，

00:06:40,190 --> 00:06:44,170
这锁的两部分是如何交互的呢？

00:06:44,170 --> 00:06:47,870
到现在为止，

00:06:47,870 --> 00:06:56,660
我一直使用这个小锁符号来说明放在比特币批次上的锁。

00:06:56,660 --> 00:07:01,580
这只是一些包含叫做脚本的小型编程语言的代码。

00:07:01,580 --> 00:07:09,350
我们称这个锁住一批比特币的代码为锁定脚本。

00:07:09,350 --> 00:07:15,410
这个锁定脚本被放在这个第一笔交易的输出上，

00:07:15,410 --> 00:07:20,630
当这些比特币被创建或者输出被创建的时候。

00:07:20,630 --> 00:07:24,530
然后在你想要解锁这批比特币并从中创建新的批次时，

00:07:24,530 --> 00:07:30,230
你需要提供一些额外的代码来匹配这个锁定脚本，

00:07:30,230 --> 00:07:38,840
这就叫做解锁脚本。

00:07:38,840 --> 00:07:47,420
这个锁定部分通常被称为脚本公钥，

00:07:47,420 --> 00:07:49,220
因为它通常包含一个公钥，

00:07:49,220 --> 00:07:52,220
并且它显然是一个脚本。

00:07:52,220 --> 00:07:53,900
这个解锁脚本有时被称为脚本签名，

00:07:53,900 --> 00:07:55,490
因为它也是一个脚本，

00:07:55,490 --> 00:07:59,360
并且通常包含一个签名。

00:07:59,360 --> 00:08:01,490
但是在这个视频中，

00:08:01,490 --> 00:08:03,890
我会坚持称它们锁定脚本和解锁脚本，

00:08:03,890 --> 00:08:07,280
因为我认为它们能更好的描述，

00:08:07,280 --> 00:08:09,560
而且并不是所有的脚本公钥都需要包含一个公钥，

00:08:09,560 --> 00:08:11,450
也不是所有的解锁脚本都需要包含一个签名。

00:08:11,450 --> 00:08:18,020
我更喜欢更通用和多功能的使用锁定脚本和解锁脚本这两个术语。

00:08:18,020 --> 00:08:22,310
这就是这些脚本的基础知识。

00:08:22,310 --> 00:08:26,060
那么它是如何交互的呢？

00:08:26,060 --> 00:08:34,969
我们在这个小型编程语言中可以使用的是这些叫做操作码的东西，

00:08:34,969 --> 00:08:41,029
它们就像是内置在脚本语言中的小型函数。

00:08:41,029 --> 00:08:46,130
对于特定类型的锁定有好处，

00:08:46,130 --> 00:08:48,800
我们称它为CHECKSIG。

00:08:48,800 --> 00:08:50,510
我们将其放入锁定脚本中。

00:08:50,510 --> 00:08:54,709
现在我们有了一个完整的脚本，

00:08:54,709 --> 00:08:57,589
包括锁定部分和解锁部分。

00:08:57,589 --> 00:09:04,880
这个特定的函数将会检查一个签名与公钥是否匹配。

00:09:04,880 --> 00:09:10,640
你可能猜到了这种脚本将如何运行和验证。

00:09:10,640 --> 00:09:13,399
就像我说的，每个脚本只包含一些数据，

00:09:13,399 --> 00:09:16,550
比如这里的公钥和签名，

00:09:16,550 --> 00:09:19,130
以及一些操作符或操作码，

00:09:19,130 --> 00:09:21,709
这就是脚本的全部内容，

00:09:21,709 --> 00:09:28,490
只有一些数据和一些被称为操作码的函数。

00:09:28,490 --> 00:09:33,140
当你试图将这个交易插入到比特币网络，

00:09:33,140 --> 00:09:36,050
或者说任何一个节点中时，

00:09:36,050 --> 00:09:38,959
他们会接收这个完整的脚本。

00:09:38,959 --> 00:09:43,820
他们会接收最初放在输出上的锁定脚本，

00:09:43,820 --> 00:09:50,649
然后他们会接收你提供的解锁脚本并运行整个脚本以确保它验证通过。

00:09:50,649 --> 00:09:53,450
如果验证通过，

00:09:53,450 --> 00:09:55,640
那么这个交易就是有效的，

00:09:55,640 --> 00:09:57,470
可以添加到区块链中，或者说他们会接受它，

00:09:57,470 --> 00:09:59,720
并将其转发给其他节点，

00:09:59,720 --> 00:10:02,480
这些节点和矿工，

00:10:02,480 --> 00:10:03,950
他们有可能将其挖掘到区块链上。

00:10:03,950 --> 00:10:11,450
如果你创建了一个更复杂的交易，

00:10:11,450 --> 00:10:16,279
你选择了许多不同的输出作为这个交易的输入，

00:10:16,279 --> 00:10:18,920
每一个都会有自己的锁定脚本，

00:10:18,920 --> 00:10:26,029
所以你需要为每个交易提供解锁脚本，

00:10:26,029 --> 00:10:30,410
每个解锁脚本也必须对整个交易有效，

00:10:30,410 --> 00:10:32,690
整个交易才能被网络上的节点接受。

00:10:32,690 --> 00:10:39,740
这就是脚本的基础知识，

00:10:39,740 --> 00:10:41,180
它只是一些数据和一些函数。

00:10:41,180 --> 00:10:45,829
这是如何运行的呢？

00:10:45,829 --> 00:10:47,779
就像我说的那样，

00:10:47,779 --> 00:10:49,579
你可能会猜到它是如何运行，

00:10:49,579 --> 00:10:53,959
我将介绍节点如何运行整个脚本的步骤。

00:10:53,959 --> 00:10:58,819
我有个小问题，

00:10:58,819 --> 00:11:03,110
解锁脚本是交易的一部分，

00:11:03,110 --> 00:11:05,930
而我们所说的锁定脚本，

00:11:05,930 --> 00:11:12,290
实际上就是数字签名。

00:11:12,290 --> 00:11:13,610
你提到的解锁脚本，

00:11:13,610 --> 00:11:20,180
实际上是由花费比特币的人创建的。

00:11:20,180 --> 00:11:23,329
谢谢你的回答，

00:11:23,329 --> 00:11:25,569
在第一个交易中，

00:11:25,569 --> 00:11:29,810
某人会设置这个锁定代码。

00:11:29,810 --> 00:11:31,279
这个人就会进行这笔交易，

00:11:31,279 --> 00:11:33,079
并将解锁代码放在这里，

00:11:33,079 --> 00:11:37,970
当他来解锁它时，

00:11:37,970 --> 00:11:41,660
他们只需要引用这批比特币，

00:11:41,660 --> 00:11:43,490
并将解锁代码输入到这个交易中。

00:11:43,490 --> 00:11:57,759
整个脚本实际上是分布在两个不同的交易中。

00:11:57,759 --> 00:12:04,610
这个新的锁定脚本会被放在这个交易的顶部。

00:12:04,610 --> 00:12:08,480
这有点复杂，

00:12:08,480 --> 00:12:13,610
因为锁定部分和解锁部分实际上是在两个不同的交易中。

00:12:13,610 --> 00:12:15,410
所以如果你看这一笔交易，

00:12:15,410 --> 00:12:17,380
实际上不会有一整个脚本来一起运行，

00:12:17,380 --> 00:12:21,829
它可能稍后在运行，

00:12:21,829 --> 00:12:24,579
据我所知，解锁脚本，

00:12:24,579 --> 00:12:28,370
就是那个红色的波浪，

00:12:28,370 --> 00:12:30,439
它将是黄色交易的一部分吗？

00:12:30,439 --> 00:12:32,430
我不知道。

00:12:32,430 --> 00:12:40,279
在这个特定的交易中，

00:12:40,279 --> 00:12:48,060
在交易数据中有输入和输出，

00:12:48,060 --> 00:12:54,060
对于每个输入，

00:12:54,060 --> 00:12:58,110
我们实际上并没有看到或输入这个锁定代码，

00:12:58,110 --> 00:13:03,200
我们所做的就是为我们选择的每个输入应用或输入一个锁定代码。

00:13:03,200 --> 00:13:08,760
即使我已经把锁定代码放在这里，

00:13:08,760 --> 00:13:12,570
实际上不会看到它们。

00:13:12,570 --> 00:13:13,830
然后在交易的第二部分，我们创建输出时，

00:13:13,830 --> 00:13:21,390
我们将在这里放一些新的锁定代码，

00:13:21,390 --> 00:13:23,430
无论我们想要什么样的锁。

00:13:23,430 --> 00:13:26,010
输入有解锁代码，

00:13:26,010 --> 00:13:29,790
输出有锁定代码。

00:13:29,790 --> 00:13:33,390
我想当我在最后展示交易数据时，

00:13:33,390 --> 00:13:34,320
你可能会更能理解。

00:13:34,320 --> 00:13:35,700
这有点令人困惑，

00:13:35,700 --> 00:13:36,990
因为我把这个锁定代码放在这里，

00:13:36,990 --> 00:13:39,120
但在这个交易中，

00:13:39,120 --> 00:13:40,350
你实际上不会看到锁定代码，

00:13:40,350 --> 00:13:42,470
我们只知道它在这里，

00:13:42,470 --> 00:13:45,029
所以我们只是在这里引用它，

00:13:45,029 --> 00:13:50,070
我现在继续运行这个完整的脚本。

00:13:50,070 --> 00:13:55,350
当节点接收到交易时，

00:13:55,350 --> 00:13:56,880
他们将拥有解锁代码，

00:13:56,880 --> 00:14:01,050
并且他们有对之前有锁定代码的输出的引用，

00:14:01,050 --> 00:14:06,140
它们将获取整个内容并一起运行，

00:14:06,140 --> 00:14:13,470
节点如何运行这两部分脚本来确保这批比特币可以被解锁和花费呢?

00:14:13,470 --> 00:14:16,890
他们会把这个解锁代码，

00:14:16,890 --> 00:14:25,079
它是在这个二级交易中提供的，

00:14:25,079 --> 00:14:28,230
将其放在锁定代码的前面，

00:14:28,230 --> 00:14:31,649
像这样，

00:14:31,649 --> 00:14:37,149
然后他们将从左到右运行这个脚本。

00:14:37,149 --> 00:14:43,180
他们运行这个代码的方式是使用一个叫做堆栈的数据结构，

00:14:43,180 --> 00:14:43,930
如果你之前做过任何编程，

00:14:43,930 --> 00:14:46,390
栈就是一个简单的数据结构，

00:14:46,390 --> 00:14:49,029
它很像数组又不是数组，

00:14:49,029 --> 00:14:57,730
我们只是在栈顶或数组的末尾推入和弹出元素。

00:14:57,730 --> 00:14:59,170
所以我们的脚本包含一堆数据和函数，

00:14:59,170 --> 00:15:02,399
它们都在栈顶上运行。

00:15:02,399 --> 00:15:09,040
所以我们现在会用这个堆栈从左到右运行这个脚本。

00:15:09,040 --> 00:15:10,660
首先当我们从左到右进行时，

00:15:10,660 --> 00:15:13,510
我们遇到了一些数据、签名，

00:15:13,510 --> 00:15:18,640
你在脚本中遇到的任何数据都会被推入栈顶，

00:15:18,640 --> 00:15:23,589
所以这个签名再次被推入了栈顶。

00:15:23,589 --> 00:15:25,690
这里有一个公钥，

00:15:25,690 --> 00:15:27,490
这只是更多的数据，

00:15:27,490 --> 00:15:30,910
它也会被推入栈顶。

00:15:30,910 --> 00:15:34,269
最后有一个操作码，

00:15:34,269 --> 00:15:35,860
操作码与数据的操作方式有些不同。

00:15:35,860 --> 00:15:38,140
数据只是被推入栈顶，

00:15:38,140 --> 00:15:41,890
而操作码可以做什么呢？

00:15:41,890 --> 00:15:46,209
它会从栈顶弹出一个或多个项目，

00:15:46,209 --> 00:15:48,370
对它们执行某些操作后，

00:15:48,370 --> 00:15:52,810
它可以选择性地在堆栈顶部推回项目，

00:15:52,810 --> 00:15:54,790
在处理这些项目之后，

00:15:54,790 --> 00:15:58,660
我们会使用CHECKSIG，

00:15:58,660 --> 00:16:03,910
它会从堆栈顶部弹出两个项目。

00:16:03,910 --> 00:16:06,310
这里它弹出了公钥和签名，

00:16:06,310 --> 00:16:08,410
然后它会对这两个项目做一些处理。

00:16:08,410 --> 00:16:12,160
CHECKSIG会检查这个签名是否匹配这个公钥，

00:16:12,160 --> 00:16:19,600 
或者这个签名是否是这个特定公钥的有效签名。

00:16:19,600 --> 00:16:21,610
如果你想了解这个过程，

00:16:21,610 --> 00:16:22,959
你可以去看看关于密钥和地址的视频。

00:16:22,959 --> 00:16:25,180
但是这里只是示例，

00:16:25,180 --> 00:16:30,790
让我们假设这个签名是这个公钥的有效签名。

00:16:30,790 --> 00:16:34,779
在CHECKSIG操作完成后，

00:16:34,779 --> 00:16:37,959
如果这个签名是有效的，

00:16:37,959 --> 00:16:42,290
它会把1推到堆栈的顶部。

00:16:42,290 --> 00:16:44,269
或将数字1推到堆栈的顶部。

00:16:44,269 --> 00:16:46,249
这个脚本就被完全执行了。

00:16:46,249 --> 00:16:53,089
那么什么使这个脚本是有效的呢，

00:16:53,089 --> 00:16:55,639
或者说一批比特币可以被花费吗？

00:16:55,639 --> 00:16:58,730
如果在运行整个脚本后，

00:16:58,730 --> 00:17:02,540
堆栈顶部留下了一个1，

00:17:02,540 --> 00:17:05,209
那么这就意味着这个脚本是有效的，

00:17:05,209 --> 00:17:08,209
这批比特币可以被花费。

00:17:08,209 --> 00:17:12,260
如果在脚本运行后，

00:17:12,260 --> 00:17:15,619
堆栈为空，则它无效，

00:17:15,619 --> 00:17:21,679
如果在整个脚本运行后堆栈顶部留下零，

00:17:21,679 --> 00:17:25,849
那么脚本同样无效。

00:17:25,849 --> 00:17:28,580
因此在这最后一个示例中，

00:17:28,580 --> 00:17:30,020
如果这个检查签名没有正确执行，

00:17:30,020 --> 00:17:34,340
我认为它会将零推到堆栈顶部或者堆栈顶部什么都没有，

00:17:34,340 --> 00:17:36,740
可能是零，堆栈就会被判定为无效。

00:17:36,740 --> 00:17:38,720
但在这个示例中，

00:17:38,720 --> 00:17:41,090
签名与公钥匹配，

00:17:41,090 --> 00:17:42,649
检查签名操作码执行所有这些操作，

00:17:42,649 --> 00:17:45,380
如果正确，

00:17:45,380 --> 00:17:49,730
它会将1推到堆栈顶部，

00:17:49,730 --> 00:17:53,480
如果在脚本运行后堆栈顶部留下1，

00:17:53,480 --> 00:17:57,559
那么这批比特币可以被花费，

00:17:57,559 --> 00:17:59,230
这些听懂了吗？是的。

00:17:59,230 --> 00:18:04,029
让我把这些都移回来，

00:18:04,029 --> 00:18:10,899
我们知道为什么刚才有一个所谓的p2pk的例子，

00:18:10,899 --> 00:18:14,320
它非常简单，

00:18:14,320 --> 00:18:18,250
一批比特币上的锁定代码只包含别人的公钥和检查签名操作码，

00:18:18,250 --> 00:18:23,620
然后当那个人想要解锁他们时，

00:18:23,620 --> 00:18:25,299
他们要的就是解锁这批比特币。

00:18:25,299 --> 00:18:29,559
我所要做的是提供私钥的有效签名，

00:18:29,559 --> 00:18:32,620
该公钥是从现在开始创建的，

00:18:32,620 --> 00:18:40,809
这可能是锁定一批比特币的最简单的方式，

00:18:40,809 --> 00:18:46,360
矿工们在区块内的coinbase交易中大量使用了这种方式，

00:18:46,360 --> 00:18:52,539
但现在我们通常使用这种锁定机制的一种变体。

00:18:52,539 --> 00:18:54,070
这是最简单的一种，

00:18:54,070 --> 00:18:57,730
但我们现在使用跟这个有点不同的东西。

00:18:57,730 --> 00:19:06,100
这被称为Pay To Pubkey或简称P2PK。

00:19:06,100 --> 00:19:09,789
请注意，这些P 2 P K和Pay To Pubkey，

00:19:09,789 --> 00:19:13,960
这些名字适用于你应用到一批比特币的锁定脚本的模式。

00:19:13,960 --> 00:19:15,909
所以如果你看到一批比特币，

00:19:15,909 --> 00:19:19,960
它有一个公钥和一个检查操作码，没有别的，

00:19:19,960 --> 00:19:24,360
那个模式就是一个Pay To Pubkey脚本，

00:19:24,360 --> 00:19:30,940
这个脚本是一组最常用的标准脚本中的一个。

00:19:30,940 --> 00:19:33,190
我将总共介绍五个，

00:19:33,190 --> 00:19:37,230
这是最简单的一个，

00:19:37,230 --> 00:19:42,490
叫做Pay To Pubkey。

00:19:42,490 --> 00:19:44,830
接下来我们有一个叫做Pay To Pubkey Hash的，

00:19:44,830 --> 00:19:46,659
它与这个非常相似，只是稍微有些不同，

00:19:46,659 --> 00:19:48,870
我会在稍后解释原因。

00:19:48,870 --> 00:19:55,570
如果你还记得在关于密钥和地址的视频中，

00:19:55,570 --> 00:19:57,279
我们创建了一个私钥和公钥，

00:19:57,279 --> 00:19:58,480
这就是我们在比特币中发送和接收比特币所需要的全部。

00:19:58,480 --> 00:20:03,519
我们通常会先对公钥进行哈希，

00:20:03,519 --> 00:20:06,340
我提到这是因为安全性，

00:20:06,340 --> 00:20:09,220
我认为，这主要是因为一开始，

00:20:09,220 --> 00:20:12,519
这是一种简单的减小公钥大小的方式，

00:20:12,519 --> 00:20:15,879
所以当我们把这个给别人的时候。

00:20:15,879 --> 00:20:19,479
我们可以给他们一个更小的公钥，

00:20:19,479 --> 00:20:21,909
但这仍然是我们的公钥，

00:20:21,909 --> 00:20:25,919
所以我们会做的是，

00:20:25,919 --> 00:20:27,789
当我们创建了密钥和地址后，

00:20:27,789 --> 00:20:30,489
我们会对公钥进行哈希，

00:20:30,489 --> 00:20:33,070
这样就减小了它的大小，

00:20:33,070 --> 00:20:36,009
然后将这个哈希值给别人，

00:20:36,009 --> 00:20:38,499
然后他们会将这个哈希值放入锁定代码中，

00:20:38,499 --> 00:20:42,209
而不是我们原来的公钥，

00:20:42,209 --> 00:20:47,129
这种特殊的锁定脚本是使用我们公钥的哈希版本，

00:20:47,129 --> 00:20:49,690
而不是标准的原始公钥。

00:20:49,690 --> 00:20:53,169
我们会在它周围放一个类似这样的锁定脚本，

00:20:53,169 --> 00:20:56,049
这有点相似，

00:20:56,049 --> 00:20:58,299
我们仍然有这个检查签名函数，

00:20:58,299 --> 00:21:01,179
但现在不是只有哈希公钥和CHECKSIG，

00:21:01,179 --> 00:21:03,309
我们对哈希公钥和这些额外的操作码进行哈希处理。

00:21:03,309 --> 00:21:08,820
稍后就会知道原因。

00:21:08,820 --> 00:21:13,089
这就是Pay To Pubkey Hash，

00:21:13,089 --> 00:21:14,739
或者说Pay To Pubkey Hash锁定脚本。

00:21:14,739 --> 00:21:20,019
当你来解锁这个特定的锁定脚本时，

00:21:20,019 --> 00:21:22,629
我们需要做的就像之前一样，

00:21:22,629 --> 00:21:27,909
我们需要一个签名，

00:21:27,909 --> 00:21:29,409
这个签名来自于生成这个公钥的私钥，

00:21:29,409 --> 00:21:32,679
除此之外，

00:21:32,679 --> 00:21:34,599
我们还需要提供原始的公钥。

00:21:34,599 --> 00:21:40,779
当我们或者一个节点来运行这个脚本，

00:21:40,779 --> 00:21:43,059
以确保其有效时，

00:21:43,059 --> 00:21:45,999
他们会再次确保解锁脚本从左到右运行。

00:21:45,999 --> 00:21:48,129
他们就会采取他们的堆栈，

00:21:48,129 --> 00:21:50,679
显然数据会被推到堆栈上，

00:21:50,679 --> 00:21:52,419
签名会在顶部，

00:21:52,419 --> 00:21:55,690
然后是公钥。

00:21:55,690 --> 00:21:59,049
然后我们遇到这个复制操作码，

00:21:59,049 --> 00:22:01,869
它会做你期望它做的事情，

00:22:01,869 --> 00:22:04,419
它会弹出堆栈的顶部元素，复制它，

00:22:04,419 --> 00:22:11,950
然后像这样将顶部元素推回到堆栈上。

00:22:11,950 --> 00:22:13,240
这就是DUP。

00:22:13,240 --> 00:22:16,570
我们有哈希160，

00:22:16,570 --> 00:22:19,300
它会弹出顶部元素，对它进行哈希，

00:22:19,300 --> 00:22:20,920
然后把它推回到堆栈的顶部。

00:22:20,920 --> 00:22:27,040
然后我们来看原始锁定脚本中的哈希公钥，

00:22:27,040 --> 00:22:28,920
它被推到了顶部。

00:22:28,920 --> 00:22:31,180
然后我们来到EQUALVERIFY操作码，

00:22:31,180 --> 00:22:35,050
这个操作码会从堆栈的顶部弹出两个元素，

00:22:35,050 --> 00:22:37,510
检查它们是否相等，如果它们相等，

00:22:37,510 --> 00:22:39,970
它不会把任何东西推回到堆栈上。

00:22:39,970 --> 00:22:42,550
然后是EQUALVERIFY操作码，

00:22:42,550 --> 00:22:44,410
它会把1推到堆栈的顶部，

00:22:44,410 --> 00:22:46,510
检查签名是否匹配公钥，

00:22:46,510 --> 00:22:48,370
如果匹配，它不会把任何内容推回到堆栈上。

00:22:48,370 --> 00:22:54,040
然后我们遇到了熟悉的CHECKSIG操作码，

00:22:54,040 --> 00:22:56,770
该代码将弹出，

00:22:56,770 --> 00:22:58,870
检查签名与公钥是否匹配，

00:22:58,870 --> 00:23:00,640
如果匹配，它会把数字1推到堆栈的顶部。

00:23:00,640 --> 00:23:10,810
所以pay to pubkey与pay to pubkey hash唯一的区别是，

00:23:10,810 --> 00:23:18,630
你需要检查你提供的公钥，

00:23:18,630 --> 00:23:25,480
是否与最初提供的公钥的哈希值匹配，

00:23:25,480 --> 00:23:31,350
如果匹配，

00:23:31,350 --> 00:23:37,060
它就会像Pay To Pubkey 那样检查签名。

00:23:37,060 --> 00:23:39,660
有其他问题吗？

00:23:39,660 --> 00:23:43,930
我们是否可以自己创建脚本？

00:23:43,930 --> 00:23:48,810
比如Pay To Pubkey，

00:23:48,810 --> 00:23:52,570
比如Pay To Pubkey Hash，

00:23:52,570 --> 00:23:54,880
假设我想做一个Pay To Pubkey Hash，

00:23:54,880 --> 00:23:57,850
这是用户实际可以做的吗？

00:23:57,850 --> 00:24:06,460
答案是肯定的，

00:24:06,460 --> 00:24:08,440
我会在稍后解释为什么。

00:24:08,440 --> 00:24:12,040
好的问题，

00:24:12,040 --> 00:24:16,690
现在我将继续讲解这些标准脚本。

00:24:16,690 --> 00:24:20,410
Pay To Pubkey和Pay To Pubkey Hash相同，

00:24:20,410 --> 00:24:29,420
它只是首先检查你在解锁脚本中提供的公钥哈希值是否与最初提供的哈希值匹配，

00:24:29,420 --> 00:24:32,300
然后像往常一样检查签名。

00:24:32,300 --> 00:24:33,740
我想说，

00:24:33,740 --> 00:24:36,530
Pay To Pubkey是针对公钥的，

00:24:36,530 --> 00:24:38,810
而Pay To Pubkey Hash是针对比特币地址的。

00:24:38,810 --> 00:24:40,430
是的，

00:24:40,430 --> 00:24:46,250
这是你在比特币上最常见的锁定脚本。

00:24:46,250 --> 00:24:55,610
为了方便实用，

00:24:55,610 --> 00:24:57,530
当你想接收比特币时，

00:24:57,530 --> 00:24:59,390
我们有一种更方便的方式，而不是创建这个哈希，

00:24:59,390 --> 00:25:02,120
然后用你想用的所有操作码包围它，

00:25:02,120 --> 00:25:05,570
基本上构造了整个锁定脚本，

00:25:05,570 --> 00:25:06,790
然后给别人。

00:25:06,790 --> 00:25:11,480
我们在比特币中有很多更方便的方法来做到这一点，

00:25:11,480 --> 00:25:14,120
我们创建一个地址，

00:25:14,120 --> 00:25:22,270
这基本上是公钥的哈希版本，

00:25:22,270 --> 00:25:24,530
转换成方便用户使用的格式。

00:25:24,530 --> 00:25:28,100
它有一个校验和，

00:25:28,100 --> 00:25:29,810
使用对用户更友好的字符。

00:25:29,810 --> 00:25:32,630
这更难犯错，

00:25:32,630 --> 00:25:35,720
然后这个地址会在前面加上一个1，

00:25:35,720 --> 00:25:38,830
这意味着如果你给别人提供一个地址，

00:25:38,830 --> 00:25:41,240
以1开头的地址，

00:25:41,240 --> 00:25:43,850
他们将能够解码它，

00:25:43,850 --> 00:25:46,490
得到公钥的原始哈希值。

00:25:46,490 --> 00:25:48,860
因为他们看到该地址前面有一个1，

00:25:48,860 --> 00:25:53,960
他们就会知道这个人想要创建Pay To Pubkey Hash，

00:25:53,960 --> 00:25:57,440
所以他们会解码它，

00:25:57,440 --> 00:26:02,450
并使用放置在其中的公钥的哈希160形成这个锁定脚本，

00:26:02,450 --> 00:26:05,090
所以这个地址只是一种方便的方式，

00:26:05,090 --> 00:26:10,119
告诉人们你希望你的比特币如何被锁定。

00:26:10,119 --> 00:26:15,080
P2PK没有地址格式，

00:26:15,080 --> 00:26:18,580
所以如果你希望比特币以这种格式被锁定，

00:26:18,580 --> 00:26:21,259
你必须发送完整的锁定脚本，

00:26:21,259 --> 00:26:26,330
然后接收人必须手动构造交易，

00:26:26,330 --> 00:26:29,659
将这个锁定脚本放入。

00:26:29,659 --> 00:26:34,369
但是Pay to Public Key Hash (P2PKH)这种更常见的格式有这个地址，

00:26:34,369 --> 00:26:36,289
所以当你向某人发送一个地址时，

00:26:36,289 --> 00:26:39,230
你发送的只是你的公钥的哈希，

00:26:39,230 --> 00:26:42,080
并告诉他们以某种方式锁定它。

00:26:42,080 --> 00:26:48,830
我要介绍五个，这是第三个，

00:26:48,830 --> 00:26:54,019
这些都是支付给一个人的公钥，

00:26:54,019 --> 00:26:58,850
在比特币中还有Pay To Multisig，

00:26:58,850 --> 00:27:02,690
你可以做的不仅仅是将一批比特币锁定到一个人的公钥上，

00:27:02,690 --> 00:27:04,490
如果你们三个人在一家公司或企业内部，

00:27:04,490 --> 00:27:06,789
你们想一起接收比特币，

00:27:06,789 --> 00:27:12,379
你们可以做的是将你们的公钥都放入一个锁定脚本中，

00:27:12,379 --> 00:27:17,869
然后你们会在后面放入一个数字，

00:27:17,869 --> 00:27:20,389
这个数字是n，

00:27:20,389 --> 00:27:22,669
表示锁定脚本中的公钥数量，

00:27:22,669 --> 00:27:26,210
然后还有另一个数字叫做m，

00:27:26,210 --> 00:27:29,269
这是需要提供满足的签名数量，

00:27:29,269 --> 00:27:38,600
才能解锁这个锁定脚本或者这个批次的比特币。

00:27:38,600 --> 00:27:44,139
最后你将使用CHECKMULTISIG函数，

00:27:44,139 --> 00:27:47,899
所以这是一个Pay To Multisig锁定脚本。

00:27:47,899 --> 00:27:50,740
就像我说的那样，

00:27:50,740 --> 00:27:57,940
这里的m只是表示需要多少签名才能解锁这个锁定脚本。

00:27:57,940 --> 00:28:01,809
当你把这个锁定脚本给别人时，

00:28:01,809 --> 00:28:05,139
他们会把一批比特币用这个锁定脚本锁定。

00:28:05,139 --> 00:28:10,870
所以当这三个人想要解锁这批比特币时，

00:28:10,870 --> 00:28:12,070
或者把它们发给别人时，

00:28:12,070 --> 00:28:20,110
他们需要的只是这三个人中的任何两个人的签名，

00:28:20,110 --> 00:28:22,419
这些签名也需要按正确的顺序排列，

00:28:22,419 --> 00:28:26,980
如果这些公钥是按特定的顺序放入锁定代码中的，

00:28:26,980 --> 00:28:31,889
这些签名也需要按正确的顺序排列，

00:28:31,889 --> 00:28:34,929
这就是典型的Pay To Multisig，

00:28:34,929 --> 00:28:37,539
我会在片刻后运行它，只是一个小提示，

00:28:37,539 --> 00:28:46,200
这个CHECKMULTISIG函数或者它的工作方式中有一个小错误。

00:28:46,200 --> 00:28:49,870
这只是从比特币开始就有的一个错误，

00:28:49,870 --> 00:28:51,250
我们只需要现在就考虑它。

00:28:51,250 --> 00:28:56,950
发生的情况是这个M在这里开头有一个偏移一个的错误。

00:28:56,950 --> 00:29:00,960
会发生的是它会多消耗掉堆栈中的一项。

00:29:00,960 --> 00:29:04,750
我们在这里指出，

00:29:04,750 --> 00:29:07,779
为了解决这个问题，

00:29:07,779 --> 00:29:09,669
对于每个Pay To Multisig签名，

00:29:09,669 --> 00:29:13,980
我们只需要在开始时放一个虚拟的或零操作码。

00:29:13,980 --> 00:29:16,629
这就是我们需要考虑的错误，

00:29:16,629 --> 00:29:19,590
当我们使用CHECKMULTISIG签名脚本时。

00:29:19,590 --> 00:29:24,120
无论如何，让我们运行这个脚本，

00:29:24,120 --> 00:29:26,110
如何运行它，如何检查它，

00:29:26,110 --> 00:29:29,289
把锁定代码放在开头，

00:29:29,289 --> 00:29:32,500
然后从左到右，

00:29:32,500 --> 00:29:34,059
数字就被推到堆栈上，

00:29:34,059 --> 00:29:36,519
就像数据一样。所以零在堆栈上，

00:29:36,519 --> 00:29:38,620
然后我们把签名推到堆栈上

00:29:38,620 --> 00:29:40,960
因为它们是数据，

00:29:40,960 --> 00:29:43,840
然后我们将数字2再次被推到堆栈上，

00:29:43,840 --> 00:29:46,929
然后是每一个公钥，它们只是数据，

00:29:46,929 --> 00:29:48,789
可以推到堆栈的顶部，

00:29:48,789 --> 00:29:52,330
然后是3，

00:29:52,330 --> 00:29:54,639
最后我们来到CHECKMULTISIG操作码，

00:29:54,639 --> 00:29:56,980
它首先会弹出顶部的元素，

00:29:56,980 --> 00:29:58,899
看到这是3，

00:29:58,899 --> 00:30:01,629
当它看到这是3，

00:30:01,629 --> 00:30:02,950
它意味着它会弹出接下来的三个元素，

00:30:02,950 --> 00:30:05,259
然后它会弹出下一个元素，

00:30:05,259 --> 00:30:07,029，
是2，

00:30:07,029 --> 00:30:09,960
当它看到这是2，它会弹出接下来的两个元素，

00:30:09,960 --> 00:30:13,250
但是像我之前提到的，

00:30:13,250 --> 00:30:16,110
这个M在这里有一个偏移一个的错误，

00:30:16,110 --> 00:30:19,440
所以它会消耗掉三个，而不是两个。

00:30:19,440 --> 00:30:21,390
但这只是比特币中的一个小漏洞，

00:30:21,390 --> 00:30:24,960
你可以假装它不存在。

00:30:24,960 --> 00:30:29,309
现在它必须检查签名是否与公钥匹配，

00:30:29,309 --> 00:30:32,970
我们从栈底的第一个签名开始，

00:30:32,970 --> 00:30:37,230
然后检查它是否与第一个公钥匹配。

00:30:37,230 --> 00:30:42,390
如果不匹配，那也没关系，

00:30:42,390 --> 00:30:44,309
它会继续检查下一个公钥，

00:30:44,309 --> 00:30:45,600
看它是否匹配。

00:30:45,600 --> 00:30:48,210
这个公钥如果匹配，

00:30:48,210 --> 00:30:49,620
我们在这里标记一下。

00:30:49,620 --> 00:30:56,130
我之所以说要把这些签名按正确的顺序放好，

00:30:56,130 --> 00:31:02,490
是因为在检查过一个签名与公钥的匹配之后，

00:31:02,490 --> 00:31:08,460
CHECKMULTISIG函数就不会再检查这些公钥了。

00:31:08,460 --> 00:31:13,470
所以当你要匹配第二个签名和公钥时，

00:31:13,470 --> 00:31:16,770
它不会从头开始与每个单独的公钥进行匹配，

00:31:16,770 --> 00:31:18,240
而是从上次匹配的位置开始。

00:31:18,240 --> 00:31:23,610
你会再次检查这个签名是否与这个公钥匹配，

00:31:23,610 --> 00:31:25,980
如果匹配，

00:31:25,980 --> 00:31:28,980
那我们就有了两个匹配的签名。

00:31:28,980 --> 00:31:36,380
因为我们在这个锁定脚本中要求有两个签名，

00:31:36,380 --> 00:31:39,799
所以CHECKMULTISIG对此很满意，

00:31:39,799 --> 00:31:43,409
它会在栈顶推入一个1。

00:31:43,409 --> 00:31:49,140
如果只有0或1个签名与这些公钥匹配，

00:31:49,140 --> 00:31:51,840
那么它会在栈顶推入一个0。

00:31:51,840 --> 00:31:53,250
但因为我们有足够的匹配签名，

00:31:53,250 --> 00:31:55,620
所以它在栈顶推入一个1。

00:31:55,620 --> 00:32:03,750
这个过程明白了吗？好了，

00:32:03,750 --> 00:32:06,480
这就是Pay To Multisig。

00:32:06,480 --> 00:32:10,380
现在你知道这些脚本是如何工作的，

00:32:10,380 --> 00:32:13,290
其实很简单。在我们继续讨论第四个之前。

00:32:13,290 --> 00:32:19,380
但是在设置Pay To Multisig时有一个小问题。

00:32:19,380 --> 00:32:22,120
假设我们公司有三个或更多的人，

00:32:22,120 --> 00:32:29,140
我们只想接受Pay To Multisig锁定脚本的比特币。

00:32:29,140 --> 00:32:33,450
我们必须构建这个锁定脚本并给别人。

00:32:33,450 --> 00:32:36,880
他们将不得不构建一个交易，

00:32:36,880 --> 00:32:39,070
并将我们给出的整个脚本，

00:32:39,070 --> 00:32:45,630
放入他们要发送给我们的比特币的锁定代码中。

00:32:45,630 --> 00:32:49,090
他们就构建这个完整的交易，

00:32:49,090 --> 00:32:53,380
他们必须将我们想要的锁定代码放到这批比特币上。

00:32:53,380 --> 00:32:57,460
但CHECKMULTISIG的问题是，

00:32:57,460 --> 00:33:03,580
这些特定的锁定脚本可能会变得相当大。

00:33:03,580 --> 00:33:08,350
这个2或3的Pay To Multisig锁定脚本有105字节，

00:33:08,350 --> 00:33:16,180
但每增加一个公钥到多重签名中，

00:33:16,180 --> 00:33:18,010
它就会变得越来越大，

00:33:18,010 --> 00:33:23,910
因为每个公钥在交易数据中占用33字节的空间。

00:33:23,910 --> 00:33:30,910
如果我们提供这个很大的锁定脚本，

00:33:30,910 --> 00:33:32,470
一个很大的Pay To Multisig锁定脚本给某人锁定我们的比特币，

00:33:32,470 --> 00:33:35,020
他们可能不会很高兴，

00:33:35,020 --> 00:33:39,400
因为这将在他们的交易中占用大量的数据。

00:33:39,400 --> 00:33:44,940
他们将不得不为这些数据支付交易费用。

00:33:44,940 --> 00:33:51,280
尤其是当你考虑到Pay To Pubkey是35字节，

00:33:51,280 --> 00:33:54,130
Pay To Pubkey Hash是25字节，

00:33:54,130 --> 00:34:00,040
而通常最小的Pay To Multisig锁定脚本要105字节，

00:34:00,040 --> 00:34:05,470
这对这个人来说，

00:34:05,470 --> 00:34:09,550
他们可能不会想发送比特币到除了Pay To Pubkey或Pay To Pubkey Hash脚本之外的任何地方。

00:34:09,550 --> 00:34:14,199
那么我们如何避免这个问题，

00:34:14,199 --> 00:34:27,619
避免这个人不得不通过创建包含更多交易数据的交易来支付这些大型锁定脚本的问题呢？

00:34:27,619 --> 00:34:34,099 
这就是Pay To Script Hash的作用。

00:34:34,099 --> 00:34:41,899
它主要是为了使这些更复杂的脚本更短，

00:34:41,899 --> 00:34:45,460
更容易让别人创建交易。

00:34:45,460 --> 00:34:48,018
这就是所谓的Pay To Script Hash，

00:34:48,018 --> 00:34:50,268
我现在来解释一下这是怎么工作的。

00:34:50,268 --> 00:34:57,710
让我们假设我们想要接收到一个Pay To Multisig锁定脚本的比特币。

00:34:57,710 --> 00:34:59,479
我们要做的不是给他们整个锁定脚本，

00:34:59,479 --> 00:35:04,880
而是首先将它哈希在一起，

00:35:04,880 --> 00:35:06,289
得到这个特定脚本的唯一哈希，

00:35:06,289 --> 00:35:08,119
这就叫做脚本哈希。

00:35:08,119 --> 00:35:14,479
那么我们可以做的就是将这个脚本哈希给别人，

00:35:14,479 --> 00:35:17,479
然后他们可以将这个放入锁定脚本，

00:35:17,479 --> 00:35:20,960
用一组操作码包裹起来，

00:35:20,960 --> 00:35:29,269
所以我们有了一个Pay To Script Hash锁定脚本。

00:35:29,269 --> 00:35:30,890
这显然要小得多。

00:35:30,890 --> 00:35:33,259
我们不是给这个人整个原始的锁定脚本，

00:35:33,259 --> 00:35:35,299
我们只是给他们一个哈希，

00:35:35,299 --> 00:35:37,249
这使得它缩小了很多，

00:35:37,249 --> 00:35:39,529
他们只需要在其周围应用两个操作码，

00:35:39,529 --> 00:35:45,589
那么我们就有了一个Pay To Script Hash的锁定脚本，

00:35:45,589 --> 00:35:47,690
这个脚本要短得多。

00:35:47,690 --> 00:35:53,150
原来的105字节变得和Pay To Pubkey Hash差不多，

00:35:53,150 --> 00:35:55,969
大约23字节，这使得他们很高兴，

00:35:55,969 --> 00:35:58,039
因为他们不需要构建这些巨大的交易，

00:35:58,039 --> 00:36:01,279
并为这些大型锁定脚本支付费用。

00:36:01,279 --> 00:36:06,079
那么这个工作，

00:36:06,079 --> 00:36:11,779
但是我们如何解锁这批有这个Pay To Script Hash锁定脚本的比特币，

00:36:11,779 --> 00:36:14,479
并在其上编写脚本呢？

00:36:14,479 --> 00:36:19,950
如果是Pay To Multisig，

00:36:19,950 --> 00:36:21,930
我们所要做的就是提供两个签名，

00:36:21,930 --> 00:36:25,860
但是除此之外，

00:36:25,860 --> 00:36:28,020
我们还需要提供原始的锁定脚本，

00:36:28,020 --> 00:36:34,460
也就是这个锁定脚本哈希是从中创建出来的。

00:36:34,460 --> 00:36:36,750
但是我们不是将各个操作码放在一起，

00:36:36,750 --> 00:36:38,610
我们只是将所有的东西压缩到一起，

00:36:38,610 --> 00:36:41,580
变成单个数据块，

00:36:41,580 --> 00:36:44,340
或者序列化成一份单一的数据，

00:36:44,340 --> 00:36:46,140
所有的操作码都在里面，

00:36:46,140 --> 00:36:47,940
但不是以单独的操作码的形式出现，

00:36:47,940 --> 00:36:54,050
只是一堆数据。

00:36:54,050 --> 00:36:59,060
所以让我们再次运行这个锁定代码和解锁代码。

00:36:59,060 --> 00:37:02,010
你将锁定代码放在开始，

00:37:02,010 --> 00:37:08,430
但是对于Pay To Script Hash，

00:37:08,430 --> 00:37:14,300
尽管它以大致相同的方式执行，

00:37:14,300 --> 00:37:19,830
但这种特殊的锁定码格式会以略微不同的方式执行，

00:37:19,830 --> 00:37:23,940
我将向你展示如何操作。

00:37:23,940 --> 00:37:26,130
它像往常一样开始，使用堆栈，

00:37:26,130 --> 00:37:28,710
我们将锁定代码放在开始，

00:37:28,710 --> 00:37:30,960
然后我们将签名推到堆栈上。

00:37:30,960 --> 00:37:35,340
然后我们遇到这个序列化的锁定脚本，

00:37:35,340 --> 00:37:38,910
也叫做赎回脚本，

00:37:38,910 --> 00:37:43,020
因为它只是数据被压缩在一起，

00:37:43,020 --> 00:37:44,960
所以它也就直接放在堆栈的顶部，

00:37:44,960 --> 00:37:49,350
这就是解锁代码的完成部分。

00:37:49,350 --> 00:37:51,000
因为它是一个Pay To Script Hash，

00:37:51,000 --> 00:37:53,490
这就是差异所在，

00:37:53,490 --> 00:37:57,420
它会在解锁脚本运行后复制堆栈。

00:37:57,420 --> 00:38:00,210
所以它会复制一份。

00:38:00,210 --> 00:38:10,440
它将使用从解锁脚本得到的堆栈来运行原始的锁定脚本。

00:38:10,440 --> 00:38:14,040
首先，它会对堆栈顶部的元素进行哈希160，

00:38:14,040 --> 00:38:19,450
所以它会对这份数据进行哈希，

00:38:19,450 --> 00:38:22,750
这就是原始的序列化锁定脚本。

00:38:22,750 --> 00:38:24,849
然后它们会对它进行哈希处理，

00:38:24,849 --> 00:38:27,609
再放回堆栈顶部，

00:38:27,609 --> 00:38:29,260
然后锁定脚本的哈希也会放回堆栈顶部。

00:38:29,260 --> 00:38:36,250
"equal opcode"将从栈中弹出两个元素并检查它们是否相等，

00:38:36,250 --> 00:38:38,440
如果相等，它将把一个1压入栈顶。

00:38:38,440 --> 00:38:41,109
因此这个脚本部分，

00:38:41,109 --> 00:38:43,299
即解锁脚本和锁定脚本，

00:38:43,299 --> 00:38:44,650
已经完全运行，

00:38:44,650 --> 00:38:47,799
并且我们在栈顶留下了一个1。

00:38:47,799 --> 00:38:49,900
这个第一部分检查锁定脚本，

00:38:49,900 --> 00:38:57,400
我们提供的序列化锁定脚本，

00:38:57,400 --> 00:39:05,460
是否与最初被哈希并放入锁定脚本中的脚本匹配，

00:39:05,460 --> 00:39:09,119
这部分已经完成了。

00:39:10,080 --> 00:39:12,720
当它运行完毕后，

00:39:12,720 --> 00:39:16,320
因为它是描述性的，

00:39:16,320 --> 00:39:18,630
它会把副本带回并用作堆栈。

00:39:18,630 --> 00:39:25,980
第一部分检查哈希是否匹配我们提供的赎回脚本，

00:39:25,980 --> 00:39:27,210
而在第二部分中，

00:39:27,210 --> 00:39:30,300
Pay To Script Hash则会弹出栈顶元素，

00:39:30,300 --> 00:39:32,220
即赎回脚本，

00:39:32,220 --> 00:39:35,970
对其进行反序列化，然后再次运行堆栈。

00:39:35,970 --> 00:39:39,680
像之前在Pay To Multisig中一样，

00:39:39,680 --> 00:39:42,210
数字2被压入栈顶，

00:39:42,210 --> 00:39:44,790
然后是所有的公钥，然后是3，

00:39:44,790 --> 00:39:47,040
然后我们再次进入了CHECKMULTISIG。

00:39:47,040 --> 00:39:49,310
它会像上次一样，

00:39:49,310 --> 00:39:51,900
弹出所有的元素，

00:39:51,900 --> 00:39:53,310
检查签名是否与公钥匹配，

00:39:53,310 --> 00:39:54,660
确保有足够的匹配，如果正确，

00:39:54,660 --> 00:39:56,790
它会把一个1压回栈顶，

00:39:56,790 --> 00:40:03,860
这样就完成了。你听懂了吗？

00:40:03,860 --> 00:40:13,890
Pay To Script Hash是唯一一个运行方式略有不同的脚本。

00:40:13,890 --> 00:40:15,630
它是后来添加到比特币中的，

00:40:15,630 --> 00:40:26,250
作为一种使复杂脚本简单化的方法，

00:40:26,250 --> 00:40:32,400
然后让其他人只需要在比特币顶部放一个简单的锁定脚本，

00:40:32,400 --> 00:40:34,200
使其更易于操作。

00:40:34,200 --> 00:40:39,090
这些Pay To Script Hash也有自己的地址，

00:40:39,090 --> 00:40:42,510
类似于Pay To Pubkey Hash。

00:40:42,510 --> 00:40:49,619
你可以为一个Pay To Script Hash锁定脚本形成一个地址，

00:40:49,619 --> 00:40:55,650
你将哈希你想要的锁定脚本，

00:40:55,650 --> 00:40:58,829
或者你想要如何锁定这个比特币，

00:40:58,829 --> 00:41:00,869
然后像之前一样创建一个哈希，

00:41:00,869 --> 00:41:07,799
然后从这个哈希你将把它编码成一个漂亮的地址格式。

00:41:07,799 --> 00:41:09,390
你可以在这些之间来回切换。

00:41:09,390 --> 00:41:12,869
在Pay To Pubkey Hash中，

00:41:12,869 --> 00:41:18,150
你有哈希值，

00:41:18,150 --> 00:41:19,739
而在这个Pay To Script Hash中，你无法找到地址，

00:41:19,739 --> 00:41:22,470
哈希值在其中，

00:41:22,470 --> 00:41:24,690
你在开头放一个3，

00:41:24,690 --> 00:41:26,880
所以当你将这个3给别人时，

00:41:26,880 --> 00:41:29,160
他们可以解码它，获取哈希值，

00:41:29,160 --> 00:41:32,190
然后形成这种特定格式的锁定脚本。

00:41:32,190 --> 00:41:39,059
以1开头的地址对应这种类型的锁定脚本，

00:41:39,059 --> 00:41:45,859
以3开头的地址对应这种类型的锁定脚本。

00:41:45,859 --> 00:41:51,539
它通常会是Pay To Multisig，

00:41:51,539 --> 00:41:55,319
或最近的隔离见证类型交易，

00:41:55,319 --> 00:41:57,720
我不会在这里介绍，

00:41:57,720 --> 00:42:03,660
但隔离见证已经使用这种格式来锁定他们的币。

00:42:03,660 --> 00:42:08,579
这就是Pay To Script Hash，

00:42:08,579 --> 00:42:10,829
这是整个视频中最复杂的部分，

00:42:10,829 --> 00:42:12,839
如果这部分讲清楚了，

00:42:12,839 --> 00:42:14,549
那么其他部分就容易了。

00:42:14,549 --> 00:42:17,190
但这就像是一种特殊的形式，

00:42:17,190 --> 00:42:19,170
要求执行的方式略有不同。

00:42:19,170 --> 00:42:23,670
在最后，

00:42:23,670 --> 00:42:30,539
最后一个在比特币中使用的标准脚本叫做NULL DATA锁定脚本，

00:42:30,539 --> 00:42:33,569
它使用了一个叫做op return的操作码，

00:42:33,569 --> 00:42:37,559
或者简单叫做return的操作码。

00:42:37,559 --> 00:42:40,650
我们的代码做了什么呢？

00:42:40,650 --> 00:42:43,319
这个操作码会使脚本无效，

00:42:43,319 --> 00:42:46,739
无论你在解锁码中放什么，

00:42:46,739 --> 00:42:49,309
只要一个节点运行了这个操作码，

00:42:51,160 --> 00:42:54,340
它就会使脚本无效，

00:42:54,340 --> 00:43:00,250
这意味着这批比特币永远不能被花费。

00:43:00,250 --> 00:43:02,110
为什么你要这么做呢？

00:43:02,110 --> 00:43:06,070
为什么要创建一批永远不能被花费的比特币呢？

00:43:06,070 --> 00:43:08,910
在比特币中通常发生的情况是，

00:43:08,910 --> 00:43:11,560
有人会创建一笔交易，

00:43:11,560 --> 00:43:15,190
然后他们还会创建一个没有比特币的输出，

00:43:15,190 --> 00:43:17,680
就像一个虚拟的输出，

00:43:17,680 --> 00:43:19,900
然后在锁定脚本中，

00:43:19,900 --> 00:43:21,730
他们会放入return操作码，

00:43:21,730 --> 00:43:24,010
所以它不能被花费，

00:43:24,010 --> 00:43:25,750
但是里面没有比特币，

00:43:25,750 --> 00:43:28,540
所以也不能被花费。

00:43:28,540 --> 00:43:31,330
在return操作码后面，他们会放入一些数据。

00:43:31,330 --> 00:43:36,940
例如你可以将文本“will you marry me”，

00:43:36,940 --> 00:43:39,880
以ASCII转换为十六进制，

00:43:39,880 --> 00:43:42,280
并将其放入锁定脚本的return操作码后面。

00:43:42,280 --> 00:43:49,060
这是一个标准交易的标准格式，

00:43:49,060 --> 00:43:51,990
所以基本上，

00:43:51,990 --> 00:44:00,610
这种格式只是一种将任意数据添加到比特币交易的方式。

00:44:00,610 --> 00:44:06,760
所以当你听到人们在区块链中插入数据时，

00:44:06,760 --> 00:44:12,370
这是一个典型的创建交易以添加数据到区块链的最简单方式，

00:44:12,370 --> 00:44:14,620
你只需要创建一个空的输出，

00:44:14,620 --> 00:44:17,350
并在锁定脚本中使用return操作码，

00:44:17,350 --> 00:44:23,050
然后在后面放入你想要的任何数据。

00:44:23,050 --> 00:44:30,670
有什么疑问吗？

00:44:30,670 --> 00:44:33,610
这就是使用比特币的五个主要标准脚本。

00:44:33,610 --> 00:44:38,320
如果你使用"return"关键词的话，

00:44:38,320 --> 00:44:42,370
社区对此的态度是可以接受的，

00:44:42,370 --> 00:44:49,740
或者他们对此并不十分满意？

00:44:49,740 --> 00:44:51,970
这听起来很有趣，

00:44:51,970 --> 00:44:53,500
我认为这是有些争议的，

00:44:53,500 --> 00:44:55,750
因为它应该只是一个简单的交易系统，

00:44:55,750 --> 00:44:58,650
但这个"return"关键词的存在，

00:44:58,650 --> 00:45:03,070
我不太明白为什么它被允许，

00:45:03,070 --> 00:45:05,530
或者为什么它以某种方式被允许。

00:45:05,530 --> 00:45:10,660
因为比特币对此是非常严格的，

00:45:10,660 --> 00:45:14,020
它希望成为一个小型数据库，

00:45:14,020 --> 00:45:18,010
而这个关键词的存在就使得人们可以在比特币中插入任意的数据。

00:45:18,010 --> 00:45:20,860
我对此并不太确定。但是就目前而言，

00:45:20,860 --> 00:45:25,180
这是一个被允许的标准脚本，

00:45:25,180 --> 00:45:30,420
你可以使用它在区块链中通过交易插入任意数据。

00:45:30,420 --> 00:45:33,850
回到你之前的问题，

00:45:33,850 --> 00:45:37,750
这些是你在区块链上最常见的标准脚本。

00:45:37,750 --> 00:45:40,540
前四个主要是支付公钥，

00:45:40,540 --> 00:45:46,310
第五个就像是一个额外的附加项。

00:45:46,310 --> 00:45:50,850
但在脚本编程语言中，

00:45:50,850 --> 00:45:55,080
你有很多不同的运算符可以使用。

00:45:55,080 --> 00:45:57,119
到目前为止，我只是介绍了这些标准脚本，

00:45:57,119 --> 00:45:59,190
但你可能已经注意到，

00:45:59,190 --> 00:46:01,890
我们有这些数字操作码，

00:46:01,890 --> 00:46:04,800
然后还有一些其他的运算符，

00:46:04,800 --> 00:46:06,450
比如数学运算符，

00:46:06,450 --> 00:46:08,750
如加法和减法，

00:46:08,750 --> 00:46:11,010
条件运算符if和else，

00:46:11,010 --> 00:46:17,430
还有更多的哈希运算符，

00:46:17,430 --> 00:46:20,580
比如sha-256和ripemd-160。

00:46:20,580 --> 00:46:25,470
所以这个脚本编程语言有很多不同的操作码，

00:46:25,470 --> 00:46:29,130
我们可以使用它们来创建不同类型的脚本。

00:46:29,130 --> 00:46:35,520
例如你可以在一批比特币创建一个锁，

00:46:35,520 --> 00:46:37,590
这只是一个数学难题，

00:46:37,590 --> 00:46:41,190
你可以使用加起来等于8，

00:46:41,190 --> 00:46:42,570
当有人想要解锁这个脚本，

00:46:42,570 --> 00:46:43,770
如果他们想要解锁并花费它，

00:46:43,770 --> 00:46:46,380
他们需要提供两个数字，

00:46:46,380 --> 00:46:49,650
这个脚本就可以被解锁。

00:46:49,650 --> 00:46:51,359
基本上，两个数字被推送到栈上，

00:46:51,359 --> 00:46:53,550
堆栈会把它们加起来，

00:46:53,550 --> 00:46:55,530
然后把结果推回到栈上，

00:46:55,530 --> 00:46:57,390
然后8会被推送到栈顶，

00:46:57,390 --> 00:46:59,250
如果栈顶的两个元素相等，

00:46:59,250 --> 00:47:02,430
那么比特币就可以被花费了。

00:47:02,430 --> 00:47:06,420
例如要在解锁脚本中，解锁这批比特币，

00:47:06,420 --> 00:47:08,600
你只需要提供两个相加等于8的数字。

00:47:08,600 --> 00:47:13,050
类似地，你可以创建一个哈希谜题，

00:47:13,050 --> 00:47:15,930
你可以使用sha 256操作码，

00:47:15,930 --> 00:47:18,420
然后在其后面放入一些数据，

00:47:18,420 --> 00:47:22,260
然后是等于操作码。

00:47:22,260 --> 00:47:23,820
如果你想解锁这批比特币，

00:47:23,820 --> 00:47:25,710
你只需要提供一些数据，

00:47:25,710 --> 00:47:30,600
这些数据的哈希值就是锁定代码中的这部分数据。

00:47:30,600 --> 00:47:35,400
这种类型的锁定脚本，

00:47:35,400 --> 00:47:37,170
你可以在区块链上找到，

00:47:37,170 --> 00:47:40,080
我现在想不出任何链接，

00:47:40,080 --> 00:47:42,450
但你知道，

00:47:42,450 --> 00:47:44,790
你可以创建这样的脚本，

00:47:44,790 --> 00:47:50,000
它们可以被挖掘到区块链上。

00:47:50,000 --> 00:47:53,970
然而在比特币中，

00:47:53,970 --> 00:47:56,640
你不能创建一个非标准的脚本，

00:47:56,640 --> 00:48:00,780
但如果你试图将其插入到一个比特币核心节点中，

00:48:00,780 --> 00:48:06,000
比特币程序实现实际上会保留一个标准脚本的列表，

00:48:06,000 --> 00:48:07,950
所以如果你创建一个非标准的脚本，

00:48:07,950 --> 00:48:10,940
它们实际上会被拒绝，

00:48:10,940 --> 00:48:15,150
这是有点可惜的。

00:48:15,150 --> 00:48:19,430
据我所知，这样做的原因是，

00:48:19,430 --> 00:48:22,230
因为这些操作码和运算符有很多种，

00:48:22,230 --> 00:48:27,240
并且并非所有的组合都经过了彻底的测试，

00:48:27,240 --> 00:48:32,040
所以可能有人能创建出一种操作码的组合，

00:48:32,040 --> 00:48:35,310
当他们将交易插入到一个节点时，

00:48:35,310 --> 00:48:37,680
该节点可能需要一段时间来处理或验证它，

00:48:37,680 --> 00:48:43,170
所以所有的标准脚本都被认为能快速运行，

00:48:43,170 --> 00:48:45,420
并且可以快速验证。

00:48:45,420 --> 00:48:50,280
为了防止任何人试图通过验证脚本，

00:48:50,280 --> 00:48:54,510
创建数千个慢或昂贵的验证脚本，

00:48:54,510 --> 00:48:56,460
并将它们插入到一个节点中来攻击网络，

00:48:56,460 --> 00:49:03,570
比特币或比特币核心节点会拒绝任何非标准的内容。

00:49:03,570 --> 00:49:05,700
我认为这有点目标不明，

00:49:05,700 --> 00:49:08,370
因为脚本虽然是一种简单的语言，

00:49:08,370 --> 00:49:13,860
但它确实有各种运算符可以使用和创建脚本，

00:49:13,860 --> 00:49:17,910
但比特币核心限制了脚本的数量或类型，

00:49:16,320 --> 00:49:17,910
你可以批量处理比特币。

00:49:17,910 --> 00:49:25,380
但这并不意味着非标准脚本是无效的，

00:49:25,380 --> 00:49:31,770
尽管一个比特币核心节点会拒绝它们，

00:49:31,770 --> 00:49:34,350
或者不接受它们进入他们的内存池。

00:49:34,350 --> 00:49:36,330
如果一个非标准脚本被挖掘到区块链上，

00:49:36,330 --> 00:49:39,120
那么这些区块就是有效的，

00:49:39,120 --> 00:49:47,220
只要实际的脚本本身是有效的，

00:49:47,220 --> 00:49:49,710
包含所有的标准操作符和数据，

00:49:49,710 --> 00:49:52,590
如果它被挖掘到一个区块中，

00:49:52,590 --> 00:49:56,850
每个节点都会接受它，

00:49:56,850 --> 00:49:58,080
但如果一个非标准脚本试图进入他们的内存池，

00:49:58,080 --> 00:50:00,000
他们就不会接受。

00:50:00,000 --> 00:50:02,040
这样做的原因是，

00:50:02,040 --> 00:50:04,980
内存池在短时间内可以接收大量的交易，

00:50:04,980 --> 00:50:08,160
所以你可以创建一个慢速验证的交易，

00:50:08,160 --> 00:50:13,200
并试图插入网络中的数千个交易，

00:50:13,200 --> 00:50:14,970
这可能会使网络瘫痪，

00:50:14,970 --> 00:50:18,360
因为每个人都在慢慢地尝试验证所有这些非标准交易。

00:50:18,360 --> 00:50:26,280 
然而一个区块只能容纳有限数量的交易，

00:50:26,280 --> 00:50:31,350
所以如果有人插入了一些慢速验证的交易到区块中，

00:50:31,350 --> 00:50:32,760
因为区块每10分钟添加一次，

00:50:32,760 --> 00:50:35,070
他们可能会被验证，

00:50:35,070 --> 00:50:38,970
验证它们会更容易，

00:50:38,970 --> 00:50:42,060
或者不会有那么多的问题，

00:50:42,060 --> 00:50:48,080
而在内存池中有数千个非标准脚本则可能是一个大风险。

00:50:48,080 --> 00:50:50,370
但是像我说的，非标准脚本是有效的，

00:50:50,370 --> 00:50:52,080
不幸的是，将其挖掘到区块链上是困难的。

00:50:52,080 --> 00:50:58,140
所以我不确定如果节点不接受它，

00:50:58,140 --> 00:51:00,450
你将如何最终挖掘到它，

00:51:00,450 --> 00:51:07,980
因为即使是矿工也会有这样的想法。

00:51:07,980 --> 00:51:10,890
所以你有的选择并不多，

00:51:10,890 --> 00:51:18,240
一种是将你的非标准交易发送给一个矿工，

00:51:18,240 --> 00:51:21,810
他会接受它们并将其添加到区块链中，

00:51:21,810 --> 00:51:26,640
但我不知道有哪些矿工让你可以发送非标准交易，

00:51:26,640 --> 00:51:29,460
或者第二种选择，

00:51:29,460 --> 00:51:32,190
虽然不一定容易，

00:51:32,190 --> 00:51:34,470
就是自己挖掘到区块链上。

00:51:34,470 --> 00:51:38,610
然而除非你有大量的处理能力，

00:51:38,610 --> 00:51:40,860
否则这可能会有些棘手。

00:51:40,860 --> 00:51:43,080
你知道，实际上，

00:51:43,080 --> 00:51:46,680
你可能无法将非标准的交易加入区块链，

00:51:46,680 --> 00:51:48,420
这非常可惜。

00:51:48,420 --> 00:51:52,830
然而就像我说的，

00:51:52,830 --> 00:51:56,070
只有比特币核心实现才会保留一个列表，

00:51:56,070 --> 00:51:58,140
也许其他的也会，

00:51:58,140 --> 00:52:03,210
但是你可以用你自己的编程语言编写你的比特币节点，

00:52:03,210 --> 00:52:06,090
用你自己的规则，你可以接受非标准的脚本。

00:52:06,090 --> 00:52:11,370
但是如果没有其他人在网络上运行你的相同软件，

00:52:11,370 --> 00:52:12,549
每次你尝试和比特币核心节点进行交易，

00:52:12,549 --> 00:52:14,009
它们都会被拒绝。

00:52:14,009 --> 00:52:19,349
所以出于所有的目的和原因，

00:52:19,349 --> 00:52:25,239 
不幸的是，非标准的脚本并不会真正被使用，

00:52:25,239 --> 00:52:27,400
并被添加到比特币的区块链上，

00:52:27,400 --> 00:52:34,769 
我认为这是一种遗憾。

00:52:34,769 --> 00:52:36,459
最后，这基本上，

00:52:36,459 -->00:52:39,969
就是你需要了解的关于脚本和它的工作方式的所有内容。

00:52:39,969 --> 00:52:41,410
如果你理解了所有的操作码、数据和堆栈，

00:52:41,410 --> 00:52:43,689
那就是脚本的工作原理。

00:52:43,689 --> 00:52:45,579
它只是一个在堆栈上执行的小型编程语言，

00:52:45,579 --> 00:52:49,089
如果在最后堆栈顶部留下一个1，

00:52:49,089 --> 00:52:50,859
那么脚本就是有效的，

00:52:50,859 --> 00:52:52,859
比特币就可以被花费。

00:52:52,859 --> 00:52:57,359
你知道，它总是像这样，

00:52:57,359 --> 00:52:59,709
或者更近期，他们实际上不再允许这样做，

00:52:59,709 --> 00:53:06,059
因为他们可能想减小区块的大小。

00:53:06,059 --> 00:53:12,729
我认为从一开始，

00:53:12,729 --> 00:53:17,589
比特币就有这套标准的脚本，

00:53:17,589 --> 00:53:20,769
但是从我所了解的，

00:53:20,769 --> 00:53:24,789
我知道对非标准的限制，

00:53:24,789 --> 00:53:27,819
我认为最终计划是取消这种限制，

00:53:27,819 --> 00:53:31,569
但是这还没有发生。

00:53:31,569 --> 00:53:39,449
最后你在哪里能找到这个实际的操作码呢？

00:53:39,449 --> 00:53:41,979
所以你在哪里找到这个，

00:53:41,979 --> 00:53:46,809
我只是简单地使用了锁定脚本和解锁脚本，

00:53:46,809 --> 00:53:50,469
使用很少的图表来表示它，

00:53:50,469 --> 00:53:51,939
你在哪里找到这个实际的解锁代码在交易数据中呢？

00:53:51,939 --> 00:53:55,529
正如我所说，

00:53:55,529 --> 00:53:58,209
当你进行比特币交易时，

00:53:58,209 --> 00:54:01,929
你说这就是交易数据，

00:54:01,929 --> 00:54:03,609
交易数据的第一部分只是选择一个输入，

00:54:03,609 --> 00:54:05,319
这就是选择这个输入。

00:54:05,319 --> 00:54:07,059
第二个部分创建输出，

00:54:07,059 --> 00:54:13,449
因此在交易数据的输出代码中，

00:54:13,449 --> 00:54:16,630
包含脚本公钥，即锁定脚本。

00:54:16,630 --> 00:54:19,619
这部分的第一部分是比特币的数量，

00:54:19,619 --> 00:54:24,090
第二部分是脚本公钥，

00:54:24,090 --> 00:54:26,160
我在这里出了一些错误，

00:54:26,160 --> 00:54:27,330
但不用担心，

00:54:27,330 --> 00:54:31,140
第二部分是脚本公钥，

00:54:31,140 --> 00:54:36,330
也就是我们在交易数据中找到的锁定脚本。

00:54:36,330 --> 00:54:41,090
这个特定的锁定脚本的解锁脚本在哪里呢？

00:54:41,090 --> 00:54:50,850
它会出现在试图花费这批比特币或这个输出的第二笔交易中。

00:54:50,850 --> 00:54:52,920
在这第二笔交易中，

00:54:52,920 --> 00:54:55,230
你有一个输入，

00:54:55,230 --> 00:54:58,350
它所做的只是引用来自之前交易的一个输出。

00:54:58,350 --> 00:55:00,690
就是引用这里，

00:55:00,690 --> 00:55:05,790
第二笔交易也会从中创建新的输出，

00:55:05,790 --> 00:55:10,920
但是我们在这第二笔交易中感兴趣的是解锁代码。

00:55:10,920 --> 00:55:14,330
当它引用这个之前的输出时，

00:55:14,330 --> 00:55:18,290
解锁代码就在输入里。

00:55:18,290 --> 00:55:21,240
这就是解锁代码，

00:55:21,240 --> 00:55:23,520
有时也被称为脚本签名，

00:55:23,520 --> 00:55:25,950
因为它是一个脚本，

00:55:25,950 --> 00:55:28,320
并且通常包含公钥的签名。

00:55:28,320 --> 00:55:31,200
所以这就是解锁代码。

00:55:31,200 --> 00:55:35,730
这显然是十六进制的，

00:55:35,730 --> 00:55:41,370
我们如何从中得到操作码呢？

00:55:41,370 --> 00:55:46,910
我们只需要对其进行解码。

00:55:46,910 --> 00:55:51,030
如果我们运行锁定脚本和解锁脚本中的每个字节，

00:55:51,030 --> 00:55:56,750
每个字节都会对应一个特定的操作码。

00:55:56,750 --> 00:56:05,910
所以十六进制中的字节76等于重复或复制的操作码。

00:56:05,910 --> 00:56:07,170
接下来的a9代表哈希160，

00:56:07,170 --> 00:56:15,650
而14并没有对应的操作码。

00:56:15,650 --> 00:56:19,080
但是如果任何东西在十六进制中小于4B，

00:56:19,080 --> 00:56:30,710
那么这个数字表示有这么多字节的数据需要被推入栈中。

00:56:30,710 --> 00:56:35,000
所以14小于4B，

00:56:35,000 --> 00:56:37,040
表示将有这么多字节推入堆栈，

00:56:37,040 --> 00:56:39,950
或者这只是数据而不是操作码，

00:56:39,950 --> 00:56:43,730
十进制中的14就是20字节，

00:56:43,730 --> 00:56:45,560
所以我们有接下来的20字节，

00:56:45,560 --> 00:56:50,510
这只是一部分数据。

00:56:50,510 --> 00:56:53,870
然后我们继续，我们有88，这是EQUAL验证，AC是校验和。

00:56:53,870 --> 00:56:58,610
然后我们就解码了锁定脚本，

00:56:58,610 --> 00:57:01,490
它只是一堆字节对应的操作码，

00:57:01,490 --> 00:57:03,350
如果一个字节低于某个数，

00:57:03,350 --> 00:57:10,190
那么就意味着接下来的X字节数是一堆数据。

00:57:10,190 --> 00:57:12,290
所以我们就解码了锁定脚本，

00:57:12,290 --> 00:57:14,000
然后我们来到解锁脚本，

00:57:14,000 --> 00:57:19,970
所有的解锁脚本就是对这种特定类型的锁进行解锁，

00:57:19,970 --> 00:57:23,000
这就是签名和公钥，

00:57:23,000 --> 00:57:25,100
所以47就是小于4B，

00:57:25,100 --> 00:57:28,520
这表示有这么多个字节数的数据，

00:57:28,520 --> 00:57:32,180
这就是签名，

00:57:32,180 --> 00:57:34,550
然后是41，这个字节数的数据，

00:57:34,550 --> 00:57:35,990
只是更多的数据，这就是公钥。

00:57:35,990 --> 00:57:39,500
所以我们已经解码了锁定和解锁脚本，

00:57:39,500 --> 00:57:44,570
这是有意义的。

00:57:44,570 --> 00:57:51,290
锁定脚本可以在一个交易的输出中找到，

00:57:51,290 --> 00:58:00,440
然后解锁脚本是在一个新的交易的输入中找到的，

00:58:00,440 --> 00:58:06,560
这个新的交易试图花费这个输出。

00:58:06,560 --> 00:58:13,170
现在总结一下我们在这个视频中做的所有事情。

00:58:13,170 --> 00:58:14,610
在一个比特币交易中，

00:58:14,610 --> 00:58:16,440
你只需要把一批比特币拿出来，

00:58:16,440 --> 00:58:18,720
创建一个新的批次，

00:58:18,720 --> 00:58:21,000
然后你想把它发送给别人，

00:58:21,000 --> 00:58:24,900
他们会有一个公钥，

00:58:24,900 --> 00:58:28,290
他们会给你一个地址，

00:58:28,290 --> 00:58:32,160
然后你为他们构建一个锁定脚本，

00:58:32,160 --> 00:58:35,520
并锁定比特币，

00:58:35,520 --> 00:58:37,410
直到他们使用公钥或者公钥的哈希。

00:58:37,410 --> 00:58:42,990
这个特殊的格式叫做Pay To Pubkey Hash，

00:58:42,990 --> 00:58:47,580
这是锁定脚本。

00:58:47,580 --> 00:58:52,440
所以当你想来或者这个人想来花费这些比特币时，

00:58:52,440 --> 00:58:54,480
他们需要提供一个解锁脚本，

00:58:54,480 --> 00:58:57,930
然后这个脚本会被运行，

00:58:57,930 --> 00:59:02,460
解锁脚本在第二个交易中提供，

00:59:02,460 --> 00:59:04,800
但是当我们一起运行完整的脚本时，

00:59:04,800 --> 00:59:06,960
我们把这个放在开始，

00:59:06,960 --> 00:59:09,210
这个被添加到栈的开始，

00:59:09,210 --> 00:59:11,609
然后我们运行脚本，

00:59:11,609 --> 00:59:14,940
使用操作码和数据，

00:59:14,940 --> 00:59:16,800
如果在运行完整的脚本后，栈上剩下一个1，

00:59:16,800 --> 00:59:21,780
那么这批比特币或者脚本就是有效的，

00:59:21,780 --> 00:59:23,520
这批比特币可以被成功解锁和花费。

00:59:23,520 --> 00:59:31,710
这就是比特币锁定机制的工作原理。

00:59:31,710 --> 00:59:34,080
它使用这种小型编程语言，

00:59:34,080 --> 00:59:36,210
即脚本，包含数据和操作码，

00:59:36,210 --> 00:59:39,030
并在堆栈上运行。

00:59:39,030 --> 00:59:44,790
这个脚本有许多不同的方法，

00:59:44,790 --> 00:59:52,980
然而我们的比特币核心实现将你限制在这五种主要格式，

00:59:52,980 --> 00:59:59,780
来锁定比特币。

00:59:59,780 --> 01:00:01,520
这里有四个词，你得知道：

01:00:01,520 --> 01:00:03,200
Pay To Pubkey Hash，

01:00:03,200 --> 01:00:05,780
这是最常用的一种；Pay To Pubkey，

01:00:05,780 --> 01:00:08,360
这是Pay To Pubkey Hash的简化版本，

01:00:08,360 --> 01:00:12,080
但现在并不常用，

01:00:12,080 --> 01:00:14,780
Pay To Pubkey Hash是最常见的。

01:00:14,780 --> 01:00:18,320
然后我们有Pay To Multisig，

01:00:18,320 --> 01:00:20,180
以及Pay To Script Hash，

01:00:20,180 --> 01:00:25,730
这只是传递一个Pay To Multisig锁定脚本的更简单的方式。

01:00:25,730 --> 01:00:31,940
所以我们有了脚本，

01:00:31,940 --> 01:00:36,850
以及如何在比特币中锁定和解锁一批比特币。

01:00:36,850 --> 01:00:40,780
关于这个视频或其任何部分有任何问题吗？

01:00:40,780 --> 01:00:49,520
如果这个演示让你理解了脚本是如何工作的，

01:00:49,520 --> 01:00:50,780
那么我认为这并不难，

01:00:50,780 --> 01:00:57,020
只有关于Pay To Script Hash部分有几点需要注意，

01:00:57,020 --> 01:01:02,840
但实际上执行脚本是相当简单的，

01:01:02,840 --> 01:01:10,540
只是一个简单的编程语言。

01:01:10,540 --> 01:01:12,890
讲述到其他的一些内容都相当不错，

01:01:12,890 --> 01:01:18,560
这个Pay To Script Hash后来被添加到比特币上，

01:01:18,560 --> 01:01:19,430
所以它并不是原始实现的一部分，

01:01:19,430 --> 01:01:22,760
这就是为什么它感觉有点复杂。

01:01:22,760 --> 01:01:27,380
但你知道，它是后来添加的，

01:01:27,380 --> 01:01:29,150
所以它有这些额外的验证规则。

01:01:29,150 --> 01:01:39,230
我写了一点代码，

01:01:39,230 --> 01:01:42,560
这个代码可以为你解码或编码一个脚本，

01:01:42,560 --> 01:01:45,860
并为你运行它，所以如果你想玩玩看，

01:01:45,860 --> 01:01:47,720
它非常简单。

01:01:47,720 --> 01:01:51,230
我不会在生产中正式使用它，

01:01:51,230 --> 01:01:52,880
这更多的是为了从中学习，

01:01:52,880 --> 01:01:54,380
看看脚本有多简单。

01:01:54,380 --> 01:01:58,560
例如，

01:01:58,560 --> 01:02:02,230
如果输入锁定脚本的代码，

01:02:02,230 --> 01:02:05,589
这就是一个典型的比特币交易，

01:02:05,589 --> 01:02:11,829
显然锁定脚本和解锁脚本提供了它。

01:02:11,829 --> 01:02:14,980
所以它已经被花费了，

01:02:14,980 --> 01:02:18,609
假设你想解码一些脚本，

01:02:18,609 --> 01:02:21,369
你可以把锁定脚本放在这里，

01:02:21,369 --> 01:02:23,619
它已经识别出这是一个Pay To Pubkey Hash，

01:02:23,619 --> 01:02:26,800
因为它有一个特殊的格式，所以它已经解码了。

01:02:26,800 --> 01:02:29,950
然后当你想解锁一些东西时，

01:02:29,950 --> 01:02:31,630
你需要提供锁定脚本。

01:02:31,630 --> 01:02:35,619
所以这就是两段数据，

01:02:35,619 --> 01:02:38,230
没有操作码在里面，

01:02:38,230 --> 01:02:40,030
所以我想运行这个脚本，

01:02:40,030 --> 01:02:42,220
这个小程序会为你运行它，

01:02:42,220 --> 01:02:45,490
只是为了模拟它。

01:02:45,490 --> 01:02:48,369
这是整个脚本，

01:02:48,369 --> 01:02:51,520
如果我能把它拉过来，

01:02:51,520 --> 01:02:54,339
它就是脚本各个部分的一个大数组。

01:02:54,339 --> 01:02:57,579
假设这是堆栈，

01:02:57,579 --> 01:03:00,670
它会把数据推入堆栈，

01:03:00,670 --> 01:03:03,369
然后这是脚本的剩余部分，

01:03:03,369 --> 01:03:05,500
所以我们在这里得到了重复的内容，

01:03:05,500 --> 01:03:07,690
我将复制顶部元素，hash160，

01:03:07,690 --> 01:03:10,300
并将它们哈希处理，

01:03:10,300 --> 01:03:14,020
然后我们得到了公钥哈希，

01:03:14,020 --> 01:03:16,540
我将其放在顶部进行EQUAL验证，

01:03:16,540 --> 01:03:17,980
它会取顶部两个元素，如果它们相等，

01:03:17,980 --> 01:03:20,020
我们会把任何东西推回堆栈，

01:03:20,020 --> 01:03:23,079
所以在我们执行了这个操作之后，

01:03:23,079 --> 01:03:24,849
这两个元素会消失，

01:03:24,849 --> 01:03:27,250
因为它们是相等的，然后是OP checksig，

01:03:27,250 --> 01:03:34,089
将根据这个公钥检查这个签名，

01:03:34,089 --> 01:03:36,940
然后我们会把true推到堆栈上，

01:03:36,940 --> 01:03:39,069
true实际上并不使用比特币，

01:03:39,069 --> 01:03:41,710
它应该是1，但在这是相同的，

01:03:41,710 --> 01:03:44,650
所以这是一个有效的脚本。

01:03:44,650 --> 01:03:47,589
所以我会在描述中添加这个链接，

01:03:47,589 --> 01:03:49,030
如果你想试玩这段代码，

01:03:49,030 --> 01:03:53,219
它就在这里，你可以看到代码是如何运行的。

01:03:53,219 --> 01:03:58,359
另外如果你去Bitcoin的维基，，

01:03:58,359 --> 01:04:01,689
进入脚本页面，

01:04:01,689 --> 01:04:04,749
它涵盖了所有可以使用的不同操作码。

01:04:04,749 --> 01:04:06,609
如你所见，

01:04:06,609 --> 01:04:08,439
有很多我只是稍微提及了一下，

01:04:08,439 --> 01:04:10,539
但像我说的，

01:04:10,539 --> 01:04:12,279
不幸的是，

01:04:12,279 --> 01:04:14,859
我们实际上只能使用标准脚本，

01:04:14,859 --> 01:04:19,719
尽管脚本包含了所有这些不同的代码。

01:04:19,719 --> 01:04:26,640
最后我找到了这个小型的IDE，

01:04:26,640 --> 01:04:30,130
它允许你输入一个脚本，

01:04:30,130 --> 01:04:35,829
然后它会为你在堆栈上可视化运行脚本。

01:04:35,829 --> 01:04:37,569
我认为它涵盖了每一个操作码，

01:04:37,569 --> 01:04:43,569
所以你知道，你可以添加更复杂的脚本在这里，

01:04:43,569 --> 01:04:47,619
然后试着运行它，

01:04:47,619 --> 01:04:52,719
它会为你运行。

01:04:52,719 --> 01:04:54,729
我没有制作这个，这是别人做的，

01:04:54,729 --> 01:04:59,859
但它可能是一个很好的方式来可视化堆栈的工作方式，

01:04:59,859 --> 01:05:02,439
并插入你自己的脚本并观察它们的运行情况，

01:05:02,439 --> 01:05:04,179
它在这里，我在描述中提供了另一个链接。

01:05:04,179 --> 01:05:11,799
最后，如果你想在我的浏览器中浏览脚本，

01:05:11,799 --> 01:05:18,009
转到任何交易，你可以看到，

01:05:18,009 --> 01:05:20,199
这是一个包含输入和输出的交易，

01:05:20,199 --> 01:05:23,469
点击解锁部分或锁定部分，

01:05:23,469 --> 01:05:30,249
它会显示你解锁代码以及放在交易之上的锁定代码，

01:05:30,249 --> 01:05:33,029
这是后续的解锁代码，

01:05:33,029 --> 01:05:37,569
所以当你一起运行这些代码时，

01:05:37,569 --> 01:05:39,309
你应该把这个放到一个堆栈上，

01:05:39,309 --> 01:05:41,979
你应该能够可视化。

01:05:41,979 --> 01:05:46,419
所有的工作或希望不会实际上为你可视化任何东西，

01:05:46,419 --> 01:05:48,999
但所有的操作码和数据都在那里，

01:05:48,999 --> 01:05:50,380
如果你看看的话，

01:05:50,380 --> 01:05:52,979
也许你可以有所触动。