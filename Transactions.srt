00:00:00,230 --> 00:00:03,449
所以在这节课中，

00:00:03,449 --> 00:00:06,210
我将向大家介绍比特币交易的基本原理。

00:00:06,210 --> 00:00:09,480
希望在本视频结束后，

00:00:09,480 --> 00:00:11,580
大家能够理解比特币交易是如何进行的，

00:00:11,580 --> 00:00:14,219
比特币是什么样的，

00:00:14,219 --> 00:00:18,510
以及如何构建自己的比特币交易。

00:00:18,510 --> 00:00:20,130
我会像上次一样，将视频分为三个部分。

00:00:20,130 --> 00:00:27,359
首先我将从比特币交易的基础知识讲起，

00:00:27,359 --> 00:00:33,300
我会解释它们是什么样的数据，代表了什么，

00:00:33,300 --> 00:00:37,440
我将讲解包含你需要了解的关于交易结构和工作原理的所有内容。

00:00:37,440 --> 00:00:40,379
之后我会继续讨论数据。

00:00:40,379 --> 00:00:43,680
这样你们不仅能看到交易执行情况的直观表示，

00:00:43,680 --> 00:00:50,100
还能了解数据是什么样的和如何工作的。

00:00:50,100 --> 00:00:52,020
如果你想查看实际的内部数据，

00:00:52,020 --> 00:00:58,590
我将向你展示数据如何描述以及它的工作原理。

00:00:58,590 --> 00:01:01,680
讲解完工作原理和数据的外观之后，

00:01:01,680 --> 00:01:11,159
我会通过一些实例以便从头开始构建一个交易，

00:01:11,159 --> 00:01:16,799
向你展示如何创建自己的比特币交易。

00:01:16,799 --> 00:01:23,490
现在我将从第一部分开始，

00:01:23,490 --> 00:01:28,020
介绍比特币交易如何工作的基础知识。

00:01:28,020 --> 00:01:30,840
在上一个视频中，

00:01:30,840 --> 00:01:34,350
我介绍了挖矿的工作原理，

00:01:34,350 --> 00:01:36,090
每台计算机都代表网络上的一个比特币节点，

00:01:36,090 --> 00:01:37,920
它们共同构成了整个网络，

00:01:37,920 --> 00:01:41,210
并共享一个称为区块链的文件。

00:01:41,210 --> 00:01:45,630
当你想要进行一笔交易，

00:01:45,630 --> 00:01:46,799
并向某人发送一些比特币时，

00:01:46,799 --> 00:01:55,300
你需要做的就是创建一行数据。

00:01:55,300 --> 00:01:57,250
这条小绿线代表了一笔比特币交易，

00:01:57,250 --> 00:02:00,280
它本质上是一行数据。

00:02:00,280 --> 00:02:04,000
你将其发送到网络中的任何一个节点，

00:02:04,000 --> 00:02:06,370
节点会把它保存在自己的内存池中，

00:02:06,370 --> 00:02:09,399
并把它转发给其他相连的节点。

00:02:09,399 --> 00:02:12,340
这个过程会一直重复，

00:02:12,340 --> 00:02:16,450
直到所有节点的内存池中都获得了这笔交易的副本。

00:02:16,450 --> 00:02:20,670
然后所有这些节点会

00:02:20,670 --> 00:02:27,370
竞争尝试将内存池中的交易挖掘到这个名为区块链的文件中。

00:02:27,370 --> 00:02:29,709
如果某个节点成功地挖掘出了一个区块，

00:02:29,709 --> 00:02:33,550
它就会把这个区块发送给其他相连的节点，

00:02:33,550 --> 00:02:37,800
这些节点随后会把这个区块加入到自己的区块链副本中。

00:02:37,800 --> 00:02:41,110
直到所有节点都更新了自己的区块链副本。

00:02:41,110 --> 00:02:44,890
当这个区块被加入到区块链中后，

00:02:44,890 --> 00:02:47,350
我们就可以查看区块链并找到这笔交易，

00:02:47,350 --> 00:02:48,820
因为它现在已经成为区块链的一部分了。

00:02:48,820 --> 00:02:55,600
比特币的所有权就从一个人转移到了另一个人。

00:02:55,600 --> 00:02:58,090
今天我要介绍的是

00:02:58,090 --> 00:03:03,370
这个过程是如何运作的，

00:03:03,370 --> 00:03:08,440
你如何创建这样的单行数据，

00:03:08,440 --> 00:03:16,209
以及它是如何来进行比特币所有权的转移。

00:03:16,209 --> 00:03:19,870
我们来看看比特币交易的基础知识，

00:03:19,870 --> 00:03:21,750
这条绿线代表的就是交易数据，

00:03:21,750 --> 00:03:28,600
它将比特币的所有权从我转移到你。

00:03:28,600 --> 00:03:30,940
如果我们放大这条绿线，

00:03:30,940 --> 00:03:32,470
它仍然代表着交易数据。

00:03:32,470 --> 00:03:34,000
我现在还不打算向你展示具体的数据内容，

00:03:34,000 --> 00:03:41,350
这里只是对实际数据的简化表示。

00:03:35,110 --> 00:03:41,350
首先这是区块链。

00:03:41,350 --> 00:03:47,950
假设这代表的是之前视频中提到的区块链的延续。

00:03:47,950 --> 00:03:50,290
从上次的视频中我们知道，

00:03:50,290 --> 00:03:54,040
区块链由一系列包含交易记录的区块组成。

00:03:54,040 --> 00:03:55,900
因此，

00:03:55,900 --> 00:04:00,150
区块链本质上是一个记录了大量交易数据的文件。

00:04:00,150 --> 00:04:05,069
我们今天要探讨的是区块链交易，

00:04:05,069 --> 00:04:10,530
以一种直观的方式来展示区块链中的交易数据。

00:04:07,530 --> 00:04:10,530
区块链本质上是由一些不同批次的比特币组成的，

00:04:10,530 --> 00:04:13,230
每一批比特币都像是这一个小橙色的盒子，

00:04:13,230 --> 00:04:21,570
所以每一个小橙盒代表一个独立的比特币批次。

00:04:21,570 --> 00:04:26,040
每个盒子都上了锁，

00:04:26,040 --> 00:04:31,530
这是人们能够安全持有比特币的原因，

00:04:28,889 --> 00:04:31,530
它们上面都有锁，

00:04:31,530 --> 00:04:35,550
这样只有能够解锁它们的人才能使用它们，

00:04:33,270 --> 00:04:35,550
并将它们发送给其他人。

00:04:35,550 --> 00:04:39,030
你可以想象一下区块链像什么？

00:04:39,030 --> 00:04:41,520
区块链就像是银行里的一排保险箱，

00:04:41,520 --> 00:04:49,440
每个保险箱里都装着不同数量的比特币。

00:04:49,440 --> 00:04:52,770
现在如果我想构建一个交易，

00:04:52,770 --> 00:04:54,169
将比特币从我这里转移到你那里，

00:04:54,169 --> 00:04:59,400
我需要做的第一步：

00:04:59,400 --> 00:05:02,880
是在区块链上中选择一批比特币。

00:05:02,880 --> 00:05:08,580
每一批比特币都有它们自己的唯一参考编码，

00:05:08,580 --> 00:05:10,380
这样你就可以轻松地选中它们。

00:05:10,380 --> 00:05:12,720
在这个第一部分，

00:05:12,720 --> 00:05:16,260
你选择你想要发送的那批比特币。

00:05:16,260 --> 00:05:17,850
我在这里输入一些参考代码，

00:05:17,850 --> 00:05:19,530
选择了要发送的比特币批次。

00:05:19,530 --> 00:05:29,220
第二步是解锁这批比特币。

00:05:29,220 --> 00:05:38,760
你需要输入解锁代码或者使用你的私钥

00:05:38,760 --> 00:05:44,940
来证明你可以解锁这批比特币。

00:05:44,940 --> 00:05:47,010
前半部分就完成了，

00:05:47,010 --> 00:05:54,630
即选择并解锁了比特币。

00:05:54,630 --> 00:05:57,240
你将在交易的后半部分放入新的锁，

00:05:54,630 --> 00:06:04,800
这就是锁定给我们的比特币，

00:06:04,800 --> 00:06:07,440
在这个交易中我们将从中创建一批新的比特币，

00:06:07,440 --> 00:06:10,530
并在上面放了一个新的锁。

00:06:10,530 --> 00:06:14,649
这个新锁是锁定给接收人的地址的，

00:06:14,649 --> 00:06:17,349
就像是一个账户号码一样。

00:06:17,349 --> 00:06:21,519
这是一个非常简单的交易过程。

00:06:21,519 --> 00:06:23,979
你只需选择一些比特币，

00:06:23,979 --> 00:06:26,709
用私钥解锁它们，再创建一个新的交易，

00:06:26,709 --> 00:06:29,109
再为这些比特币设置一个新的锁，

00:06:29,109 --> 00:06:34,299
并将它们锁定给接收人。

00:06:34,299 --> 00:06:37,209
当你想要进行交易时，

00:06:37,209 --> 00:06:39,069
最好不要将其视为真正拥有一些比特币，

00:06:39,069 --> 00:06:40,719
然后通过互联网直接转给别人，

00:06:40,719 --> 00:06:41,979
因为这并不是真正的交易方式。

00:06:41,979 --> 00:06:44,559
实际上你拥有一组密钥，

00:06:44,559 --> 00:06:47,349
密钥包括地址和私钥。

00:06:47,349 --> 00:06:49,719
接收方也有他们自己的地址和私钥。

00:06:49,719 --> 00:06:53,979
当你想要向他们发送比特币时，

00:06:51,729 --> 00:06:53,979
你只需通过区块链，

00:06:53,979 --> 00:06:58,419
选择那些能用你的私钥解锁的比特币，

00:06:58,419 --> 00:07:06,099
然后创建一批新的比特币锁定到接收方的地址上，

00:07:06,099 --> 00:07:12,129
这样他们就可以使用他们的私钥来解锁这些比特币。

00:07:12,129 --> 00:07:13,449
在这之后，

00:07:13,449 --> 00:07:15,069
如果他们想要将这些比特币发送给其他人，

00:07:15,069 --> 00:07:16,689
他们只需使用他们的私钥解锁你为他们设置的特定锁，

00:07:16,689 --> 00:07:18,339
然后就可以进行转账了。

00:07:18,339 --> 00:07:26,469
因此你可以看到比特币交易形成了一个交易链，

00:07:26,469 --> 00:07:31,569
从一个人传递到另一个人。

00:07:31,569 --> 00:07:33,999
到目前为止，

00:07:33,999 --> 00:07:36,459
我一直将这些比特币的集合称为批次，

00:07:36,459 --> 00:07:37,929
但它们的技术术语称为输出。

00:07:37,929 --> 00:07:40,569
所以从现在开始，

00:07:40,569 --> 00:07:43,329
我将使用“输出”这个词来描述这些比特币批次。

00:07:43,329 --> 00:07:45,159
所有这些被锁定的比特币批次都被称为输出，

00:07:45,159 --> 00:07:48,639
这就是这些橙色框框里的内容。

00:07:48,639 --> 00:07:54,879
但需要明确的是，

00:07:54,879 --> 00:07:57,239
当我们在交易中消费一个输出时，

00:07:57,239 --> 00:08:00,609
我们称之为输入。

00:08:00,609 --> 00:08:10,110
因此每笔交易都会接受输入并创建新的输出。

00:08:10,110 --> 00:08:12,300
然后我们将这笔交易发送到比特币网络，

00:08:12,300 --> 00:08:15,509
希望它能被添加到区块链中的新区块中。

00:08:15,509 --> 00:08:17,190
假设这是一个新的交易区块，

00:08:17,190 --> 00:08:20,910
那么我们的交易就被记录在区块链上了。

00:08:20,910 --> 00:08:23,400
如果我们将刚刚完成的交易可视化，

00:08:23,400 --> 00:08:28,139
我们能看到已经花费了这个输出，

00:08:28,139 --> 00:08:29,699
因此我将其标记为灰色，

00:08:29,699 --> 00:08:31,470
表示它不能再被使用。

00:08:31,470 --> 00:08:35,250
在这个新的区块中，

00:08:35,250 --> 00:08:37,380
由于我的交易，

00:08:37,380 --> 00:08:41,070
我生成了一个新的输出，

00:08:41,070 --> 00:08:42,750
这个新的输出属于接收方。

00:08:42,750 --> 00:08:49,470
这就是交易在基本层面上的工作原理。

00:08:49,470 --> 00:08:51,420
在上一个例子中，

00:08:51,420 --> 00:08:57,060
我发送了整批比特币，

00:08:57,060 --> 00:08:59,490
并且设定了十个比特币作为我要发送的金额。

00:08:59,490 --> 00:09:02,250
但实际上你并不需要总是发送整批的比特币，

00:09:02,250 --> 00:09:04,920
如果你想发送的金额少于十个比特币，

00:09:04,920 --> 00:09:06,839
那么你可以这么做：

00:09:06,839 --> 00:09:11,459
你可以创建一个输出，

00:09:11,459 --> 00:09:14,580
向某人发送8个比特币，

00:09:14,580 --> 00:09:17,339
显然这样会有2个比特币剩余，

00:09:17,339 --> 00:09:19,650
因此你需要为自己创建一个找零的输出。

00:09:19,650 --> 00:09:24,570
我们已经使用了一个输入，

00:09:24,570 --> 00:09:27,779
创建了一个8比特币的输出，

00:09:27,779 --> 00:09:30,089
这个输出发送给了接收方，

00:09:30,089 --> 00:09:32,130
然后我们处理剩余的找零部分，

00:09:32,130 --> 00:09:34,350
将其锁定到我们自己的地址上。

00:09:34,350 --> 00:09:39,959
这就是你处理找零的方式，

00:09:39,959 --> 00:09:41,070
当你进行交易时，

00:09:41,070 --> 00:09:47,850
基本上是你自己为自己找零。

00:09:47,850 --> 00:09:49,770
到目前为止，

00:09:49,770 --> 00:09:51,990
我一直在使用整数比特币作为例子，

00:09:51,990 --> 00:09:55,380
但实际上比特币可以被分割成非常小的单位。

00:09:55,380 --> 00:09:57,360
例如，

00:09:57,360 --> 00:09:59,190
我可以发送一笔非常小的金额，

00:09:59,190 --> 00:10:01,290
并将剩余的部分作为找零返还给自己。

00:10:01,290 --> 00:10:05,130
这在比特币系统中是完全可行的，

00:10:05,130 --> 00:10:08,370
没有任何实质性的限制，

00:10:08,370 --> 00:10:11,459
也没有关于分割比特币的限制。

00:10:11,459 --> 00:10:14,010
比特币的最小单位被称为“Satoshi”，

00:10:14,010 --> 00:10:17,040
它等于比特币的十亿分之一。

00:10:17,040 --> 00:10:18,110
这就是你能将比特币分割的最小程度，

00:10:18,110 --> 00:10:20,060
无法再细分。

00:10:20,060 --> 00:10:22,090
同样，

00:10:23,500 --> 00:10:27,350
假设你拥有10个比特币，

00:10:27,350 --> 00:10:29,570
你想向某人发送30个比特币。

00:10:29,570 --> 00:10:35,810
如果你有两批或更多的不同的批次比特币输出为你所用，

00:10:35,810 --> 00:10:42,050
你可以将它们合并作为一笔交易的输入，

00:10:42,050 --> 00:10:45,260
来创建一个更大的输出，

00:10:45,260 --> 00:10:47,120
而不是分开进行两次交易。

00:10:47,120 --> 00:10:54,620
只要你有密钥解锁这些比特币，

00:10:54,620 --> 00:10:59,450
就可以从区块链中选择任意数量的输入来进行你的交易。

00:10:59,450 --> 00:11:03,320
再次以10个和25个比特币为例，

00:11:03,320 --> 00:11:05,450
我想向某人发送30个比特币，

00:11:05,450 --> 00:11:08,330
所以在这笔交易中显然会有5个比特币的剩余。

00:11:08,330 --> 00:11:10,310
这个剩余5个比特币需要作为找零处理，

00:11:10,310 --> 00:11:12,200
归还给自己。

00:11:12,200 --> 00:11:14,840
正如我之前提到的，

00:11:14,840 --> 00:11:16,820
每一笔交易都需要处理自己的找零。

00:11:16,820 --> 00:11:22,520
当这笔交易被记录到区块链上时，

00:11:22,520 --> 00:11:24,200
会有一个30比特币的输出，

00:11:24,200 --> 00:11:27,080
锁定给接收人，

00:11:27,080 --> 00:11:29,210
同时还会有一个5个比特币的输出，

00:11:29,210 --> 00:11:32,480
锁定给发送人自己。

00:11:32,480 --> 00:11:34,310
而我们从区块链中选择的这两个输入

00:11:34,310 --> 00:11:37,400
在这笔交易后就会被标记为已花费，

00:11:37,400 --> 00:11:39,020
因为它们已经被用掉了。

00:11:39,020 --> 00:11:47,960
这就是比特币在区块链中的交易方式和工作原理。

00:11:47,960 --> 00:11:51,380
所以，

00:11:51,380 --> 00:11:53,810
你在最后一张幻灯片中说，

00:11:53,810 --> 00:12:00,560
你提到一笔交易可以有多个输入，是吗？

00:12:00,560 --> 00:12:04,250
你可以有任意多的输入，

00:12:04,250 --> 00:12:06,680
并创建一些输出。

00:12:06,680 --> 00:12:08,870
这些输入都必须是你自己的，是这样吗？

00:12:08,870 --> 00:12:11,510
是的，只要你能解锁它们就行。

00:12:11,510 --> 00:12:13,130
我想说的是，

00:12:13,130 --> 00:12:14,210
只要它们是你的，

00:12:14,210 --> 00:12:16,010
且你拥有解锁这些输入的密钥，

00:12:16,010 --> 00:12:18,350
那就没问题，我们就可以认为这些输入是你的。

00:12:18,350 --> 00:12:26,050
因此你可以将别人转给你的多个交易作为输入。

00:12:26,050 --> 00:12:28,250
例如，

00:12:28,250 --> 00:12:31,340
如果有三个人各自给了我5美元，

00:12:31,340 --> 00:12:35,060
而我想支付给某人14美元，

00:12:35,060 --> 00:12:38,480
我可以将这三个交易合一起作为输入，

00:12:38,480 --> 00:12:42,530
创建一个14美元的输出给对方，

00:12:42,530 --> 00:12:51,740
再创建一个1美元的输出退还给我自己。

00:12:51,740 --> 00:12:59,180
这里我仅展示了一个独立的交易案例。

00:12:59,180 --> 00:13:01,630
如果你回溯历史，

00:13:01,630 --> 00:13:07,580
可视化所有随着时间被添加到区块链上的交易，

00:13:07,580 --> 00:13:11,420
你会看到这是第一笔交易，

00:13:11,420 --> 00:13:16,730
然后有另一笔交易消费了这个输出，

00:13:16,730 --> 00:13:18,770
接着又有一个区块中的交易，

00:13:18,770 --> 00:13:25,220
每笔交易都会使用之前的输出，

00:13:25,220 --> 00:13:28,370
如此循环往复，

00:13:28,370 --> 00:13:31,130
每一笔新的交易都在构建了这种图形结构。

00:13:31,130 --> 00:13:32,930
所以，

00:13:32,930 --> 00:13:35,540
正如你所问的，

00:13:35,540 --> 00:13:38,150
你确实可以从不同的交易中提取不同的输出，

00:13:38,150 --> 00:13:42,580
将它们组合在一起，形成一个新的单独交易。

00:13:42,580 --> 00:13:44,510
然而如你所见，

00:13:44,510 --> 00:13:47,030
每笔交易都是相互关联的，

00:13:47,030 --> 00:13:50,030
它们形成了一个直接的输出链，

00:13:50,030 --> 00:13:55,640
包括输入和输出等。

00:13:55,640 --> 00:13:57,530
因此当你执行比特币交易时，

00:13:57,530 --> 00:14:02,330
你只需要从区块链网络中选择任何未被使用的输出，

00:14:02,330 --> 00:14:04,610
然后基于这些输出创建新的输出。

00:14:04,610 --> 00:14:07,850
这样的一对一连接，

00:14:07,850 --> 00:14:12,290
一笔接一笔的交易，

00:14:12,290 --> 00:14:15,110
就对比特币交易网络产生这样的影响，

00:14:15,110 --> 00:14:20,810
就像这样的比特币交易图。

00:14:20,810 --> 00:14:25,580
这样的比特币交易网络图是理解区块链的一个很好的方式。

00:14:25,580 --> 00:14:26,990
我意思是，你可以将其想象为独立的输出，

00:14:26,990 --> 00:14:32,300
但实际上，这些输出是通过一系列交易相互连接的。

00:14:32,300 --> 00:14:35,060
区块链看起来就像这样的，

00:14:35,060 --> 00:14:39,220
当然实际上要复杂庞大得多。

00:14:40,910 --> 00:14:43,800
这些橙色的输出尚未被使用，

00:14:43,800 --> 00:14:46,079
因此它们被称为未花费的交易输出，

00:14:46,079 --> 00:14:49,230
或者被称为UTXO。

00:14:49,230 --> 00:14:54,839
所以当你看到UTXO这个术语时，

00:14:54,839 --> 00:14:57,170
它指的就是这些未被使用的比特币。

00:14:57,170 --> 00:15:00,120
这些UTXO非常重要，

00:15:00,120 --> 00:15:07,199
因为它们通常被比特币客户端保存在RAM中，

00:15:07,199 --> 00:15:16,019
以便可以快速访问。

00:15:16,019 --> 00:15:19,709
到目前为止，

00:15:19,709 --> 00:15:21,300
我一直在引用这些原始的交易。

00:15:21,300 --> 00:15:23,850
那么最初的比特币是如何产生的呢？

00:15:23,850 --> 00:15:31,829
每当一个新的区块被挖掘出来并加入到区块链中时，

00:15:31,829 --> 00:15:39,510
就会产生一定数量的新比特币，

00:15:39,510 --> 00:15:41,399
这就是所谓的区块奖励。

00:15:41,399 --> 00:15:44,730
当矿工成功挖掘到一个区块时，

00:15:44,730 --> 00:15:48,110
他们会通过区块奖励创建一个输出，

00:15:48,110 --> 00:15:50,399
并将其锁定到自己的地址上。

00:15:50,399 --> 00:15:56,760
他们是如何做到这一点的呢？

00:15:56,760 --> 00:16:00,269
在每个区块中，

00:16:00,269 --> 00:16:02,579
矿工会构建多个交易块，

00:16:02,579 --> 00:16:04,170
但在这些交易的最顶端，

00:16:04,170 --> 00:16:06,480
有一个特殊的交易，

00:16:06,480 --> 00:16:08,339
就是所谓的coinbase交易，

00:16:08,339 --> 00:16:11,160
这是矿工的专有交易。

00:16:11,160 --> 00:16:12,480
通过coinbase交易，

00:16:12,480 --> 00:16:14,760
矿工可以领取区块奖励。

00:16:14,760 --> 00:16:18,000
正如我所提到的，

00:16:18,000 --> 00:16:19,610
每当一个新区块被挖出，

00:16:19,610 --> 00:16:25,170
就会生成一些之前不存在的新比特币。

00:16:25,170 --> 00:16:27,350
那么，

00:16:27,690 --> 00:16:36,030
比特币交易树的第一层只包含coinbase交易吗？

00:16:36,030 --> 00:16:40,800
是的，

00:16:40,800 --> 00:16:47,340
第一层仅包含coinbase交易，

00:16:47,340 --> 00:17:01,500
而coinbase交易本身就是这棵树的根。

00:17:01,500 --> 00:17:06,540
正如你在这个图表上看到，

00:17:06,540 --> 00:17:14,490
所有这些交易都有一个源头，

00:17:14,490 --> 00:17:18,569
都源自区块奖励。

00:17:18,569 --> 00:17:27,200
在这个简要介绍的最后，

00:17:27,200 --> 00:17:32,010
你可能对交易费用的工作原理感兴趣。

00:17:32,010 --> 00:17:36,660
当你发起一笔交易时，

00:17:36,660 --> 00:17:44,190
你想支付手续费，

00:17:44,190 --> 00:17:50,970
你通常不会花掉交易输入中的全部金额。

00:17:48,930 --> 00:17:50,970
例如如果你有10个比特币作为输入，

00:17:50,970 --> 00:17:53,760
而你创建了一个8个比特币的输出，

00:17:53,760 --> 00:17:55,770
那么你就已经使用了全部金额。

00:17:55,770 --> 00:17:57,840
但是如果你没有使用掉所有的输入金额，

00:17:57,840 --> 00:18:02,850
而是把剩余的部分自动地作为手续费。

00:18:02,850 --> 00:18:05,130
因此，

00:18:05,130 --> 00:18:07,380
当你想在交易中支付手续费时，

00:18:07,380 --> 00:18:09,450
你无需为其创建一个独立的输出，

00:18:09,450 --> 00:18:13,710
只需留下一部分未使用的输入即可。

00:18:13,710 --> 00:18:16,830
例如，

00:18:16,830 --> 00:18:18,720
如果一笔交易的手续费设定为0.1比特币，

00:18:18,720 --> 00:18:21,029
当我们将其广播到网络时，

00:18:21,029 --> 00:18:27,779
这笔交易会被加入到网络中所有节点的内存池中。

00:18:27,779 --> 00:18:30,690
之所以需要在交易中支付手续费，

00:18:30,690 --> 00:18:33,210
是因为矿工在创建新的候选区块时，

00:18:33,210 --> 00:18:34,799
只能包含有限数量或大小的交易。

00:18:34,799 --> 00:18:38,730
过去，

00:18:38,730 --> 00:18:42,600
这个限制基本上是1MB大小的交易，

00:18:42,600 --> 00:18:45,059
而现在这个限制已经转变为以“权重”计量，

00:18:45,059 --> 00:18:48,390
大致相当于1.7MB的交易数据。

00:18:48,390 --> 00:18:49,799
因此，

00:18:49,799 --> 00:18:52,500
当内存池中的交易总量超过1.7MB时，

00:18:52,500 --> 00:18:54,240
矿工会优先选择

00:18:54,240 --> 00:18:58,559
那些提供更高手续费的交易进行打包。

00:18:58,559 --> 00:19:00,140
他们这么做的原因是，

00:19:00,140 --> 00:19:04,200
矿工可以收取这些交易的手续费。

00:19:04,200 --> 00:19:09,720
假设这些黄色的小圆盘代表高手续费的交易，

00:19:09,720 --> 00:19:11,820
矿工可以选择这些交易，

00:19:11,820 --> 00:19:14,520
并将它们的手续费收入自己的口袋，

00:19:14,520 --> 00:19:16,770
即放入coinbase交易中。

00:19:16,770 --> 00:19:19,620
因此，

00:19:19,620 --> 00:19:21,600
矿工在coinbase交易中

00:19:21,600 --> 00:19:26,690
不仅会给自己发送当前的区块奖励（目前为12.5比特币），

00:19:26,690 --> 00:19:34,919
还会包含他们所打包交易的所有手续费。

00:19:34,919 --> 00:19:37,980
当这个区块被成功挖出后，

00:19:37,980 --> 00:19:40,230
coinbase交易就会回收所有的手续费，

00:19:40,230 --> 00:19:42,210
并且创建一批新的比特币，

00:19:42,210 --> 00:19:45,260
这批新比特币包括了区块奖励。

00:19:45,260 --> 00:19:48,720
这样解释是否清楚了呢？

00:19:48,720 --> 00:19:52,950
那么我们已经讲解了所有基础知识，

00:19:52,950 --> 00:19:54,840
包括交易的结构，

00:19:54,840 --> 00:19:58,200
以及如何通过输入来创建输出的直观表示。

00:19:58,200 --> 00:20:04,710
接下来，我要讲解的内容是关于数据，

00:20:04,710 --> 00:20:08,190
如果我们查看内部数据，

00:20:08,190 --> 00:20:15,530
你如何从数据本身构建自己的交易。

00:20:15,530 --> 00:20:17,450
这部分内容会有点技术性，

00:20:17,450 --> 00:20:21,680
如果你不是技术人员，

00:20:21,680 --> 00:20:25,550
这些应该能够满足你对交易内部机制的兴趣，

00:20:25,550 --> 00:20:30,440
这更适合编程和其他相关的东西。

00:20:30,440 --> 00:20:36,440
从之前的图表中我们可以看到，

00:20:36,440 --> 00:20:38,540
我用绿线表示了数据，

00:20:38,540 --> 00:20:40,460
而这个黑色的框架就好比我的代码编辑器。

00:20:40,460 --> 00:20:44,150
我们将从头开始创建一个交易。

00:20:44,150 --> 00:20:46,100
每笔交易都是以一个版本号开头的，

00:20:46,100 --> 00:20:49,070
这个版本号定义了交易结构的格式。

00:20:49,070 --> 00:20:52,580
目前版本号通常是1，

00:20:52,580 --> 00:20:57,560
我相信大多数交易都采用的是版本号1。

00:20:54,590 --> 00:20:57,560
因此我们在这里输入1，

00:20:57,560 --> 00:20:59,180
这是没有问题的。

00:20:59,180 --> 00:21:06,650
但是由于这是交易数据，

00:21:06,650 --> 00:21:10,130
它具有特定的结构，

00:21:10,130 --> 00:21:14,450
所以这个版本号应该是四个字节的长度。

00:21:14,450 --> 00:21:16,520
我们在这里输入1，

00:21:16,520 --> 00:21:17,690
但我们需要用零来填充它，

00:21:17,690 --> 00:21:19,250
以确保它的长度是四个字节。

00:21:19,250 --> 00:21:22,550
每两个字符代表一个字节，

00:21:22,550 --> 00:21:25,010
所以这里应该是八个字符的长度，

00:21:25,010 --> 00:21:28,220
即四个字节。

00:21:28,220 --> 00:21:32,510
之所以有这样的字段大小，

00:21:30,530 --> 00:21:36,980
是因为交易中的每个元素都有自己的字段大小，

00:21:36,980 --> 00:21:43,580
这样可以使得解码交易变得更加简单。

00:21:43,580 --> 00:21:45,050
其次，除了长度是四个字节之外，

00:21:45,050 --> 00:21:48,110
它还必须是十六进制表示的。

00:21:48,110 --> 00:21:49,340
这里的计数是1，在十六进制中也表示为1。

00:21:49,340 --> 00:21:53,570
最后，可能是最让人困惑的一点是，

00:21:53,570 --> 00:21:56,390
从我们人类的角度来看，

00:21:56,390 --> 00:22:00,890
这些数据必须采用网络字节顺序，

00:22:00,890 --> 00:22:03,670
也就是你需要反转字节的顺序。

00:22:05,479 --> 00:22:07,519
这就是第一部分。第二部分

00:22:07,519 --> 00:22:12,889
你需要指定交易中要使用的输入数量。

00:22:12,889 --> 00:22:16,190
假设你有三个输入，

00:22:16,190 --> 00:22:18,320
我们这就有三个，

00:22:18,320 --> 00:22:21,349
但在这个例子中，我们只会使用一个输出，

00:22:21,349 --> 00:22:22,849
因此我在这里输入的是1，

00:22:22,849 --> 00:22:24,769
占用一个字节。

00:22:24,769 --> 00:22:31,209
这里有一个特殊的字段，

00:22:31,209 --> 00:22:41,749
叫做varint字段，

00:22:41,749 --> 00:22:48,729
有时也被称为紧凑大小（compact size）。

00:22:48,729 --> 00:22:51,979
可变整数和变量是我习惯使用的。

00:22:51,979 --> 00:22:55,909
如果你要选择的输出数量小于252，

00:22:55,909 --> 00:23:02,149
或者用十六进制表示就是FC，

00:23:02,149 --> 00:23:04,159
那么你只需要一个字节，

00:23:04,159 --> 00:23:07,789
所以可以直接写在这里。

00:23:07,789 --> 00:23:12,169
如果你想发送超过252个输入，

00:23:12,169 --> 00:23:14,599
那么，

00:23:14,599 --> 00:23:17,389
你需要在前面加上FD标识，

00:23:17,389 --> 00:23:20,989
并在其后用两个字节以十六进制形式，

00:23:20,989 --> 00:23:27,859
表示你使用了多少个输入。

00:23:27,859 --> 00:23:29,959
同样地，如果你需要的数字超过两个字节能表示的范围，

00:23:29,959 --> 00:23:31,669
你就在前面加上FE，

00:23:31,669 --> 00:23:33,649
这意味着接下来的四个字节会告诉你输入的具体数量。

00:23:33,649 --> 00:23:36,649
如果这个数字甚至比四个字节还要大，

00:23:36,649 --> 00:23:38,329
那么你就在前面加上FF，

00:23:38,329 --> 00:23:45,019
随后的八个字节将告诉你你想要使用的输入数量。

00:23:45,019 --> 00:23:49,429
但对于大多数交易来说，

00:23:49,429 --> 00:23:55,999
你不太可能会用到这么多输入，

00:23:55,999 --> 00:24:01,380
如果你是自己构建交易的话，

00:24:01,380 --> 00:24:03,299
你可能只会用到一个字节，

00:24:03,299 --> 00:24:05,250
因此大多数情况下，

00:24:05,250 --> 00:24:08,900
这个输入字段的大小仅为一个字节。

00:24:08,960 --> 00:24:12,690
好的，

00:24:12,690 --> 00:24:14,850
这可能是最具技术性的部分，

00:24:14,850 --> 00:24:16,110
现在我们继续输入，

00:24:16,110 --> 00:24:21,360
这个步骤相对简单一些。

00:24:21,360 --> 00:24:24,059
我们需要从区块链中选择一个交易作为输入，

00:24:24,059 --> 00:24:26,610
这就需要我们获取该交易的ID号。

00:24:26,610 --> 00:24:29,429
每个交易都有一个唯一的ID号，

00:24:29,429 --> 00:24:32,460
称为交易ID，

00:24:32,460 --> 00:24:38,390
你只需要把它放在输入代码的第一部分就可以选择它，

00:24:38,390 --> 00:24:44,880
这个ID是一个32字节长的十六进制数，

00:24:44,880 --> 00:24:47,070
按照网络字节顺序排列，

00:24:47,070 --> 00:24:49,830
因此在使用前需要将其字节序反转。

00:24:49,830 --> 00:24:52,260
你可以将这个ID输入到区块链浏览器中，

00:24:52,260 --> 00:24:54,419
由于它已经是反转后的形式，

00:24:54,419 --> 00:24:56,909
因为它已经被反转了。

00:24:56,909 --> 00:25:01,289
你可以很容易地找到对应的交易。

00:25:01,289 --> 00:25:05,010
我们需要选择交易中的一个特定输出，

00:25:05,010 --> 00:25:11,669
正如我之前展示的，

00:25:11,669 --> 00:25:12,780
一笔交易可以有多个输出。

00:25:12,780 --> 00:25:15,570
你需要做的是使用Vout，

00:25:15,570 --> 00:25:19,559
这是输出向量的简称，

00:25:19,559 --> 00:25:21,780
每个输出都有一个从0开始的索引号。

00:25:21,780 --> 00:25:24,360
如果交易只有一个输出，

00:25:24,360 --> 00:25:27,450
我在这里输入0，

00:25:27,450 --> 00:25:30,110
这个索引号也是一个4字节长的十六进制数。

00:25:30,110 --> 00:25:34,100
输入后，我们就完成了输入部分的主要内容。

00:25:34,580 --> 00:25:38,280
接下来是下一个主要部分，

00:25:38,280 --> 00:25:41,340
基本上我们已经确认了。

00:25:41,340 --> 00:25:44,630
好的，快速提一个问题：

00:25:44,630 --> 00:25:48,690
假设我们有多个交易，

00:25:48,690 --> 00:25:51,150
每个交易都有多个输出，

00:25:51,150 --> 00:25:54,030
那是可能的，对吧？

00:25:54,030 --> 00:25:57,360
比如说，我们有两笔交易，

00:25:57,360 --> 00:25:59,850
每笔交易都有两个输出。

00:25:59,850 --> 00:26:04,230
在01那里，

00:26:04,230 --> 00:26:11,490
会变成04。

00:26:11,490 --> 00:26:14,130
在填写输入字段时，

00:26:14,130 --> 00:26:17,280
前一个输入的输入计数将变为04？

00:26:17,280 --> 00:26:20,030
将会是02，你是所有交易的输入数量吗？

00:26:20,030 --> 00:26:24,630
是的，是的，是的，

00:26:24,630 --> 00:26:27,780
然后我们会列出所有的交易ID，

00:26:27,780 --> 00:26:30,240
这些ID会一个接一个地排列。

00:26:30,240 --> 00:26:30,630
好的，

00:26:30,630 --> 00:26:32,610
如果你想选择两个不同的输出，

00:26:32,610 --> 00:26:37,700
这段代码就是为了选择单个输出。

00:26:37,700 --> 00:26:40,350
就是这个，

00:26:40,350 --> 00:26:42,840
如果你需要两个输出，

00:26:42,840 --> 00:26:49,770
你只需在这段代码之后重复相同的步骤。

00:26:49,770 --> 00:26:51,659
那么我们在这里，

00:26:51,659 --> 00:26:53,460
已经成功地选择了这个特定的输出，

00:26:53,460 --> 00:26:54,480
通过交易ID可以找到这个交易，

00:26:54,480 --> 00:26:56,309
查看特定的Vout，

00:26:56,309 --> 00:27:00,900
以便成功引用了这个输出，

00:27:00,900 --> 00:27:02,909
但显然它是有锁的。

00:27:02,909 --> 00:27:05,580
为了能够使用比特币并将其转发给他人，

00:27:05,580 --> 00:27:07,140
你必须先解锁它。

00:27:07,140 --> 00:27:10,890
在比特币交易中，

00:27:10,890 --> 00:27:15,360
你需要构建完整的交易结构才能解锁比特币。

00:27:15,360 --> 00:27:18,510
在解锁之前，你无法执行交易。

00:27:18,510 --> 00:27:19,950
现在我们不讨论这个环节。

00:27:19,950 --> 00:27:24,360
解锁所需的代码被称为脚本签名，

00:27:24,360 --> 00:27:28,770
这里的签名以及相关的所有代码都被称作脚本，

00:27:28,770 --> 00:27:30,270
因为它们有自己的脚本语言。

00:27:30,270 --> 00:27:33,720
所以被称作脚本签名，

00:27:33,720 --> 00:27:35,010
你可以为它取一个更易懂的名字，

00:27:35,010 --> 00:27:39,600
你可以称之为解锁代码。

00:27:39,600 --> 00:27:44,100
每个交易输入都有一个序列号，

00:27:44,100 --> 00:27:46,470
这个序列号并不经常被使用。

00:27:46,470 --> 00:27:52,679
如果我将这个序列号设置为一个小于最大可能值的数字，

00:27:52,679 --> 00:27:58,169
那么在未来就有可能替换这笔交易。

00:27:58,169 --> 00:28:00,330
例如，

00:28:00,330 --> 00:28:02,130
如果你在一个交易中设置了很低的手续费，

00:28:02,130 --> 00:28:04,740
你可以创建一个新的交易，

00:28:04,740 --> 00:28:06,200
这个新交易具有更高的序列号，

00:28:06,200 --> 00:28:10,080
从而能够替代已经在网络中的那笔交易。

00:28:10,080 --> 00:28:13,770
我通常会把这个序列号设置为最大的十六进制值，

00:28:13,770 --> 00:28:17,580
我会这样做。

00:28:17,580 --> 00:28:21,370
从这里开始，

00:28:21,370 --> 00:28:24,350
我通常会将这个设置为全是F，

00:28:24,350 --> 00:28:25,850
如果你需要选择另一个输入，

00:28:25,850 --> 00:28:29,660
只需在这段代码后重复相同的过程即可，

00:28:29,660 --> 00:28:34,990
这样可以快速完成解析。

00:28:34,990 --> 00:28:37,400
接下来，

00:28:37,400 --> 00:28:38,930
我们完成了输入，

00:28:38,930 --> 00:28:42,560
现在要创建一些输出。

00:28:42,560 --> 00:28:44,330
输出的数量是一个可变的整数，

00:28:44,330 --> 00:28:48,500
如果你想创建超过252个输出，

00:28:48,500 --> 00:28:50,540
你只需使用可用的可变整数代码。

00:28:50,540 --> 00:28:52,430
但由于我这里只创建了两个输出，

00:28:52,430 --> 00:28:55,270
所以可以简单地使用一个字节来表示。

00:28:55,270 --> 00:28:57,680
我之前没说，是想要在数据传输中节省空间，

00:28:57,680 --> 00:29:01,400
以便更高效地利用数据。

00:29:01,400 --> 00:29:08,840
在处理数据以确保输出结构良好时，

00:29:08,840 --> 00:29:11,030
首先你需要输入你想要发送的比特币数量。

00:29:11,030 --> 00:29:13,490
但是你输入的不是比特币的数量，

00:29:13,490 --> 00:29:14,780
而是输入Satoshi的数量。

00:29:14,780 --> 00:29:18,740
比如说，我想要发送大约0.02个比特币。

00:29:18,740 --> 00:29:20,300
你必须把它转换成Satoshi，

00:29:20,300 --> 00:29:26,570
因为Satoshi是比特币的最小单位。

00:29:26,570 --> 00:29:28,880
这段输出的第一部分，

00:29:28,880 --> 00:29:31,220
必须是一个有效的十进制数值，

00:29:31,220 --> 00:29:32,960
并且长度为8个字节。

00:29:32,960 --> 00:29:36,500
由于这些字节是以反向字节排列的，

00:29:36,500 --> 00:29:41,630
所以在阅读代码时可能看起来像是乱码。

00:29:41,630 --> 00:29:43,730
但如果你把字节顺序反过来，

00:29:43,730 --> 00:29:47,000
并将其转换成十进制数，它就会显示出实际的数值。

00:29:47,000 --> 00:29:50,210
在这之后，

00:29:50,210 --> 00:29:53,150
你提到了这个8字节长度的数字，

00:29:53,150 --> 00:29:55,100
这让我想到可能存在一定的限制，

00:29:55,100 --> 00:29:58,880
即你在一次交易中能够发送的最大数额。

00:29:58,880 --> 00:30:01,700
这个交易数额是用8字节的十六进制表示的，

00:30:01,700 --> 00:30:03,470
我认为这是一个极大的数值。

00:30:03,470 --> 00:30:06,440
应该足以覆盖大多数情况。

00:30:06,440 --> 00:30:09,470
我感觉，

00:30:09,470 --> 00:30:13,460
如果真的遇到问题，

00:30:13,460 --> 00:30:16,060
那将是一个需要解决的大难题。

00:30:17,500 --> 00:30:22,730
在设定了金额之后，

00:30:22,730 --> 00:30:27,280
下一步就是对其进行加密锁定。

00:30:27,280 --> 00:30:30,440
锁定机制有自己的脚本语言，

00:30:30,440 --> 00:30:32,240
其大小是可变的。

00:30:32,240 --> 00:30:36,159
由于锁定脚本的大小是可变的，

00:30:34,450 --> 00:30:38,980
它们并没有像交易ID或版本号那样的固定大小，

00:30:38,980 --> 00:30:42,330
因此我们必须使用可变整数来表示。

00:30:42,330 --> 00:30:50,679
大多数签名的长度大约是19到25字节，

00:30:50,679 --> 00:30:53,619
这个长度仅仅是为了告知接下来的锁定脚本的大小。

00:30:53,619 --> 00:30:58,869
然后你将锁定脚本放在相应的位置。

00:30:58,869 --> 00:31:00,759
这里包含了一些代码，

00:31:00,759 --> 00:31:04,720
用于创建一个脚本，

00:31:04,720 --> 00:31:06,639
将交易锁定到一个特定的地址。

00:31:06,639 --> 00:31:10,359
这是我们锁定的地址，

00:31:10,359 --> 00:31:13,269
我们在这里使用了公钥，

00:31:13,269 --> 00:31:16,869
但现在我不打算深入探讨这部分内容，

00:31:16,869 --> 00:31:22,029
只是说明这些代码与特定地址是相对应的。

00:31:22,029 --> 00:31:28,359
这些灰色的部分实际上是锁定脚本，

00:31:28,359 --> 00:31:31,090
它们将资金锁定到特定的公钥。

00:31:31,090 --> 00:31:32,769
如果你想设置自己的锁，

00:31:32,769 --> 00:31:36,190
你可以复制这段，

00:31:36,190 --> 00:31:41,830
并用你想要发送给的人的公钥来替换现有的公钥。

00:31:41,830 --> 00:31:48,999
这个公钥是可以从相应的地址中派生出来的。

00:31:48,999 --> 00:31:51,129
因此对于不同的公钥，

00:31:51,129 --> 00:31:54,059
锁定脚本自然会有所不同。

00:31:54,059 --> 00:31:57,429
在一笔典型的交易中，

00:31:57,429 --> 00:31:59,639
这段7609编码会改变的只是这里的绿色部分，

00:31:59,639 --> 00:32:05,799
这里的76a914和88ac是脚本中的特定指令代码。

00:32:05,799 --> 00:32:07,600
简单来说，当这个地址已经存在时，

00:32:07,600 --> 00:32:12,100
这个输出被锁定到这个公钥，

00:32:12,100 --> 00:32:20,799
任何想要发送资金的人都必须提供一个匹配的签名。

00:32:20,799 --> 00:32:25,559
这就是将要执行的脚本，

00:32:25,559 --> 00:32:27,909
你知道的，

00:32:27,909 --> 00:32:32,769
你把它放在堆栈上，

00:32:32,769 --> 00:32:34,570
检查是否匹配。

00:32:34,570 --> 00:32:37,509
这些操作码，

00:32:37,509 --> 00:32:39,249
包括OP_DUP等，

00:32:39,249 --> 00:32:42,279
我在这里没有详细说明，

00:32:42,279 --> 00:32:44,450
我觉得签名脚本和操作码值得我在后面单独解释。

00:32:44,450 --> 00:32:48,379
这是锁定脚本的部分，

00:32:48,379 --> 00:32:50,960
我不期望你现在就完全理解它。

00:32:50,960 --> 00:32:55,669
正如你之前提到的，

00:32:55,669 --> 00:32:58,580
因为我提到了两个输出，

00:32:58,580 --> 00:33:03,980
所以我在这里创建了另一个输出，

00:33:03,980 --> 00:33:06,320
其结构与之前的相同。

00:33:06,320 --> 00:33:08,419
这部分指定了我发送的金额，

00:33:08,419 --> 00:33:11,389
接着是即将出现的锁定代码的大小，

00:33:11,389 --> 00:33:16,190
这是具有不同地址的锁定代码。

00:33:16,190 --> 00:33:18,230
你可以看到这以88ac结尾，

00:33:18,230 --> 00:33:20,359
就像那个一样，

00:33:20,359 --> 00:33:24,859
它以76a9开始。

00:33:24,859 --> 00:33:25,009
所以，

00:33:25,009 --> 00:33:32,239
我们在这里改变的仅仅是我要锁定的目标地址。

00:33:32,239 --> 00:33:33,950
最后，

00:33:33,950 --> 00:33:35,809
我要讲的是时间锁，

00:33:35,809 --> 00:33:38,929
是交易结构的最后部分。

00:33:38,929 --> 00:33:44,149
时间锁基本上允许你对交易设置一个延后处理的时间点。

00:33:44,149 --> 00:33:49,460
如果你设置的时间锁小于5亿，

00:33:49,460 --> 00:33:51,649
那么它代表的是一个特定的区块高度。

00:33:51,649 --> 00:33:54,320
回顾之前的例子，

00:33:54,320 --> 00:33:56,629
假设当前已经产生了14个区块，

00:33:56,629 --> 00:33:58,609
如果我们设置的时间锁是16，

00:33:58,609 --> 00:34:03,590
那么这意味着这笔交易只能在

00:34:03,590 --> 00:34:06,700
区块高度达到16或更高时被打包进区块链。

00:34:07,389 --> 00:34:10,699
相似地，

00:34:10,699 --> 00:34:12,859
如果你将锁定时间设置为大于5亿（500 million），

00:34:12,859 --> 00:34:16,909
那么这里的5亿指的是Unix时间戳。

00:34:16,909 --> 00:34:18,770
如果超过这个数，

00:34:18,770 --> 00:34:35,179
那么你指定的是一个特定的Unix时间点，

00:34:35,179 --> 00:34:23,960
交易将在达到或超过该时间点时才能被确认。

00:34:23,960 --> 00:34:29,330
即自1970年1月1日00：00：00起的秒数。

00:34:29,330 --> 00:34:32,960
不管怎样，这个时间锁都会将交易

00:34:32,960 --> 00:34:35,179
锁定到一个特定的区块或一个特定的时间点之后。

00:34:35,179 --> 00:34:38,449
但如果你不打算使用时间锁，

00:34:38,449 --> 00:34:44,060
你可以将其设置为零，

00:34:44,060 --> 00:34:47,889
这意味着交易可以立即被打包。

00:34:47,889 --> 00:34:52,790
至此我们完成了对交易结构的概述。

00:34:52,790 --> 00:34:55,099
再次回顾一下，交易主要包括四个部分：

00:34:55,099 --> 00:34:58,700
版本号，通常是1；

00:34:58,700 --> 00:35:01,130
然后是输入部分，

00:35:01,130 --> 00:35:03,920
我们这里只选择了一个输入；

00:35:03,920 --> 00:35:06,080
接下来是输出部分，

00:35:06,080 --> 00:35:10,280
涉及到的解锁脚本我稍后会详细解释；

00:35:10,280 --> 00:35:12,530
最后是时间锁。

00:35:12,530 --> 00:35:14,960
这就是任何交易的四个主要部分。

00:35:14,960 --> 00:35:17,589
好的，

00:35:17,660 --> 00:35:22,089
现在我们来到了幻灯片的最后一部分。

00:35:22,089 --> 00:35:24,619
接下来，

00:35:24,619 --> 00:35:27,019
我将向大家介绍签名的实际操作过程，

00:35:27,019 --> 00:35:28,700
这是为了解锁输出，

00:35:28,700 --> 00:35:31,640
也就是我们所说的输入。

00:35:31,640 --> 00:35:34,640
在这部分，我会快速介绍一些内容，

00:35:34,640 --> 00:35:37,309
可能由于时间限制，无法详细解释清楚。

00:35:37,309 --> 00:35:39,740
因为我认为关于签名的细节

00:35:39,740 --> 00:35:42,769
可能需要通过一些视频来进一步阐释。

00:35:42,769 --> 00:35:44,599
但是如果你之后有机会重新观看这个视频，

00:35:44,599 --> 00:35:47,269
并且想要从头开始构建自己的交易，

00:35:47,269 --> 00:35:50,059
我想确保至少涵盖了创建签名，

00:35:50,059 --> 00:35:52,750
以及签署交易所需完成的所有步骤。

00:35:52,750 --> 00:35:57,380
所以如果有些内容你暂时还不理解，

00:35:57,380 --> 00:35:59,269
也不必担心，

00:35:59,269 --> 00:36:02,690
也许等你再次回顾时就能弄明白了。

00:36:02,690 --> 00:36:07,670
我们来看这个交易，

00:36:07,670 --> 00:36:09,500
其中包含了一个需要解锁的输入。

00:36:09,500 --> 00:36:11,990
这个输入已经被锁定到了我们的地址上，

00:36:11,990 --> 00:36:16,400
而我们持有与该地址相对应的私钥。

00:36:16,400 --> 00:36:28,940
我们需要用这个私钥来证明我们是地址的所有者。

00:36:28,940 --> 00:36:33,740
一个非常简单但绝对不推荐的方法是，

00:36:33,740 --> 00:36:37,369
直接把你的私钥放入交易中。

00:36:37,369 --> 00:36:38,720
这样确实可以证明你拥有私钥，

00:36:38,720 --> 00:36:40,759
但问题是，

00:36:40,759 --> 00:36:43,819
一旦你这样做并将其发送到网络上，

00:36:43,819 --> 00:36:47,329
你的私钥就相当于公开给了网络中的每个人，

00:36:47,329 --> 00:36:49,519
因为私钥已经被暴露出去了。

00:36:49,519 --> 00:36:51,950
如果你有其他的输出被锁定到这个地址，

00:36:51,950 --> 00:36:54,589
他们可以使用你的私钥解锁并花费它们，

00:36:54,589 --> 00:36:56,359
或者他们甚至可以不转发此交易，

00:36:56,359 --> 00:36:59,269
而是直接用你的私钥创建一个新交易，

00:36:59,269 --> 00:37:03,410
然后将资金发送到他们自己的地址。

00:37:03,410 --> 00:37:05,839
这显然是非常危险的。

00:37:05,839 --> 00:37:08,390
因此我们需要一种更加智能的方法来使用私钥解锁锁定，

00:37:08,390 --> 00:37:11,509
以证明我们拥有该地址，

00:37:11,509 --> 00:37:13,940
而不是直接暴露私钥本身。

00:37:13,940 --> 00:37:18,079
这就是数字签名的用途。

00:37:18,079 --> 00:37:19,880
正如我所说，

00:37:19,880 --> 00:37:24,450
私钥和地址实际上是相互关联的，

00:37:24,450 --> 00:37:27,000
地址实际上是由私钥生成的。

00:37:27,000 --> 00:37:30,810
我现在不打算详细解释这个过程，

00:37:30,810 --> 00:37:32,070
但是私钥和数字签名，

00:37:32,070 --> 00:37:40,710
是通过椭圆曲线加密的一些数学运算相互关联的。

00:37:40,710 --> 00:37:41,820
你可以做的是，

00:37:41,820 --> 00:37:44,150
利用椭圆曲线加密的数学运算，

00:37:44,150 --> 00:37:48,810
从你的私钥生成一个签名，

00:37:48,810 --> 00:37:53,970
这个签名可以用来解锁该地址。

00:37:53,970 --> 00:37:57,480
我将简要介绍如何为交易创建数字签名。

00:37:57,480 --> 00:38:00,180
首先，

00:38:00,180 --> 00:38:04,430
你需要你的私钥和你想要签名的交易数据，

00:38:04,430 --> 00:38:08,490
然后将它们放入椭圆曲线加密算法中。

00:38:08,490 --> 00:38:10,470
通过一系列椭圆曲线数学运算，

00:38:10,470 --> 00:38:13,790
你将得到一个签名。

00:38:13,790 --> 00:38:16,320
目前，

00:38:16,320 --> 00:38:21,360
交易的输入部分仅显示屏幕上的信息，

00:38:21,360 --> 00:38:27,030
是的，它还在那里。

00:38:27,030 --> 00:38:32,700
对，是的，

00:38:32,700 --> 00:38:34,950
然后你将这个未签名的交易和你的私钥一起输入到算法中，

00:38:34,950 --> 00:38:38,460
和你的私钥一起输入到算法中，

00:38:38,460 --> 00:38:40,410
这将生成一个签名。

00:38:40,410 --> 00:38:44,040
这个签名随后会被嵌入到交易中。

00:38:44,040 --> 00:38:45,660
我这里简化了这个过程，

00:38:45,660 --> 00:38:48,840
这可能是你觉得难以理解的部分，

00:38:48,840 --> 00:38:51,720
因为它确实有些复杂。

00:38:51,720 --> 00:38:52,040
然而，

00:38:52,040 --> 00:38:55,590
如果你从技术角度来分析或实际操作这个过程，

00:38:55,590 --> 00:38:58,140
你需要做的是，

00:38:58,140 --> 00:39:01,740
首先在你想要对一个交易进行签名时，

00:39:01,740 --> 00:39:03,180
必须先移除任何已有的签名。

00:39:03,180 --> 00:39:04,890
如果你已经对一个输入进行了签名，

00:39:04,890 --> 00:39:07,470
就要将这个签名删除。

00:39:07,470 --> 00:39:19,020
接着你需要在脚本签名应该放置的位置放入一个占位符代码，

00:39:19,020 --> 00:39:23,820
这个占位符代表了我们尝试解锁的输入的锁定脚本或者是公钥脚本。

00:39:23,820 --> 00:39:25,950
这仅仅是一个占位符，

00:39:25,950 --> 00:39:27,720
用来标识我们要签名的是哪个输入。

00:39:27,720 --> 00:39:29,559
然后，

00:39:29,559 --> 00:39:32,480
你需要将所谓的签名哈希类型（sig hash type）

00:39:32,480 --> 00:39:34,970
添加到交易数据的末尾。

00:39:34,970 --> 00:39:38,239
我不是很确定这个具体是用来做什么的，

00:39:38,239 --> 00:39:41,989
但是对于标准的签名过程，

00:39:41,989 --> 00:39:43,640
你通常只需要在这里输入数字1，

00:39:43,640 --> 00:39:45,380
这代表了网络字节序，长度是4个字节。

00:39:45,980 --> 00:39:48,619
之后你需要将所有这些数据

00:39:48,619 --> 00:39:52,099
通过SHA256算法进行两次哈希处理，

00:39:52,099 --> 00:39:54,980
得到一个摘要，它是信息，

00:39:54,980 --> 00:40:01,489
这就是椭圆曲线的内容，

00:40:01,489 --> 00:40:03,289
椭圆曲线会输出一个签名。

00:40:03,289 --> 00:40:10,670
你需要将这个签名编码成DER格式，

00:40:10,670 --> 00:40:12,890
我相信大多数库都提供了这种编码签名的功能。

00:40:12,890 --> 00:40:15,769
最后你需要将相同的签名哈希类型

00:40:15,769 --> 00:40:18,259
附加到实际的签名，

00:40:18,259 --> 00:40:22,009
我们将它放入数学运算中，

00:40:22,009 --> 00:40:29,299
并在签名的末尾附加上相同的数字。

00:40:29,299 --> 00:40:31,730
这个数字是4个字节长，

00:40:31,730 --> 00:40:32,599
而这是1个字节长，

00:40:32,599 --> 00:40:35,420
我认为在账户开发时

00:40:35,420 --> 00:40:40,460
将字节大小设置成不同的值是一个错误，

00:40:40,460 --> 00:40:43,700
但它们都表示相同的数字1和1，

00:40:43,700 --> 00:40:44,930
所以这个放在末尾。

00:40:44,930 --> 00:40:46,099
但如果你在做这方面技术性的工作，

00:40:46,099 --> 00:40:48,079
这就是你需要了解的。

00:40:48,079 --> 00:40:49,309
我这里只是简化了整个过程，

00:40:49,309 --> 00:40:53,119
目的是为了向你展示交易数据是如何进入椭圆曲线算法的。

00:40:53,119 --> 00:40:55,789
因此，

00:40:55,789 --> 00:40:58,609
当你使用椭圆曲线加密算法创建这个签名时，

00:40:58,609 --> 00:41:01,369
签名会显示在地址上。

00:41:01,369 --> 00:41:04,579
好的，

00:41:04,579 --> 00:41:11,509
这个签名只能由拥有相应公钥的人创建。

00:41:11,509 --> 00:41:14,630
那么这就足够了，

00:41:14,630 --> 00:41:16,249
签名足以解锁一个输入，

00:41:16,249 --> 00:41:22,640
我们可以把这个签名放在这里，

00:41:22,640 --> 00:41:24,529
而无需暴露我们的公钥或私钥。

00:41:24,529 --> 00:41:30,289
签名过程的一个优点是，

00:41:30,289 --> 00:41:39,890
因为签名是针对我们所创建的特定交易生成的，

00:41:39,890 --> 00:41:42,859
所以一旦我们将签名加入交易并发送到网络，

00:41:42,859 --> 00:41:51,380
如果有人试图修改交易内容，

00:41:51,380 --> 00:41:58,549
比如改变接收比特币的地址，

00:41:58,549 --> 00:42:00,170
企图窃取比特币，

00:42:00,170 --> 00:42:02,450
那么签名将不再有效，

00:42:02,450 --> 00:42:06,799
交易也就无法成立。

00:42:06,799 --> 00:42:13,369
这是因为签名是专为原始交易设计的，

00:42:13,369 --> 00:42:19,069
它确保了交易结构的安全，

00:42:19,069 --> 00:42:21,079
只能用于该特定交易。

00:42:21,079 --> 00:42:32,710
这就是创建签名以解锁输入的方法，

00:42:32,710 --> 00:42:35,619
这种方法被称为脚本签名。

00:42:35,619 --> 00:42:38,359
但在脚本签名中，

00:42:38,359 --> 00:42:41,569
你不仅需要放入签名，

00:42:41,569 --> 00:42:45,920
因为我之前向你展示了这里的锁定代码，

00:42:45,920 --> 00:42:48,799
它需要你放入公钥，

00:42:48,799 --> 00:42:57,829
即地址的原始形式，

00:42:52,400 --> 00:42:57,829
你必须将其放入脚本签名。

00:42:57,829 --> 00:42:59,749
尽管它被称为脚本签名，

00:42:59,749 --> 00:43:03,650
但它也需要公钥才能使解锁代码正常工作。

00:43:03,650 --> 00:43:09,799
由于公钥的大小可能会变化，

00:43:09,799 --> 00:43:15,920
因此需要在这里

00:43:11,509 --> 00:43:15,920
加入一个可变整数来表示它的长度。

00:43:15,920 --> 00:43:17,660
签名的大小也是可变的，

00:43:17,660 --> 00:43:21,200
因此它也有自己的可变整数。

00:43:21,200 --> 00:43:24,650
在整个脚本签名的前面，

00:43:24,650 --> 00:43:28,400
还需要放置一个可变整数。

00:43:28,400 --> 00:43:31,039
这样，

00:43:31,039 --> 00:43:33,890
我们就可以区分固定大小的字段和可变大小的字段，

00:43:33,890 --> 00:43:37,819
这意味着你可以解码这个交易并准确地获取数据量，

00:43:37,819 --> 00:43:40,420
从而知道每个部分的内容。

00:43:41,050 --> 00:43:43,190
然后，

00:43:43,190 --> 00:43:44,600
我们将这个交易发送到网络中，

00:43:44,600 --> 00:43:46,610
因为你已经加入了解锁所需的签名，

00:43:46,610 --> 00:43:47,960
它将被网络传播，

00:43:47,960 --> 00:43:50,840
最终交易会被挖矿节点确认，

00:43:50,840 --> 00:43:55,040
就会扩展成这个图表。

00:43:55,040 --> 00:43:58,130
在这个过程中，

00:43:58,130 --> 00:44:06,140
网络中的每个节点都有责任检查交易的有效性。

00:44:06,140 --> 00:44:07,460
好的，

00:44:07,460 --> 00:44:14,000
如果我篡改了Cynthia的脚本，

00:44:14,000 --> 00:44:21,020
节点会识别出来并忽略这个交易，

00:44:21,020 --> 00:44:34,940
节点会当成发送了一个错误的脚本。

00:44:34,940 --> 00:44:44,570
实际上它是一个数字签名，

00:44:44,570 --> 00:44:46,640
仅仅是由私钥对交易的哈希进行签名。

00:44:49,370 --> 00:44:50,560
你的理解是正确的。

00:44:50,560 --> 00:44:58,070
我感觉，

00:44:58,070 --> 00:45:02,360
节点可能会使用公钥重新对签名进行验证，

00:45:02,360 --> 00:45:07,940
并检查签名是否一致。

00:45:07,940 --> 00:45:10,010
没错，

00:45:10,010 --> 00:45:15,920
你已经理解了这个过程。

00:45:15,920 --> 00:45:18,500
回到这个幻灯片，

00:45:18,500 --> 00:45:23,150
你曾经提到了占位符。

00:45:23,150 --> 00:45:25,880
能否请你再解释一遍？

00:45:25,880 --> 00:45:30,710
我的理解是，占位符可能是一些文本，

00:45:30,710 --> 00:45:33,020
或者仅仅是一个标记？

00:45:33,020 --> 00:45:43,040
在我们之前创建交易时，

00:45:43,040 --> 00:45:49,010
占位符是用来表示锁定脚本的代码。

00:45:49,010 --> 00:45:50,299
举个例子，

00:45:50,299 --> 00:45:54,270
假设你想要使用一个输入，

00:45:54,270 --> 00:46:05,789
那么这里的占位符就代表了该输入的锁定脚本代码。

00:46:05,789 --> 00:46:08,849
这听起来有些混乱，

00:46:08,849 --> 00:46:12,569
我不确定为什么它一定要是锁定脚本的代码，

00:46:12,569 --> 00:46:14,670
但我猜想它也可以是其他任何东西。

00:46:14,670 --> 00:46:16,380
不过，它必须是该输入的实际锁定脚本代码。

00:46:16,380 --> 00:46:17,520
坦白说，

00:46:17,520 --> 00:46:19,230
这让交易的创建过程显得有些麻烦，

00:46:19,230 --> 00:46:24,329
因为你需要回头去找到那个输入的实际锁定脚本，

00:46:24,329 --> 00:46:27,030
并将其作为占位符。

00:46:27,030 --> 00:46:32,430
但这就是它的工作原理。

00:46:32,430 --> 00:46:34,349
让我们再次回顾一下整个过程。

00:46:34,349 --> 00:46:38,579
我们对整个区块进行哈希处理，

00:46:38,579 --> 00:46:40,200
这就是我们要签名的内容。

00:46:40,200 --> 00:46:41,460
我之前简化了这个过程，

00:46:41,460 --> 00:46:44,369
说你只需要把交易数据放进椭圆曲线算法中就可以了。

00:46:44,369 --> 00:46:46,680
在某种程度上这是对的，

00:46:46,680 --> 00:46:48,690
但更准确的说，

00:46:48,690 --> 00:46:51,180
你实际上是在交易数据后附加了一个哈希类型，

00:46:51,180 --> 00:46:53,420
然后对其进行哈希处理，

00:46:53,420 --> 00:46:58,099
最后将结果放入椭圆曲线数学公式中进行签名。

00:46:58,609 --> 00:47:05,940
通常你可以找到一个名为ECDSA的库，

00:47:05,940 --> 00:47:11,160
也就是椭圆曲线数字签名算法，

00:47:11,160 --> 00:47:16,529
我们通常可以用它来完成签名过程。

00:47:16,529 --> 00:47:19,470
还有一个问题是，

00:47:19,470 --> 00:47:25,579
我们是否需要对每一个我们尝试使用的输出，

00:47:25,579 --> 00:47:29,430
都执行这个签名过程？

00:47:29,430 --> 00:47:32,609
大致上，

00:47:32,609 --> 00:47:35,339
需要确保移除交易中所有已存在的签名。

00:47:35,339 --> 00:47:40,500
对于每一个需要签名的空白部分，

00:47:40,500 --> 00:47:45,930
我们最后汇总，

00:47:45,930 --> 00:47:49,890
然后逐一进行签名操作。

00:47:49,890 --> 00:47:53,190
喔，不好意思，

00:47:53,190 --> 00:47:55,319
在这个例子中，

00:47:55,319 --> 00:47:57,329
我只有一个签名，

00:47:57,329 --> 00:48:01,470
假设有多个输入，

00:48:01,470 --> 00:48:02,670
我就会取出所有这些签名，

00:48:02,670 --> 00:48:04,290
然后签名一个，

00:48:04,290 --> 00:48:07,470
就将占位符放入下一个，

00:48:07,470 --> 00:48:09,390
以此类推，直到最后，

00:48:09,390 --> 00:48:12,390
你只需要在最后插入到相应的位置。

00:48:12,390 --> 00:48:14,280
最后，

00:48:14,280 --> 00:48:21,120
我们将所有生成的签名插入到相应的位置。

00:48:21,120 --> 00:48:23,160
总结一下，

00:48:23,160 --> 00:48:25,350
这是我们创建的交易，

00:48:25,350 --> 00:48:30,660
我们创建了签名并将其放入。

00:48:30,660 --> 00:48:32,730
之前我说，一个交易有四个主要部分，

00:48:32,730 --> 00:48:35,460
交易的版本号（version），输入（inputs），

00:48:35,460 --> 00:48:38,070
输入本身有自己的结构或子结构，

00:48:38,070 --> 00:48:41,700
它有一个引用，指向一个交易ID，

00:48:41,700 --> 00:48:44,000
然后引用一个特定的输出，

00:48:44,000 --> 00:48:51,330
接着有一个可变整数来告诉你脚本签名的大小，

00:48:51,330 --> 00:48:54,360
之后是一个序列号。

00:48:54,360 --> 00:48:56,730
这是一个输入，

00:48:56,730 --> 00:48:58,140
下一个部分是输出，

00:48:58,140 --> 00:49:02,250
输出的结构相对简单，

00:49:02,250 --> 00:49:04,500
包含一个8字节长的数值，

00:49:04,500 --> 00:49:08,250
然后是一个可变整数来告诉你输出脚本的大小，

00:49:08,250 --> 00:49:14,300
最后你有锁定时间。

00:49:14,300 --> 00:49:17,490
这就是一笔交易，

00:49:17,490 --> 00:49:19,260
它们都是相同的，

00:49:19,260 --> 00:49:21,150
唯一的区别是它们有不同数量的输入，

00:49:21,150 --> 00:49:24,270
和不同数量的输出，

00:49:24,270 --> 00:49:29,820
并且它们显然指向不同的交易并且有不同的签名，

00:49:29,820 --> 00:49:31,620
但如果你理解了结构，

00:49:31,620 --> 00:49:33,420
那么你就能理解除了隔离见证之外，

00:49:33,420 --> 00:49:35,060
每一笔可能存在的比特币交易的结构。

00:49:35,060 --> 00:49:39,570
这就像是一种旧式的交易。

00:49:39,570 --> 00:49:42,840
现在我们有了隔离见证，

00:49:42,840 --> 00:49:46,830
从非常基础的层面来说，

00:49:46,830 --> 00:49:52,860
将原本嵌入在交易数据中间的签名代码

00:49:52,860 --> 00:49:55,440
移动到交易数据的末尾。

00:49:55,440 --> 00:50:04,740
这部分移动到末尾的数据就被称为“见证”，

00:50:04,740 --> 00:50:10,860
这也是“隔离见证”这个名字的由来，

00:50:10,860 --> 00:50:17,369
它本质上是将签名数据与交易数据分离开来。

00:50:17,369 --> 00:50:23,160
我认为详细介绍隔离见证可能需要一个单独的视频，

00:50:23,160 --> 00:50:26,339
但我想至少在这里先解释一下基础的交易，

00:50:26,339 --> 00:50:30,869
这些交易仍然是有效的。

00:50:30,869 --> 00:50:42,920
你仍然可以在网络上正常地进行这些交易。

00:50:44,300 --> 00:50:48,059
这只是一个比特币提案吗，

00:50:48,059 --> 00:50:51,390
哦，是的没错。

00:50:51,390 --> 00:50:57,119
隔离见证是改变交易数据结构的提案。

00:50:57,119 --> 00:50:59,339
是的，正如你所说，

00:50:59,339 --> 00:51:02,520
这是个典型的基础交易，

00:51:02,520 --> 00:51:06,450
但是隔离见证会有一个额外的字段或部分称为见证区。

00:51:06,450 --> 00:51:11,130
在隔离见证中，签名基本上被移动到交易的末尾，

00:51:11,130 --> 00:51:15,359
这部分就被称为见证区。

00:51:15,359 --> 00:51:16,740
让我重新表述一下这个问题，

00:51:16,740 --> 00:51:19,980
这是比特币核心的改变，

00:51:19,980 --> 00:51:23,970
还是为了交易所需要做出的改变？

00:51:23,970 --> 00:51:30,390
因为我一直听说某个人需要实施隔离见证，

00:51:30,390 --> 00:51:35,400
另一个人也需要实施隔离见证，

00:51:35,400 --> 00:51:38,940
但他们还没有这么做，

00:51:38,940 --> 00:51:41,220
我对此仍有些困惑。

00:51:41,220 --> 00:51:43,980
如果你没有使用比特币核心软件，

00:51:43,980 --> 00:51:47,849
而是创建了自己的软件，

00:51:47,849 --> 00:51:53,790
并且你的软件只能创建这两种类型的交易结构，

00:51:53,790 --> 00:51:56,640
那么你就必须使用你自己的软件来创建交易。

00:51:56,640 --> 00:51:59,910
如果你已经制作了自己的软件来创建这些交易，

00:51:59,910 --> 00:52:02,190
自己创建的会更有意义，

00:52:02,190 --> 00:52:05,099
安全也更有保障。

00:52:05,099 --> 00:52:12,030
这项技术并不复杂，

00:52:12,030 --> 00:52:13,260
我明白有些地方要花一些时间，

00:52:13,260 --> 00:52:15,299
我想可能是出于谨慎的考虑。

00:52:15,299 --> 00:52:19,530
如果我发送一个包含隔离见证的比特币交易，

00:52:19,530 --> 00:52:24,059
比特币核心会识别吗？

00:52:24,059 --> 00:52:27,450
是的，它会的。

00:52:27,450 --> 00:52:32,069
好的，我们把基础工作已经完成了。

00:52:32,069 --> 00:52:34,140
beta版本完成了。

00:52:34,140 --> 00:52:36,329
接下来我会做一些示例，

00:52:36,329 --> 00:52:37,859
我会从头开始创建一个交易。

00:52:37,859 --> 00:52:47,490
好的，这是我之前创建的网站，

00:52:47,490 --> 00:52:50,119
在这里，

00:52:50,119 --> 00:52:54,240
展示如何从零开始构建交易。

00:52:54,240 --> 00:52:55,740
我打开了词汇表，

00:52:55,740 --> 00:52:59,880
去查阅交易数据，

00:52:59,880 --> 00:53:02,490
我在这里已经细分了交易，

00:53:02,490 --> 00:53:04,530
如果你想解码你自己的交易，

00:53:04,530 --> 00:53:05,460
我认为这是个很棒的主意。

00:53:05,460 --> 00:53:07,530
我认为解码交易数据是学习的很好开始，

00:53:07,530 --> 00:53:10,650
因为一开始尝试构建一个签名可能有点棘手，

00:53:10,650 --> 00:53:13,349
你可能在某个点上会遇到困难。

00:53:13,349 --> 00:53:22,290
但我认为从解码开始会更好的理解交易的工作原理，

00:53:22,290 --> 00:53:27,390
拥有自己的解码器仅是为了自己参考目的方便，

00:53:27,390 --> 00:53:30,030
但如果你想深入了解交易数据，

00:53:30,030 --> 00:53:34,940
你可以访问我的网站上的这个页面，

00:53:34,940 --> 00:53:40,650
或者你也可以在浏览器上查看任何区块链上的交易。

00:53:40,650 --> 00:53:43,349
比如这个，这个例子有点复杂，

00:53:43,349 --> 00:53:46,230
它包含了许多输入和输出。

00:53:46,230 --> 00:53:48,480
但如果你点击查看具体细节，

00:53:48,480 --> 00:53:52,109
你可以把交易拆解成它的各个组成部分。

00:53:52,109 --> 00:53:55,380
所以当你想了解交易的结构时，

00:53:55,380 --> 00:54:03,900
这个方法可能会对你有帮助。

00:54:03,900 --> 00:54:05,420
但我现在要做的是，

00:54:05,420 --> 00:54:11,450
我要构建我自己的交易。

00:54:11,450 --> 00:54:15,349
我发誓我不能放弃，我要摆脱这个小东西。

00:54:15,349 --> 00:54:18,109
噢对不起，我不知道怎么做，兄弟。

00:54:18,109 --> 00:54:27,799
所以我有一些我做了一个小脚本，

00:53:22,290 --> 00:54:18,109
叫做交易构建器，

00:54:27,799 --> 00:54:30,440
我将要用它来构建我的交易。

00:54:30,440 --> 00:54:39,049
首先我需要知道我能够使用哪些未花费的输出，

00:54:39,049 --> 00:54:41,869
幸运的是，我之前创建了一个交易，

00:54:41,869 --> 00:54:46,430
且提前将一些输出锁定到了一个地址，

00:54:46,430 --> 00:54:54,380
现在我打算花费其中的一个输出。

00:54:54,380 --> 00:54:55,849
这是我想要使用的输出，

00:54:55,849 --> 00:54:57,549
我打算将其发送到另一个地址。

00:54:57,549 --> 00:55:00,170
首先在交易构建器中，

00:55:00,170 --> 00:55:01,549
我需要一个版本号，

00:55:01,549 --> 00:55:03,589
我决定使用版本1。

00:55:03,589 --> 00:55:11,359
我将这个数字1转换成十六进制的网络字节顺序，

00:55:11,359 --> 00:55:15,980
并将其转换成一个4字节的字段。

00:55:15,980 --> 00:55:17,930
接下来，我需要选择输入，

00:55:17,930 --> 00:55:20,720
包括一个交易ID和一个输出编号。

00:55:20,720 --> 00:55:23,020
这是交易ID，

00:55:23,020 --> 00:55:26,270
我将它放在这里，

00:55:26,270 --> 00:55:30,280
并且我选择了编号为0的输出，

00:55:30,280 --> 00:55:36,380
这是我唯一想要花费的输出。

00:55:36,380 --> 00:55:40,460
那么你看这里，

00:55:40,460 --> 00:55:44,000
这是输入的数量，

00:55:44,000 --> 00:55:50,530
接着是交易ID的反向字节顺序，

00:55:54,090 --> 00:55:50,530
所以是4a，

00:55:50,530 --> 00:55:59,460
而这里是4字节的输出编号。

00:55:59,460 --> 00:56:02,550
这里是可变整数，

00:56:02,550 --> 00:56:04,080
用来告诉我即将出现的签名大小，

00:56:04,080 --> 00:56:05,730
但我还没有把它放进去，

00:56:05,730 --> 00:56:07,500
所以是0。

00:56:07,500 --> 00:56:11,120
这里是我尚未使用的序列号。

00:56:11,120 --> 00:56:13,650
接下来，

00:56:13,650 --> 00:56:16,970
我需要设置我的交易输出。

00:56:16,970 --> 00:56:20,910
这是0.005比特币，

00:56:20,910 --> 00:56:23,520
但我想用Satoshi来表示，

00:56:23,520 --> 00:56:28,350
所以我这里要设置一下，

00:56:28,350 --> 00:56:33,090
就是510,000Satoshi，

00:56:33,090 --> 00:56:36,840
我输入了金额和我想要发送到的地址，

00:56:36,840 --> 00:56:41,760
这个地址是我网站顶部的捐赠地址。

00:56:41,760 --> 00:56:47,310
好了。

00:56:47,310 --> 00:56:51,630
但我希望这笔交易能被矿工确认，

00:56:51,630 --> 00:56:53,880
我没有专门设置交易费用，

00:56:53,880 --> 00:56:54,660
所以我打算不发送全部金额，

00:56:54,660 --> 00:57:00,990
而是发送490000这个数额，

00:57:00,990 --> 00:57:02,490
这样就相当于加上了一点手续费。

00:57:02,490 --> 00:57:03,960
我不确定具体每比特的手续费会是多少，

00:57:03,960 --> 00:57:06,120
但这样会留下一些余额。

00:57:06,120 --> 00:57:09,570
我再次输入了地址，

00:57:09,570 --> 00:57:12,450
交易已经创建，

00:57:12,450 --> 00:57:17,910
输出也已经添加到了交易代码中。

00:57:17,910 --> 00:57:22,190
当我放入这个的时候，这是对的，

00:57:22,190 --> 00:57:26,180
但我有个问题，

00:57:26,180 --> 00:57:39,090
这个时候它是已经签名的还是没有签名？

00:57:31,260 --> 00:57:35,070
你需要先创建完整的交易结构，

00:57:35,070 --> 00:57:39,090
然后才能签名。

00:57:39,090 --> 00:57:46,020
所以现在你的代码已经被插入到这里，

00:57:46,020 --> 00:57:48,510
最后一步就是签名。

00:57:48,510 --> 00:57:50,850
我们已经创建了交易结构，

00:57:50,850 --> 00:57:52,410
选择了输入并创建了输出，

00:57:52,410 --> 00:57:56,010
我们有了完整的结构和所需的数据，

00:57:56,010 --> 00:57:59,370
就可以进行签名了。

00:57:59,370 --> 00:58:00,330
我需要这个地址的私钥来签名。

00:58:00,330 -->00:58:06,300
记住，你永远不要暴露你的私钥。

00:58:06,300 --> 00:58:08,970
在这个例子中，

00:58:08,970 --> 00:58:12,690
我已经输出了我的私钥，

00:58:12,690 --> 00:58:13,710
它对应于之前的输出内容。

00:58:13,710 --> 00:58:16,680
但正如我提到的，

00:58:16,680 --> 00:58:21,180
我们需要获取锁定脚本，

00:58:21,180 --> 00:58:22,710
这样在签名时才能使用相应的占位符。

00:58:22,710 --> 00:58:25,080
这个过程可能有些繁琐，

00:58:25,080 --> 00:58:29,970
不过你可以在浏览器中点击那个小锁图标来获取锁定脚本。

00:58:29,970 --> 00:58:34,160
锁定脚本包含了一系列操作码，

00:58:34,160 --> 00:58:41,120
以及公钥和地址信息。

00:58:41,120 --> 00:58:47,550
我需要这个锁定脚本来作为签名交易时的占位符。

00:58:47,550 --> 00:58:47,700
现在我要进行签名操作，

00:58:47,700 --> 00:58:50,640
这里是已经签名完毕的交易数据，

00:58:50,640 --> 00:58:54,330
它已经完全签名好了，

00:58:54,330 --> 00:58:55,770
好了，准备就绪，

00:58:55,770 --> 00:58:59,370
可以使用，如果我想的话，

00:58:59,370 --> 00:59:01,760
我可以迅速对其进行解码。

00:59:01,760 --> 00:59:03,470
我已经编写了自己的交易解码器，

00:59:03,470 --> 00:59:05,700
这非常方便。

00:59:05,700 --> 00:59:08,370
通过它，

00:59:08,370 --> 00:59:11,370
我可以看到交易的输入部分，

00:59:11,370 --> 00:59:15,000
包括一个交易ID和一个输出部分，

00:59:15,000 --> 00:59:16,440
这个输出可以被解锁到一个特定的地址，

00:59:16,440 --> 00:59:21,600
这是我的捐赠地址。

00:59:21,600 --> 00:59:23,580
如果你下载了比特币核心客户端，

00:59:23,580 --> 00:59:25,670
那么它也有内置的解码器，

00:59:25,670 --> 00:59:27,829
你可以用它来做同样的事情，

00:59:27,829 --> 00:59:32,650
它同样能够帮你解码交易数据。

00:59:33,190 --> 00:59:37,609
现在我们已经有了一笔已签名并准备好的交易。

00:59:37,609 --> 00:59:41,829
我可以使用比特币的命令行界面来发送这笔交易。

00:59:41,829 --> 00:59:45,200
当我执行发送操作后，

00:59:45,200 --> 0:59:48,589
系统会给我一个交易ID，

00:59:48,589 --> 00:59:51,230
这个ID就代表了这笔交易。

00:59:51,230 --> 00:59:54,079
我可以拿这个交易ID，

00:59:54,079 --> 00:59:56,859
然后进入我的区块链浏览器，

00:59:56,859 --> 00:59:59,660
输入交易ID试图找到它，

00:59:59,660 --> 01:00:01,640
好吧，刚开始可能查不到，

01:00:01,640 --> 01:00:05,900
还需要一些时间来传播网络，

01:00:05,900 --> 01:00:12,589
我继续刷新页面，

01:00:12,589 --> 01:00:16,039
好吧，我等它十秒钟，

01:00:16,039 --> 01:00:18,559
是的，我们期待着这笔交易能在内存池中出现，

01:00:18,559 --> 01:00:20,450
或者是在区块链上被确认。

01:00:20,450 --> 01:00:25,160
我创建的这笔交易已经发送到了一个节点，

01:00:25,160 --> 01:00:25,549
现在它将被广播到整个网络，

01:00:25,549 --> 01:00:28,809
并最终进入到该节点的内存池中。

01:00:28,809 --> 01:00:31,759
这通常是一个自然的过程。

01:00:31,759 --> 01:00:33,710
如果我点击这个内存池查看，

01:00:33,710 --> 01:00:36,470
理论上我应该能在那里找到它。

01:00:36,470 --> 01:00:41,539
我再次刷新了页面，果然，交易出现了，

01:00:41,539 --> 01:00:42,890
是在五秒钟前接收到的。

01:00:42,890 --> 01:00:46,069
我可以点击查看这笔交易的详情，

01:00:46,069 --> 01:00:48,319
这正是我刚刚创建并发送的交易。

01:00:48,319 --> 01:00:51,349
现在通过浏览器我可以确认，

01:00:51,349 --> 01:00:53,089
我的交易已经成功地广播到了网络上。

01:00:53,089 --> 01:00:56,059
我注意到这笔交易设置的手续费非常低，

01:00:56,059 --> 01:01:00,410
我不确定它是否会很快被矿工挖掘确认。

01:01:00,410 --> 01:01:01,970
但我仍然可以查看交易的详细信息，

01:01:01,970 --> 01:01:04,549
这正是我创建的那笔交易。

01:01:04,549 --> 01:01:07,519
基本上，你把一个交易发送到了网络，

01:01:07,519 --> 01:01:12,589
这就描述了从输入到输出的交易过程。

01:01:12,589 --> 01:01:18,769
是的，这样更好。

01:01:18,769 --> 01:01:21,170
这里转换成美元，在这里……

01:01:21,170 --> 01:01:22,880
在这里…… 我没有，

01:01:22,880 --> 01:01:25,069
我想我可以请求我的兄弟，

01:01:25,069 --> 01:01:26,420
我还得继续努力，

01:01:26,420 --> 01:01:30,559
是的，我认为这大约是80美元，

01:01:30,559 --> 01:01:42,150
所以我可能想要确保这笔交易在我提交之前得到确认，

01:01:42,150 --> 01:01:49,440
因为确切的私钥和手续费大约是0.0002，

01:01:49,440 --> 01:01:52,950
由于节点在填充区块时只能使用有限的字节数，

01:01:52,950 --> 01:01:55,230
所以它们会根据字节收费。

01:01:55,230 --> 01:02:00,600
我还没有更新区块链浏览器使用权重计算，

01:02:00,600 --> 01:02:02,010
这是一个更为复杂的问题。

01:02:02,010 --> 01:02:05,400
如果我们查看所有交易，

01:02:05,400 --> 01:02:10,170
你会发现在底部的那些交易

01:02:10,170 --> 01:02:13,290
通常是根据手续费来排序的，

01:02:13,290 --> 01:02:15,480
最低的大约是100Satoshi。

01:02:15,480 --> 01:02:17,490
对，最少要100个Satoshi，

01:02:17,490 --> 01:02:19,530
因此，有些人可能会支付更低的费用，

01:02:19,530 --> 01:02:24,780
但这只是一个大致的估算。

01:02:24,780 --> 01:02:28,620
看起来我的交易费用稍微低了一点，

01:02:28,620 --> 01:02:32,130
目前还无法显示我的交易。

01:02:32,130 --> 01:02:36,990
所以我可能会创建另一个交易来演示给你看。

01:02:36,990 --> 01:02:39,750
我认为这已经足够了。

01:02:39,750 --> 01:02:47,730
当你发起一个交易时，

01:02:47,730 --> 01:02:49,620
它会进入内存池。

01:02:49,620 --> 01:02:52,610
我已经把相关代码放在了网站上，

01:02:52,610 --> 01:02:55,650
如果你查看transactionbuilder.rb文件，

01:02:55,650 --> 01:02:59,280
你会发现所有的代码都在那里。

01:02:59,280 --> 01:03:00,440
我用Ruby语言编写，我尽量保持简单。

01:03:00,440 --> 01:03:03,570
我本来打算用过程式编程来实现，

01:03:03,570 --> 01:03:04,680
因为我觉得那样会更简单，

01:03:04,680 --> 01:03:06,630
但最终还是选择了面向对象的方式，

01:03:06,630 --> 01:03:08,250
因为这样更容易实现。

01:03:08,250 --> 01:03:12,360
代码量并不多，

01:03:12,360 --> 01:03:14,460
大约300行，

01:03:14,460 --> 01:03:26,310
但关键是你需要一些工具来获取所有数据的正确格式。

01:03:26,310 --> 01:03:28,920
一个交易的构成，

01:03:28,920 --> 01:03:31,110
它包含版本、输入、输出和锁定时间等

01:03:31,110 --> 01:03:34,350
每笔交易都有一个输入数组，

01:03:34,350 --> 01:03:35,790
和一个输出数组。

01:03:35,790 --> 01:03:40,040
输入对象包括交易ID、Vout和脚本等信息，

01:03:40,040 --> 01:03:45,320
而输出对象则包含价值和脚本公钥。

01:03:45,320 --> 01:03:52,940
如果你想从零开始构建自己的交易构建器，

01:03:52,940 --> 01:03:54,560
这是一个不错的方法。

01:03:54,560 --> 01:03:57,650
你可以使用自己喜欢的编程语言来实现。

01:03:57,650 --> 01:03:59,030
如果在构建过程中遇到错误或者问题，

01:03:59,030 --> 01:04:00,110
你想看看哪里出了问题，

01:04:00,110 --> 01:04:03,320
可以随时查阅相关资料。

01:04:03,320 --> 01:04:07,030
例如，签名可能是构建过程中最复杂的部分，

01:04:07,030 --> 01:04:10,310
这里有签名方法，

01:04:10,310 --> 01:04:12,860
有点长，

01:04:12,860 --> 01:04:14,300
但通过正确的步骤和注释，

01:04:14,300 --> 01:04:18,530
你可以更容易地找出可能遗漏的部分。

01:04:18,530 --> 01:04:24,880
这些可能会对你有所帮助。

01:04:24,940 --> 01:04:29,990
如果你有任何问题，可以随时提问。

01:04:29,990 --> 01:04:39,920
这个网站对于那些想要创建自己的交易，

01:04:39,920 --> 01:04:47,750
或者了解交易如何进行的人来说非常有用。

01:04:47,750 --> 01:04:49,850
网站是通过实时的比特币核心节点运行的，

01:04:49,850 --> 01:04:52,280
因此当你执行交易时，

01:04:52,280 --> 01:04:54,440
信息会即时更新。

01:04:54,440 --> 01:04:58,060
虽然我将数据存储在自己的数据库中，

01:04:58,060 --> 01:05:00,740
但它实际上是与运行中的比特币核心节点同步的。

01:05:00,740 --> 01:05:04,940
你进行交易或者新的区块被添加时，

01:05:04,940 --> 01:05:10,490
是的，所有的信息都是实时更新的。

01:05:10,490 --> 01:05:19,100
有些人可能会选择在另一台机器上拉取数据到数据库，

01:05:19,100 --> 01:05:22,070
并让网站从数据库中读取数据。

01:05:22,070 --> 01:05:23,510
但实际上，

01:05:23,510 --> 01:05:27,980
将节点和网站放在同一台机器上更为合理。

01:05:27,980 --> 01:05:29,150
-我将这个网站仅仅作为数据库使用，

01:05:29,150 --> 01:05:33,170
但我不需要机器来处理它。

01:05:33,170 --> 01:05:35,600
好的。

01:05:35,600 --> 01:05:40,640
由于这个网站实际上是在瑞士的一台机器上运行，

01:05:40,640 --> 01:05:41,990
而我在英国。

01:05:41,990 --> 01:05:47,910
当我从本地节点发送交易时，

01:05:47,910 --> 01:05:55,650
可能需要几秒钟的时间才能在整个网络中传播，

01:05:55,650 --> 01:05:59,699
因此我的网站在解码交易时会稍显缓慢。

01:05:59,699 --> 01:06:03,259
然后这些交易数据会被存储在数据库中。

01:06:04,039 --> 01:06:08,369
比特币的命令行界面CLI为你提供了所有这些数据，

01:06:08,369 --> 01:06:13,679
你可以访问包括内存池和内存池中的交易在内的所有数据。

01:06:13,679 --> 01:06:16,199
是的，它确实提供了所有的数据。

01:06:16,199 --> 01:06:19,019
因此你可以使用这个网站，

01:06:19,019 --> 01:06:21,989
但实际上你可以直接通过bitcoin-cli获取所有这些数据。

01:06:21,989 --> 01:06:25,939
我不太确定你指的是什么。

01:06:25,939 --> 01:06:28,650
至于内存池，

01:06:28,650 --> 01:06:31,469
bitcoin-cli可以获取更多关于内存池的信息，

01:06:31,469 --> 01:06:33,779
包括所有的交易ID。

01:06:33,779 --> 01:06:37,439
如果你想获取比特币交易信息，

01:06:37,439 --> 01:06:47,519
一切都可以在这里找到。

01:06:47,519 --> 01:06:48,809
我刚才查看的那笔交易的数据，

01:06:48,809 --> 01:06:50,729
所有的信息都有，

01:06:50,729 --> 01:06:52,229
你知道，

01:06:52,229 --> 01:06:53,269
你可以从内存池中获取所有的数据。

01:06:53,269 --> 01:07:00,119
我认为比特币系统设计得非常好，

01:07:00,119 --> 01:07:03,630
所以我想我已经讲解了我想要说的所有内容。

01:07:03,630 --> 01:07:07,859
是的，就是这些。

01:07:07,859 --> 01:07:13,670
非常感谢你。

01:07:13,670 --> 01:07:16,679
我期待着下一次的讲解。

01:07:16,679 --> 01:07:29,789
下次我们可能会讨论公钥和地址，

01:07:29,789 --> 01:07:33,059
以及每个密钥和地址是如何通过特定算法相互关联的。

01:07:33,059 --> 01:07:34,529
我还会解释很多关于数字签名是如何工作的细节。

01:07:34,529 --> 01:07:35,910
目前我只是简单地说这是一个签名，

01:07:35,910 --> 01:07:38,489
它是有效的，

01:07:38,489 --> 01:07:44,730
但我可以用数学的方法来详细解释它是如何真正起作用的。

01:07:44,730 --> 01:07:47,040
好的，我很期待。

01:07:47,040 --> 01:07:48,810
只要你准备好了，

01:07:48,810 --> 01:07:51,119
就告诉我。

01:07:51,119 --> 01:07:52,500
我就停下来，

01:07:52,500 --> 01:07:54,390
停止敲打键盘和处理一些我的事情。

01:07:54,390 --> 01:07:56,310
好的，我过一段时间给你发邮件，

01:07:56,310 --> 01:07:59,550
让你知道我什么时候可能准备好了。

01:07:59,550 --> 01:08:02,250
非常感谢你。

01:08:02,250 --> 01:08:04,550
谢谢你，谢谢你的帮助。