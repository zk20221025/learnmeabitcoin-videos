00:00:00,560 --> 00:00:06,240
所以我对了解sha-256的哈希函数是如何工作的感到很感兴趣，

00:00:06,240 --> 00:00:09,389
所以我创建了这个小脚本，

00:00:09,389 --> 00:00:12,780
它可以动态的显示数据的哈希过程，

00:00:12,780 --> 00:00:15,870
这样我就可以看到它是如何工作的。

00:00:15,870 --> 00:00:19,470
这个脚本只是在后台对字符串ABC进行哈希处理。

00:00:19,470 --> 00:00:22,320
我想在这个视频中，

00:00:22,320 --> 00:00:30,210
来逐步解释sha-256哈希函数是如何工作的，

00:00:30,210 --> 00:00:32,820
我会从基本知识开始，

00:00:32,820 --> 00:00:36,210
然后在这个基础之上慢慢拓展，

00:00:36,210 --> 00:00:42,930
以便我们最终能够理解整个哈希函数机制，

00:00:42,930 --> 00:00:46,289
然后我们就能理解sha-256是如何工作的。

00:00:46,289  --> 00:00:50,550
请耐心等待，我会从基本知识开始解释。

00:00:50,550 --> 00:00:51,660
首先，哈希函数的作用是什么？

00:00:51,660 --> 00:00:53,160
哈希函数接收一些数据，

00:00:53,160 --> 00:00:59,609
并为你提供一个该数据唯一的、

00:00:56,430 --> 00:00:59,609
更短的摘要或指纹，这就是它的全部功能，

00:00:59,609 --> 00:01:00,989
或者说它把数据打乱，

00:01:00,989 --> 00:01:04,019
然后为你提供一个更短的摘要。

00:01:04,019 --> 00:01:06,299
如果我对数据进行微小的修改，

00:01:06,299 --> 00:01:08,040
你会得到两个完全不同的结果，

00:01:08,040 --> 00:01:15,720
所以世界上的每一个数据都有自己独一无二的哈希摘要。

00:01:15,720 --> 00:01:16,650
你可以对字符串进行此操作，

00:01:16,650 --> 00:01:19,439
也可以对文件进行此操作。

00:01:19,439 --> 00:01:22,979
我这里有一个文件，

00:01:22,979 --> 00:01:25,200
写入"hello there"，保存它，

00:01:25,200 --> 00:01:28,009
然后获取这个文件的sha-256摘要。

00:01:28,009 --> 00:01:32,720
如果我对文件稍作修改，

00:01:32,720 --> 00:01:36,390
再来一次，

00:01:36,390 --> 00:01:39,090
我得到了一个完全不同的结果，这很酷。

00:01:39,090 --> 00:01:41,009
这使我可以检查文件何时发生了改变。

00:01:41,009 --> 00:01:48,180
而比特币中使用的哈希函数是，

00:01:48,180 --> 00:01:50,549
你可以对一些数据进行哈希处理，

00:01:50,549 --> 00:01:52,380
然后进行微小的调整，

00:01:52,380 --> 00:01:54,600
它会产生一些极其不同的结果，

00:01:54,600 --> 00:01:56,850
这是挖矿的一部分。

00:01:56,850 --> 00:01:59,430
同样重要需要注意的是，

00:01:59,430 --> 00:02:02,460
你无法控制这个哈希函数的结果，

00:02:02,460 --> 00:02:04,860
它以一种你无法预测结果的方式混淆数据，

00:02:04,860 --> 00:02:06,450
你能做的就是哈希它并查看结果。

00:02:06,450 --> 00:02:09,330
如果我想要它以10个“A”开始，

00:02:09,330 --> 00:02:13,580
我无法做到，

00:02:13,580 --> 00:02:17,210
我所能做的就是不断尝试不同的数据片段，

00:02:17,210 --> 00:02:18,650
希望我能找到一个结果是以十个“A”开头的。

00:02:18,650 --> 00:02:21,740
这就是挖矿的基本原理。

00:02:21,740 --> 00:02:25,250
如果你对比特币感兴趣，

00:02:25,250 --> 00:02:31,130
你可能会想知道矿工们是如何在区块链上添加交易块的。

00:02:31,130 --> 00:02:32,960
他们首先需要做一些工作才能做到这一点。

00:02:32,960 --> 00:02:37,550
他们会先从内存池中获取一些交易，

00:02:37,550 --> 00:02:40,490
这个内存池就像一个等候区，存放着最新的交易。

00:02:40,490 --> 00:02:45,620
矿工们会将这些交易汇集到一起，形成一个区块。

00:02:45,620 --> 00:02:47,480
对于这个区块，他们会构造一个区块头，

00:02:47,480 --> 00:02:49,730
它基本上总结了区块内的所有数据。

00:02:49,730 --> 00:02:52,010
我们会对这个区块头进行哈希处理，

00:02:52,010 --> 00:02:56,870
这就是我们要输入到哈希函数中的数据。

00:02:56,870 --> 00:02:58,700
但这里还有一点空间用于存放nonce，

00:02:58,700 --> 00:03:03,980
它是只使用一次的数字。

00:03:03,980 --> 00:03:08,150
所以我会逐一增加这个nonce，

00:03:08,150 --> 00:03:10,160
连同区块头一起，

00:03:10,160 --> 00:03:12,760
然后不断地对它进行哈希处理。

00:03:12,760 --> 00:03:17,150
因为我们的目标是得到一个以特定数量的零开头的哈希结果，

00:03:17,150 --> 00:03:19,459
并且总是低于某个特定的值。

00:03:19,459 --> 00:03:25,280
如果我使用n这个区块头不断改变这个nonce，

00:03:25,280 --> 00:03:29,930
你可以看到我们得到了很多不同的哈希结果。

00:03:29,930 --> 00:03:32,150
所以这就是矿工试图挖掘一个区块的过程。

00:03:32,150 --> 00:03:34,850
他们会做什么呢？他们会尽可能快地进行这个过程，

00:03:34,850 --> 00:03:42,800
试图得到一个以特定数量的零开头的哈希摘要或结果。

00:03:42,800 --> 00:03:46,580
这个目标可能需要花费相当长的时间才能实现。

00:03:46,580 --> 00:03:48,709
这个过程运行得非常慢，

00:03:48,709 --> 00:03:51,980
但幸运的是，这个区块之前已经被挖掘过了，

00:03:51,980 --> 00:03:53,840
所以我知道有效的nonce值是多少。

00:03:53,840 --> 00:03:56,900
如果我再运行一次，

00:03:56,900 --> 00:03:58,370
但是从一个更高的nonce值开始，

00:03:58,370 --> 00:04:00,739
你会看到，

00:04:00,739 --> 00:04:06,080
这个nonce值随机地产生了一个以特定数量的零开头的哈希摘要，

00:04:06,080 --> 00:04:07,940
这个值低于目标值。

00:04:07,940 --> 00:04:11,060
因此这个区块已经被挖掘出来，

00:04:11,060 --> 00:04:13,380
并可以被添加到区块链上。

00:04:13,380 --> 00:04:19,380
矿工不能强制这个过程发生，

00:04:19,380 --> 00:04:25,110
他们能做的只是尽可能快地对区块头进行哈希，

00:04:25,110 --> 00:04:27,510
试图找到一个足够幸运的随机数，

00:04:27,510 --> 00:04:29,460
让你得到的结果低于目标值。

00:04:29,460 --> 00:04:38,670
这在网络中创造了一个无人能强制或控制的竞争，

00:04:38,670 --> 00:04:40,110
保护了已经在区块链中的交易。

00:04:40,110 --> 00:04:46,260
但今天我们关心的是这个哈希函数是如何工作的，

00:04:46,260 --> 00:04:59,280
如何从我的名字Greg或字符串ABC得到这个结果，

00:04:57,360 --> 00:04:59,280
现在将向你展示。

00:04:59,280 --> 00:05:01,860
我对于冗长的介绍感到抱歉。

00:05:01,860 --> 00:05:03,750
但是希望这个过程会很有趣。

00:05:03,750 --> 00:05:09,420
首先，我将从SHA-256使用的一些基本操作开始，

00:05:09,420 --> 00:05:12,960
第一个操作叫做右移。

00:05:12,960 --> 00:05:16,470
SHA-256在位（1和0）上进行操作，

00:05:16,470 --> 00:05:22,530
所有的数据都可以用位表示，

00:05:22,530 --> 00:05:26,400
它在32位的块上操作，

00:05:26,400 --> 00:05:30,210
我们称之为二进制位。

00:05:30,210 --> 00:05:36,360
右移操作就是将位移动一个位置，

00:05:36,360 --> 00:05:38,960
这是一个32位的右移，

00:05:38,960 --> 00:05:42,840
你只是将位向右移动。

00:05:42,840 --> 00:05:49,950
接下来我们有一个右旋转。

00:05:49,950 --> 00:05:52,500
这个操作与右移操作非常相似，

00:05:52,500 --> 00:05:55,620
但它并不是像普通的右移那样丢弃移出的位，

00:05:55,620 --> 00:06:00,480
而是将它们移动到左边以创建这种旋转的位操作，

00:06:00,480 --> 00:06:04,910
因此被称为循环右移。

00:06:04,910 --> 00:06:16,620
接下来我们使用这个叫做异或的操作，

00:06:16,620 --> 00:06:19,110
如果你输入的二进制位中是0和1，

00:06:19,110 --> 00:06:23,220
那么结果就是1。

00:06:23,220 --> 00:06:26,160
让我给你展示一下，

00:06:26,160 --> 00:06:28,530
如果两个位都是0，那么结果就是0，

00:06:28,530 --> 00:06:34,260
如果两个位都是1，那么结果是0，

00:06:34,260 --> 00:06:39,750
如果输入1和0，那么结果就是1。

00:06:39,750 --> 00:06:45,330
这意味着，这可以用来合并多个位，

00:06:45,330 --> 00:06:48,330
以得到一个公平或平衡的所有位的表示。

00:06:48,330 --> 00:06:52,230
例如在这里，

00:06:52,230 --> 00:06:57,080
我在这里对三个位进行了多次异或操作。

00:06:57,080 --> 00:07:00,030
前两个是0，结果是0，

00:07:00,030 --> 00:07:02,250
还有一个是1，

00:07:02,250 --> 00:07:06,210
然后0和1的结果是1，

00:07:06,210 --> 00:07:09,030
所以我们得到的结果是1。

00:07:09,030 --> 00:07:10,860
也许我直接给你展示会更容易理解。

00:07:10,860 --> 00:07:14,640
这是一个关于异或在不同位组合中的动画展示，

00:07:14,640 --> 00:07:17,190
并展示了结果。

00:07:17,190 --> 00:07:20,400
正如我所说，

00:07:20,400 --> 00:07:27,080
它给你一个平衡的三个输入位的表示。

00:07:27,080 --> 00:07:29,730
一半的时间你会得到1，

00:07:29,730 --> 00:07:30,870
一半的时间你会得到0，

00:07:30,870 --> 00:07:34,610
我希望这能让你有所理解。

00:07:34,610 --> 00:07:37,740
最后我们有一个叫做普通加法的操作，

00:07:37,740 --> 00:07:39,630
也就是整数加法。

00:07:39,630 --> 00:07:44,550
所以插入整数加法，

00:07:44,550 --> 00:07:46,530
这只是以二进制表示的数字，

00:07:46,530 --> 00:07:48,930
将它们加在一起，这就是加法，

00:07:48,930 --> 00:07:50,940
就像任何两个数相加，

00:07:50,940 --> 00:07:52,650
用二进制表示它。

00:07:52,650 --> 00:07:55,670
需要注意的是，

00:07:55,670 --> 00:07:59,400
进行加法运算后，

00:07:59,400 --> 00:08:03,360
我们将结果取模2^32，

00:08:03,360 --> 00:08:06,420
所以结果限制了在32位以内。

00:08:06,420 --> 00:08:11,700
如果我们把多个单词加在一起，

00:08:09,120 --> 00:08:11,700
结果大于32位的话，

00:08:11,700 --> 00:08:15,220
那么这个模2^32就能保证它在32位范围内。

00:08:15,220 --> 00:08:22,900
这些就是sha-256哈希函数的构建模块。

00:08:22,900 --> 00:08:25,480
如果你理解了这些，那么剩下的就不难了。

00:08:25,480 --> 00:08:32,890
现在使用这些旋转函数，

00:08:32,890 --> 00:08:34,299
我们可以把它们组合在一起，

00:08:34,299 --> 00:08:38,799
创建这种复合的位移动作。

00:08:38,799 --> 00:08:42,760
这个叫做小写的Sigma 0，

00:08:42,760 --> 00:08:49,900
它只是对这个单词进行7次、18次和3次的旋转，

00:08:49,900 --> 00:08:53,140
然后把它们加在一起得到这个结果。

00:08:53,140 --> 00:08:58,050
所以1+1是1，然后1+1是0，再然后0+1是1，等等。

00:08:58,050 --> 00:09:00,880
它被称为Sigma，没有什么特别的原因，

00:09:00,880 --> 00:09:07,180
只是因为我们想给这些复合的操作或位移动作起个名字。

00:09:07,180 --> 00:09:09,970
我们还有一个叫做小写的Sigma 1，

00:09:09,970 --> 00:09:12,790
完全一样，

00:09:12,790 --> 00:09:14,440
只是旋转次数不同，

00:09:14,440 --> 00:09:19,240
移位的次数也不同。

00:09:19,240 --> 00:09:23,410
第三个是大写的Sigma 0，旋转次数不同，

00:09:23,410 --> 00:09:27,540
然后把它们异或在一起。

00:09:27,540 --> 00:09:31,300
然后我们有第四个，

00:09:31,300 --> 00:09:34,720
也是最后一个旋转复合运动，

00:09:34,720 --> 00:09:37,930
大写的Sigma 1，

00:09:37,930 --> 00:09:40,720
这里有6次、11次和25次的旋转，

00:09:40,720 --> 00:09:43,450
然后把它们异或在一起。所以它们都非常相似，

00:09:43,450 --> 00:09:48,640
唯一的区别是小写的Sigma函数使用了右移，

00:09:48,640 --> 00:09:50,560
所以一些位在这里丢失了，

00:09:50,560 --> 00:09:57,930
而大写的Sigma只做完整的旋转3次在输入单词上。

00:09:57,930 --> 00:10:00,390
最后我们还有两个不使用旋转的函数。

00:10:00,390 --> 00:10:03,210
有一个叫做选择的函数，

00:10:03,210 --> 00:10:11,339
它使用第一个输入来决定是否从第二个或第三个单词中获取输入。

00:10:11,339 --> 00:10:13,890
所以如果是1，它就选择Y，如果是0，它就选择Z。

00:10:13,890 --> 00:10:22,170
所以这里101选择了0，0选择了Z，

00:10:22,170 --> 00:10:25,529
它使用X单词，

00:10:25,529 --> 00:10:28,529
接受三个输入，

00:10:28,529 --> 00:10:31,940
来选择第二或第三个单词的位。

00:10:31,940 --> 00:10:35,029
这就是选择函数。

00:10:35,029 --> 00:10:40,020
最后我们有一个叫做多数的函数可以更容易解释它，

00:10:40,020 --> 00:10:42,270
结果就是三个位的多数。

00:10:42,270 --> 00:10:45,300
这里多数是1就是1，多数是0就是0，

00:10:45,300 --> 00:10:53,190
这就是在sha-256哈希函数中使用的六个函数。

00:10:53,190 --> 00:10:59,940
在我真正介绍哈希函数之前，

00:10:59,940 --> 00:11:06,420
我需要给你们展示一些sha-256使用的常数。

00:11:06,420 --> 00:11:08,220
这些常数最终只是一些看起来随机的位，

00:11:08,220 --> 00:11:13,800
用来混合我们放入哈希函数的消息。

00:11:13,800 --> 00:11:17,160
那么这些常数从哪里来的呢？

00:11:17,160 --> 00:11:28,940
看这里，它取了前64个质数的立方根。

00:11:28,940 --> 00:11:31,860
所以这是13的立方根，

00:11:31,860 --> 00:11:37,080
这是19的立方根。

00:11:37,080 --> 00:11:41,490
但是质数的立方根或平方根会给你一个无理数的结果，

00:11:41,490 --> 00:11:45,750
所以这个分数是无理数。

00:11:45,750 --> 00:11:47,790
这个过程将会持续下去，

00:11:47,790 --> 00:11:49,890
看起来相当随机，

00:11:49,890 --> 00:11:51,779
因此它是一个很好的常数来源。

00:11:51,779 --> 00:11:54,149
如果我们选择了具体的常数，

00:11:54,149 --> 00:11:57,899
别人可能会设计出包含后门的sha256。

00:11:57,899 --> 00:12:05,600
但通过使用这些公开已知的随机位、立方根和质数，

00:12:05,600 --> 00:12:07,339
我们得到了这些看起来很漂亮的常数，

00:12:07,339 --> 00:12:08,630
它们看起来相当随机，有助于我们混淆信息。

00:12:08,630 --> 00:12:14,240
这是对前64个质数进行的，

00:12:14,240 --> 00:12:18,949
这给我们提供了64个我们将要使用的常数。

00:12:18,949 --> 00:12:21,110
在哈希函数中，所有这些随机位都在这里。

00:12:21,110 --> 00:12:31,069
现在我们终于可以进入SHA-256哈希算法了。

00:12:31,069 --> 00:12:34,519
我将在这里哈希字符串ABC，

00:12:34,519 --> 00:12:42,350
并逐步讲解哈希函数的每个部分。

00:12:42,350 --> 00:12:44,149
首先我们有ABC这个字符串，

00:12:44,149 --> 00:12:48,829
你可能已经注意到，

00:12:48,829 --> 00:12:50,389
哈希函数在单个位上工作，

00:12:50,389 --> 00:12:52,490
数据的1和0。

00:12:52,490 --> 00:12:55,370
所有数据都可以用1和0表示。

00:12:55,370 --> 00:12:57,800
所以这里的字符串A、B和C，

00:12:57,800 --> 00:13:05,380
每个字母都有自己在ASCII表中对应的数字。

00:13:05,380 --> 00:13:10,130
A是97，B是98，C是99，

00:13:10,130 --> 00:13:14,689
然后我们可以将这些数字转换为二进制表示。

00:13:14,689 --> 00:13:16,399
所以这就是ABC在二进制中的样子，

00:13:16,399 --> 00:13:19,480
这就是我们要放入哈希函数的内容。

00:13:19,480 --> 00:13:22,970
在我们开始对其哈希之前，

00:13:22,970 --> 00:13:24,889
我们首先需要对它进行填充，

00:13:24,889 --> 00:13:32,209
因为哈希函数喜欢一次处理512位的数据。

00:13:32,209 --> 00:13:34,339
这只有24位的数据，

00:13:34,339 --> 00:13:36,110
所以我们需要用零填充它，使其达到512位。

00:13:36,110 --> 00:13:39,439
但在我们这样做之前，

00:13:39,439 --> 00:13:43,220
我们在0后面放一个1，

00:13:45,139 --> 00:13:47,449
作为信息和零之间的分隔符。

00:13:47,449 --> 00:13:49,490
我们添加了零，

00:13:49,490 --> 00:13:51,829
但是你会注意到这里略小于512，

00:13:51,829 --> 00:13:54,610
因为我们在末尾留下了64位，

00:13:54,610 --> 00:14:03,079
因为在最后64位中我们对消息长度进行编码。

00:14:03,079 --> 00:14:06,410
这里的消息是24位，

00:14:06,410 --> 00:14:08,930
这就是用二进制表示24的方式。

00:14:08,930 --> 00:14:12,829
因此，最后64位无论长度多少，

00:14:12,829 --> 00:14:17,760
都是为消息的长度或消息的大小保留的。

00:14:17,760 --> 00:14:19,950
我们已经将我们的消息填充到512位，

00:14:19,950 --> 00:14:22,620
这是哈希函数想要的哈希。

00:14:22,620 --> 00:14:30,360
如果我们的消息略大于512，

00:14:30,360 --> 00:14:34,080
它将被填充到最接近的512位的倍数，

00:14:34,080 --> 00:14:37,710
将有1024位。

00:14:37,710 --> 00:14:41,040
因为它是512的倍数，所以一旦填充它，

00:14:41,040 --> 00:14:44,180
我们就将它分割成512位的块。

00:14:44,180 --> 00:14:47,400
因为这已经是512位，

00:14:47,400 --> 00:14:49,410
只有一个消息块，

00:14:49,410 --> 00:14:58,190
但是如果它更大，我们可能会从原始消息知道2、3、4个消息块。

00:14:58,190 --> 00:15:02,580
所以这个消息块就是要放入哈希函数的内容。

00:15:02,580 --> 00:15:04,200
我们已经准备好了要被哈希的消息。

00:15:04,200 --> 00:15:10,650
首先，我们需要从每个消息块创建一个消息计划。

00:15:10,650 --> 00:15:16,800
这就是消息块和消息计划，

00:15:16,800 --> 00:15:18,690
基本上就是把它分割成32个词。

00:15:18,690 --> 00:15:30,750
我们只需使用块中的数据来构造的前16个词。

00:15:30,750 --> 00:15:32,760
然而，这个消息计划实际上需要是64个词长，

00:15:32,760 --> 00:15:38,700
所以我们需要扩展或扩大它另外48个词，达到64个词。

00:15:38,700 --> 00:15:47,700
我们做这个的方式是使用已经在消息计划中的一些词来创建计划中的下一个词。

00:15:52,070 --> 00:15:57,270
所以这里的第16个词，它使用了计划中的第16个词，

00:15:57,270 --> 00:16:00,240
以及第15个、第7个，然后减去两个词。

00:16:00,240 --> 00:16:08,520
但在这个词上，

00:16:08,520 --> 00:16:10,980
我们对它进行了一个小写的Sigma零旋转，

00:16:10,980 --> 00:16:14,040
而在这个词上，我们对它进行了一个大写的Sigma一旋转。

00:16:14,040 --> 00:16:15,900
你可以看到，这些又变成了零，

00:16:15,900 --> 00:16:19,410
因为旋转只是旋转一堆零，

00:16:19,410 --> 00:16:21,120
并将它们异或在一起，

00:16:21,120 --> 00:16:22,290
总是得到零。

00:16:22,290 --> 00:16:25,320
所以这很无聊，

00:16:25,320 --> 00:16:31,070
这就是为什么这个在消息计划中的新词和这个词完全一样，

00:16:31,070 --> 00:16:33,870
因为这个加上那个再加上那个再加上那个就得到了这个。

00:16:33,870 --> 00:16:37,110
这很无聊，

00:16:37,110 --> 00:16:39,600
但是当你向下移动消息计划时，

00:16:39,600 --> 00:16:42,390
你会看到我们正在扩展它，

00:16:42,390 --> 00:16:46,470
并且再次将很多新的位扩展到计划中。

00:16:46,470 --> 00:16:57,570
所以这些旋转函数使用消息块中的现有数据进行融合并扩展消息计划，

00:16:57,570 --> 00:17:01,860
以此生成大量新的位。

00:17:01,860 --> 00:17:04,260
这就是消息计划中的最后一个词，

00:17:04,260 --> 00:17:06,780
以便更直观地展示其工作方式。

00:17:06,780 --> 00:17:10,230
这是一个动画，

00:17:10,230 --> 00:17:12,930
如我所说，它取现有的词，

00:17:12,930 --> 00:17:23,130
然后旋转它们，然后将它们加在一起以在计划中创建新的词。

00:17:23,130 --> 00:17:25,160
这是非常有创意的。

00:17:25,160 --> 00:17:29,120
在计划中的第63或64个词。

00:17:29,120 --> 00:17:31,260
我们现在知道你已经准备好了，

00:17:31,260 --> 00:17:32,820
扩展了消息块的Metis计划，

00:17:32,820 --> 00:17:38,190
这就是我们将要在主哈希函数中使用的，

00:17:38,190 --> 00:17:39,870
以及我之前提到的常数。

00:17:39,870 --> 00:17:45,030
正如我所说，

00:17:45,030 --> 00:17:46,410
现在我们进入哈希函数的压缩部分，

00:17:46,410 --> 00:17:50,010
这是哈希函数的真正核心，

00:17:50,010 --> 00:17:59,250
所有的比特都会被压缩在一起并堆叠在一起以创建最终的消息摘要。

00:17:59,250 --> 00:18:03,600
但首先，我们需要初始化这个压缩函数中的哈希值。

00:18:03,600 --> 00:18:06,480
这些被称为状态寄存器或工作变量，

00:18:06,480 --> 00:18:09,870
有8个插槽用于存放数据。

00:18:09,870 --> 00:18:14,880
这些寄存器的初始化方式类似于常数，

388
00:18:14,880 --> 00:18:16,980
使用质数的平方根，

00:18:16,980 --> 00:18:22,050
这将给你一个好的小的有理分数部分，

00:18:22,050 --> 00:18:24,180
或者一些随机位来初始化哈希。

00:18:24,180 --> 00:18:27,870
取它的小数部分，

00:18:27,870 --> 00:18:31,230
乘以2的32次方。

00:18:31,230 --> 00:18:33,750
这样我们就可以得到32位的数据。

00:18:33,750 --> 00:18:36,410
这就是我们在整数形式下的结果，

00:18:36,410 --> 00:18:38,880
用于将其转化为二进制后，我们就得到了初始的哈希值。

00:18:38,880 --> 00:18:41,220
我们就得到了初始的哈希值。

00:18:41,220 --> 00:18:43,470
所以你的哈希值会像这个样子开始，

00:18:43,470 --> 00:18:51,360
然后我们会使用消息计划来修改它。现在

00:18:51,360 --> 00:18:53,160
现在我们要进入压缩函数，

00:18:53,160 --> 00:18:55,890
我们将从第一个消息块中取出消息计划，

00:18:55,890 --> 00:18:59,250
然后将其压缩到这些阶段寄存器中。

00:18:59,250 --> 00:19:03,030
取出第一个词，

00:19:03,030 --> 00:19:05,820
对于消息计划中的每一个词我们都会这样做。这

00:19:05,820 --> 00:19:07,410
这是第一个词，

00:19:07,410 --> 00:19:12,960
这是常量中的第一个词。

00:19:12,960 --> 00:19:19,410
在我们修改任何东西之前，我们首先需要创建两个临时词。

00:19:19,410 --> 00:19:21,800
看一下复杂的条形图，如果不太清楚。

00:19:21,800 --> 00:19:23,690
让我来给你看一个动画。

00:19:23,690 --> 00:19:29,490
这是第一个临时词，

00:19:29,490 --> 00:19:31,530
你选择EF和G这三个，

00:19:31,530 --> 00:19:36,000
得到这个结果。

00:19:36,000 --> 00:19:38,460
然后你对E进行大写的Sigma旋转，

00:19:38,460 --> 00:19:44,460
然后你取H，

00:19:44,460 --> 00:19:46,380
然后将这三个加在一起，

00:19:46,380 --> 00:19:49,710
再加上消息计划中的词，

00:19:49,710 --> 00:19:51,780
以及当前的常量，

00:19:51,780 --> 00:19:57,060
这就给出了这个临时词。

00:19:57,060 --> 00:19:59,400
这是第一个，

00:19:59,400 --> 00:20:02,190
然后第二个临时词稍微简单一些，但也相当相似，

00:20:02,190 --> 00:20:10,370
它取前三个a，b，c中的大部分

00:20:10,370 --> 00:20:22,080
然后对状态寄存器中的第一个词进行Sigma 0旋转，

00:20:22,080 --> 00:20:25,050
然后把它们加在一起就得到了t2。

00:20:25,050 --> 00:20:33,060
我们将在稍后使用这些来更新这些哈希值中的数据。

00:20:33,060 --> 00:20:35,490
现在我们将进入有趣的部分。

00:20:35,490 --> 00:20:37,920
我将进行一轮压缩，

00:20:37,920 --> 00:20:42,120
我们将所有的词在状态寄存器中向下移动一位，

00:20:42,120 --> 00:20:44,190
然后在a位置上空出一个空位，

00:20:44,190 --> 00:20:46,760
丢掉最后一个词。

00:20:46,760 --> 00:20:51,090
在a位置加上t1和t2，

00:20:51,090 --> 00:20:56,010
在e位置我们加上t1。

00:20:56,010 --> 00:21:00,210
所以，我们向下移动每一个词，把一个新词放入a位置，

00:21:00,210 --> 00:21:04,350
并更新e位置。

00:21:04,350 --> 00:21:06,360
这个过程对于消息计划中的每一个词都会重复，

00:21:06,360 --> 00:21:09,570
所以我们有63个词，63个常量，我们将对每个词进行压缩。

00:21:09,570 --> 00:21:18,380
我们将对消息计划中的每个词进行压缩。

00:21:18,380 --> 00:21:22,520
这个过程将继续进行，

00:21:22,520 --> 00:21:32,239
直到每一个词都被压缩。

00:21:32,239 --> 00:21:39,419
然后我们得到最后一个词，

00:21:39,419 --> 00:21:42,989
再次更新状态寄存器，

00:21:42,989 --> 00:21:49,559
我们已经将主计划中的每一个单词都压缩到了这些状态寄存器中。

00:21:49,559 --> 00:21:52,079
最后一部分，

00:21:52,079 --> 00:21:54,149
这是压缩的最后一个部分，

00:21:54,149 --> 00:21:56,759
该消息块将采用开始时的初始哈希值，

00:21:56,759 --> 00:22:01,529
然后加上压缩的结果。

00:22:01,529 --> 00:22:07,979
这样我们就得到了第一个消息块的哈希值。

00:22:07,979 --> 00:22:13,199
这个过程将会对每一个消息块重复。

00:22:13,199 --> 00:22:14,399
对于下一个消息块，

00:22:14,399 --> 00:22:15,989
我们将使用这些值作为初始哈希值，

00:22:15,989 --> 00:22:18,149
然后进行消息计划，

00:22:18,149 --> 00:22:21,479
然后进行压缩。

00:22:21,479 --> 00:22:23,369
这个过程将会对每一个消息块重复，

00:22:23,369 --> 00:22:28,499
每一个消息块都会被压缩到现有的哈希值上。

00:22:28,499 --> 00:22:33,299
一旦对每一个消息块都执行了这个操作，

00:22:33,299 --> 00:22:35,399
就会在状态寄存器中剩下一些最终值，

00:22:35,399 --> 00:22:38,339
这些就是最终的哈希值。

00:22:38,339 --> 00:22:45,239
最终的哈希值就是我们把每一个词转换成十六进制，

00:22:45,239 --> 00:22:48,599
然后把它们连接在一起，

00:22:48,599 --> 00:22:53,309
我们就得到了最终的消息摘要。

00:22:53,309 --> 00:22:57,589
这就是SHA-256的工作原理。



